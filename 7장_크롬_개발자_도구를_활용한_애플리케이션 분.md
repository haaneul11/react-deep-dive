# 크롬 개발자 도구를 활용한 애플리케이션 분석

자바스크립트 메모리, 네트워크, 소스, 실제 HTML 및 CSS 등 리액트가 아닌 일반적인 웹 애플리케이션 환경의 디버깅을 수행하려면 리액트 개발 도구가 아닌 좀 더 범용적인 도구를 활용해야 한다.

일반적인 브라우저 환경에서 발생할 수 있는 문제를 디버깅할 수 있는 도구를 브라우저 개발자 도구라고 한다.

# 📑 크롬 개발자 도구란?

크롬 개발자 도구란 크롬에서 제공하는 개발자용 도구로, 웹페이지에서 일어나는 거의 모든 일을 확인할 수 있는 강력한 개발 도구이다.

이 개발 도구를 확인하려면 먼저 디버깅하고 싶은 페이지에 접속한 뒤 메뉴에서 **보기 → 개발자 도구** 순으로 선택하면 된다. 또는 웹페이지에서 마우스 오른쪽 버튼을 클릭한 뒤 **검사**를 누르면 마찬가지로 개발자 도구를 볼 수 있다.

개발자 도구를 열면 하단이나 오른쪽에 새로운 창이 나타난다.

![Untitled](https://github.com/user-attachments/assets/8ecf5ad4-9760-41a1-9024-b0d943dc8271)
❣️ 크롬 개발자 도구에서 웹사이트를 제대로 디버깅하고 싶다면 시크릿 모드 또는 프라이빗 모드라 불리는 개인정보 보호 모드에서 페이지와 개발자 도구를 여는 것을 권장한다.

→ 브라우저에 설치되어 있는 각종 확장 프로그램 때문이다.

→ 브라우저 확장 프로그램은 웹페이지 방문 시 확장 프로그램의 실행을 위해 전역 변수나 HTML 요소에 실제 웹 애플리케이션이 제공하지 않은 다른 정보를 추가할 수 있다. 그리고 이 정보는 개발자가 추가한 정보가 아닐뿐더라 다른 사용자에게서는 볼 수 없는 정보로서 디버깅하는 데 방해가 될 수 있다.

→ 개인정보 보호 모드에서는 브라우저에 설치돼 있는 각종 확장 프로그램이 실행되지 않기 때문에 순수하게 웹페이지와 관련된 정보만 확인할 수 있다.

# 📑 요소 탭

크롬 개발자 도구에서 첫 번째로 노출되는 탭은 요소(Element) 탭이다.

→ 현재 웹페이지를 구성하고 있는 HTML, CSS 등의 정보를 확인할 수 있다.

## 🖌️ 요소 화면

왼쪽 화면은 현재 웹페이지를 구성하는 HTML을 나타낸다.

→ 이 중에서 원하는 태그를 클릭하면 브라우저 페이지의 해당 요소가 강조되고, 해당 태그와 관련된 정보를 확인할 수 있다.

![Untitled 1](https://github.com/user-attachments/assets/f4f5a491-0daa-422b-a4eb-2a5ebbe8d2ec)

→ 크롬 개발자 도구의 요소 탭에서 특정 요소를 클릭한 모습

- 요소 화면에서는 단순히 현재 HTML을 보는 것뿐만 아니라 직접 코드를 수정해서 웹페이지에서 어떻게 보이는지 빠르게 확인할 수 있다.
- 수정하고 싶은 요소를 더블클릭해 태그명이나 클래스 등 요소와 관련된 정보를 수정하거나, 오른쪽 화면에서 스타일을 수정할 수도 있다.
  → 이렇게 웹페이지의 DOM을 직접적으로 수정하면 프로덕션으로 개발된 페이지에서 수정된 내용이 어떻게 보이는지 미리 확인할 수 있어 편리하고, 개발 모드에서도 리액트 코드를 수정해 핫 리로딩(hot reloading)을 거치지 않아도 확인할 수 있으므로 빠른 작업이 가능하다.
- 만약 배너와 같이 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM이 있다면 요소의 중단점을 사용해 디버깅할 수 있다. 먼저 디버깅하고 싶은 요소를 선택하고 마우스 오른쪽 버튼을 클릭한 후 중단 위치를 선택하고 중단을 원하는 옵션을 클릭하면 된다.
  ![Untitled 2](https://github.com/user-attachments/assets/a75fb7cc-5b31-483a-898c-fa6e1ff12282)
  → 크롬 개발자 도구의 요소 탭에서 디버깅하고 싶은 요소를 대상으로 마우스 오른쪽 클릭하고 중단 위치를 설정해 둔 모습
  → 이와 같이 중단 위치를 설정해 두면 중단과 관련된 작업이 일어날 때마다 브라우저가 렌더링을 중단하고 해당 요소 변경을 일으킨 소스코드를 보여준다.

![Untitled 3](https://github.com/user-attachments/assets/e9c7d0e3-85c3-4946-b3b0-6050b7ceb7ef)

→ 요소의 중단점이 확인해 준 요소의 변경을 일으킨 소스 파일

- 중단점에서 보면, 이 요소의 경우 해당 노드의 class명을 수정하려는 작업이 리액트에서 일어났다는 사실을 확인할 수 있다. 따라서 리액트에서 해당 요소의 클래스를 수정하는 코드를 찾아보면 된다는 실마리를 얻을 수 있다.
- 이 외에도 요소에 속성을 추가, 수정, 삭제하거나 해당 요소를 스크린숏으로 캡쳐하거나 숨기는 등 HTML DOM과 관련된 다양한 작업을 수행할 수 있다.

## 🖌️ 요소 정보

- `스타일` : 요소와 관련된 스타일 정보를 나타낸다. 어떤 클래스, 태그명, 아이디 등으로 매핑되어 설정된 스타일인지 확인할 수 있고, 또한 스타일이 선언돼 있는 파일도 확인할 수 있다. 요소와 마찬가지로 이 스타일 정보의 내용도 수정해 페이지에 어떻게 반영되는지 미리 확인해 볼 수 있다.
- `계산됨` : 해당 요소의 크기, 패딩(padding), 보더(border), 마진(margin)과 각종 CSS 적용 결과값을 알 수 있는 탭이다. 스타일 탭은 어떤 스타일이 어디서 왔는지를 나타낸다면, 계산됨에서는 그렇게 적용된 스타일이 결과적으로 어떤 결과물로 나타나는지 확인할 수 있다.
- `레이아웃` : CSS 그리드나 레이아웃과 관련된 정보를 확인할 수 있다.
- `이벤트 리스너` : 현재 요소에 부착된 각종 이벤트 리스너를 확인할 수 있다. 상위 버튼을 체크 해제하면 딱 해당 요소에 명확하게 부탁된 이벤트만 볼 수 있다. 그러나 이벤트 버블링 등으로 이벤트를 발생시키는 경우네는 확인할 수 없다. 이 기능은 이후에 리액트 17의 변경 사항 중 하나인 이벤트 위임의 변경에서 확인해 본다.
- `DOM 중단점` : 앞에서 설명한 중단점이 있는지 알려주는 탭이다.
- `속성` : 해당 요소가 가지고 있는 모든 속성값을 나타낸다. 기본적으로 자바스크립트에서 해당 DOM으로 .attributes를 실행했을 때 나오는 결과와 비슷하지만 .attributes는 직접 할당된 값만 나오는 반면 속성 탬에는 모든 값이 나온다는 차이가 있다. 해당 요소가 가지고 있는 모든 값을 확인하고 싶다면 속성 탭을 확인해 보자.
- `접근성` : 접근성이랑 웹 이용에 어려움을 겪는 장애인, 노약자를 위한 스크린리더기 등이 활용하는 값을 말한다. 접근성 탭에서는 이러한 접근성 정보를 확인할 수 있다.

왼쪽 요소 화면이 웹페이지 요소의 구조를 확인하고, 추가, 수정, 삭제를 할 수 있는 공간이라면 오른쪽 요소 정보에서는 해당 요소와 관련된 모든 정보를 확인할 수 있다.

이 메뉴를 사용하면 브라우저에서 해당 DOM이 왜 이런 모습으로 페인딩됐는지에 대한 모든 단서를 확인할 수 있다. 이뿐만 아니라 DOM에 추가돼 있는 이벤트 리스너, 접근석 등 DOM과 관련된 모든 정보를 확인할 수 있으므로 DOM과 관련된 정보가 필요하다면 이 요소 탭을 활용하면 좋다.

# 📑 소스 탭

소스 탭에서는 웹 애플리케이션을 불러오기 위해 실행하거나 참조된 모든 파일을 확인할 수 있다. 자바스크립트 파일부터, CSS, HTML, 폰트까지 다양한 파일 정보를 확인할 수 있다.

✅ 소스 탭 화면

![Untitled 4](https://github.com/user-attachments/assets/3c510aa3-ca16-4a5f-8c57-461f3174287f)

소스 탭은 파일을 선택해야 정보가 보이게 된다.

프로덕션 모드의 경우 파일이 모두 압축돼 있기 때문에 디버깅하기가 매우 불편하지만 개발 모드에서는 유용하게 사용할 수 있다.

ex) create-react-app으로 생성된 프로젝트를 개발 모드에서 실행한 후, 브라우저에서 해당 페이지에 접근해보면 create-react-app을 기반으로 생성된 다양한 파일을 찾아볼 수 있다.

![Untitled 5](https://github.com/user-attachments/assets/248c8a57-5e0b-479a-8b77-f3416ae92fc8)

→ 개발 모드로 실행한 웹사이트에서 크롬 개발자 도구를 연 뒤 ‘열기’로 파일을 찾으면 위와 같은 창이 뜬다.

→ 이렇게 찾은 코드의 실제 내용도 확인할 수 있다.

![Untitled 6](https://github.com/user-attachments/assets/1b0a9e6e-0f7d-4581-b572-5797d7779558)

소스 탭은 요소 탭에서 DOM 중단점을 만들어 DOM이 변경되는 과정을 디버깅해 볼 수 있던것처럼 여기서도 소스 중단점을 생성해 자바스크립트 실행을 중단시키고 디버깅을 수행할 수 있다.

→ 코드에 debugger를 선언하는 것과 동일한 역할을 한다.

→ 소스코드를 오염시키지 않아 더 유용하다.

✅ 소스 탭에서 useEffect에 중단점을 생성해 중단시키는 화면

![Untitled 7](https://github.com/user-attachments/assets/a4a7a6f6-01d9-4833-a22f-dfed047dad1b)

→ useEffect 내부 코드에 중단점을 만들어 useEffect 내부에서 어떠한 일이 일어나는지 알 수 있다.

→ 중단점을 만들어 다음 코드 시작을 중지할 수 있고, 이전에 할당한 변수에는 어떤 값이 들어있는지 확인할 수 있다.

→ 오른쪽 패널에서도 요소 탭과 마찬가지로 해당 소스 파일과 코드 실행과 관련된 다양한 정보를 확인할 수 있다.

→ 만약 작성한 파일 이외에 다른 곳, 예를 들어 리액트 파일 내에서 중단점을 생성해 보고 싶으면 해당 소스 파일을 찾아 중단점을 걸어보는 것도 가능하다.

![Untitled 8](https://github.com/user-attachments/assets/23459215-94a6-4c8f-aae9-f8f60bb6a7b0)

useEffect에 중단점을 걸어 디버깅한 결과

- create라 선언된 useEffect를 만드는 함수, 그리고 deps라고 선언된 의존성 배열(여기서는 의존성 배열을 별도로 명시하지 않아 undefined가 할당됐다) 등을 확인할 수 있다.
- 이와같이 사용 중인 라이브러리에서 버그가 의심되는 지점을 디버깅하거나 실제로 소스코드상에서 어떤 식으로 작동하는지 확인하고 싶을 때 매우 유용하다.

소스 탭 오른쪽에 제공하는 정보와 기능은 다음과 같다.

- `감시` : 감시는 말 그대로 감시하고 싶은 변수를 선언하고, 해당 변수의 정보를 확인할 수 있는 메뉴다. 왼쪽에서 제공하는 변수 외에 디버깅 시점에서 특정 변수의 값을 알고 싶다면 이 감시를 활용하면 된다.
  ![Untitled 9](https://github.com/user-attachments/assets/64ec9f65-5f76-4870-9e7e-623210d72a87)
  → 개발자가 추적하고 싶은 변수를 적어두고 현재 값이 무엇인지 실시간으로 확인할 수 있다.
  감시로 확인할 수 있는 정보가 있다면 해당 변수의 값을, 확인할 수 없는 값은 <not availble>로 표시되는 것을 볼 수 있다.
- `중단점` : 현재 웹사이트에서 추가한 중단점을 확인할 수 있다. 현재 열려 있는 파일뿐만 아니라 웹페이지 전체에 걸쳐 소스 탭에서 추가한 모든 중단점을 확인할 수 있다.
- `범위` : 범위는 이름 그대로 현재 중단점에서의 스코프를 의미한다. 로컬은 현재 로컬 스코프를 의미하며, 이 스코프에서 접근할 수 있는 값을 확인할 수 있다. 이 밖에도 클로저, 전역 스코프 등을 확인할 수 있다.
  ![Untitled 10](https://github.com/user-attachments/assets/55873403-b051-4d21-a790-6a83710545d1)
- `호출 스택` : 호출 스택에서는 현재 중단점의 콜스택을 확인할 수 있다. 이 메뉴를 활용하면 자바스크립트 코드가 실행되며 생성되는 실행 콘텍스트가 어떻게 저장되어 현재 어떤 모습을 하고 있는지 직접 볼 수 있다.
- `전역 리스너` : 현재 전역 스코프에 추가된 리스너 목록을 확인할 수 있다.
- `XHR/가져오기, DOM, 이벤트 리스너, CSP 위반 중단점` : 소스의 중단점 이외에 다양한 중단점을 확인할 수 있다.

소스 탭에서는 실제 애플리케이션을 실행하는 데 사용된 파일을 직접 볼 수 있을뿐만 아니라 중단점을 설정해 두면 빌드된 자바스크립트 또는 실제 개발 중인 스크립트 파일이 어떻게 실행되는지 눈으로 확인할 수 있다.

변수의 값을 미리 보여주는 기능, 감시에 변수를 추가해 실제 변수값을 확인하는 기능을 사용한다면 굳이 번거롭게 변수마다 console.log로 디버깅하지 않아도 훨씬 빠르게 필요한 정보를 확인할 수 있다.

또한 자바스크립트 파일에서는 확인할 수 없는 스코드, 호출 스택 등 현재 자바스크립트가 실행되고 있는 구조도 확인 가능하다.

⭐ 소스 탭은 웹사이트 디버깅 시 요소 탭과 가장 자주 사용되는 도구이다.

# 📑 네트워크 탭

네트워크 탭에는 해당 웹페이지를 접속하는 순간부터 발생하는 모든 네트워크 관련 작동이 기록된다.

웹사이트에서 자주 사용하는 HTTP 요청부터 웹 소켓에 이르기까지, 웹페이지가 외부 데이터와 통신하는 정보를 확인하고 싶다면 네트워크 탭을 참조하면 된다.

![Untitled 11](https://github.com/user-attachments/assets/0efe6f44-6a98-46ea-a6f1-8f2d11b1de6c)

→ create-react-app으로 생성한 애플리케이션에 useEffect를 추가해 내부에서 API를 호출하도록 만든 코드, 네트워크 탭에서는 해당 코드의 네트워크 통신 기록을 보여준다.

create-react-app으로 생성된 기본 웹페이지에 useEffect를 추가해 API를 요청하는 코드를 추가한 후 웹페이지가 로딩되는 동안 발생한 네트워크 요청을 네트워크 탭에서 확인해 봤다.

- 상단에는 네트워크 탭과 관련된 다양한 메뉴가 있다. 전체와 Fetch/XHR, JS 등의 탭으로 보고 싶은 네트워크 요청 종류를 필터링할 수 있으며, 기타 다른 체크박스를 선택해 보고 싶은 네트워크 종류를 제한할 수 있다.
- 왼쪽에는 실제 해당 페이지를 불러오는 과정에서 발생한 네트워크 요청 목록을 나온다. 이 네트워크 요청을 통해 페이지가 로딩되는 과정을 대략적으로 확인해 볼 수 도 있다.
- 웹페이지는 최초에 HTML을 다운로드하고, HTML을 파싱하는 과정에서 만난 자바스크립트를 다운로드한다.
  → 개발자 모드로 실행되면 웹 소켓을 통해 핫 리로딩되는 것을 확인할 수 있다.
- 그리고 웹페이지 어디선가 [https://jsonplaceholder.typicode.com/todos/1을](https://jsonplaceholder.typicode.com/todos/1을) 불러온다.

네트워크 탭에서 위 API 요청이 2번 실행된것으로 보이는데 의도된 코드라면 상관없지만 리액트에서 동일한 주소의 요청이 두 번 실행되는 경우는 대부분 잘못된 useEffect의 사용으로 발생하는 문제이므로 네트워크 탭을 자세히 들여다보면 이와같이 리액트 코드에 문제가 있는지도 확인할 수 있다.

![Untitled 12](https://github.com/user-attachments/assets/e42966d0-54de-4934-9ff1-caa87db3bbc7)

→ 네트워크 요청 흐름에 따라 웹페이지가 어떻게 로딩되고 있는지 확인할 수 있다.

→ 페이지를 불러오는 기간 동안 발생한 총 요청 건수와 총 다운로드한 업로드 리소스의 크기를 확인 할 수도 있다.

→ 만약 모바일 웹페이지를 개발하는 것이라면 총 리소스의 크기만큼 사용자가 모바일 네트워크 비용을 지불해야 하기 때문에 단지 비용뿐만이 아니라 속도에도 영향을 미치는 문제이므로 가급적 네트워크 리소스 요청 횟수와 크기를 줄일 필요가 있다.

- 또한 리소스 크기가 크면 gzip이나 brotli를 적절히 활용해 리소스를 압축하거나 이미지가 있다면 이미지를 최적화할 필요도 있다.

넷플릭스 홈페이지를 불러오는 네트워크 요청을 확인해보자.

네트워크 탭에서 시간이 지남에 따라 배경이 없었던 화면에 이미지 다운로드가 완료되면서 배경이 완성되어 간다.

코드 내부에서 발생하는 fetch 요청 이외에도 외부 CDN에서 가져오는 이미지 리소스 요청 등도 확인할 수 있기 때문에 사용자에게 먼저 노출되거나, 노출되는 영역이 큰 중요한 콘텐츠가 우선적으로 다운로드 되는지, 혹은 넷플릭스의 배경 이미지처럼 조금 우선순위가 낮은 이미지가 나중에 다운로드되는지 등을 확인할 수 있다.

무엇보다 페이지가 자연스럽게 완성되는 모습을 보여주는 것이 중요하다.

⭐ 네트워크 탭을 통해 웹페이지 로딩 과정 중에 발생하는 네트워크 요청을 확인해봤다. 이때 집중적으로 확인해 봐야 하는 점은 다음과 같다.

- 불필요한 요청 또는 중복되는 요청이 없는지
- 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
- 리소스를 불러오는 속도는 적절한지 또는 너무 속도가 오래 걸리는 리소스는 없는지
- 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

# 📑 메모리 탭

메모리 탭에서는 현재 웹페이지가 차지하고 있는 메모리 관련 정보를 확인할 수 있다.

이 탭은 크롬 개발자 도구에서 제공하는 도구 중 가장 난이도가 높고 까다롭다. 하지만 애플리케이션에서 발생하는 메모리 누수, 속도 저하, 혹은 웹페이지 프리징 현상을 확인할 수 있는 유용한 도구이다.

✅ 메모리 메뉴의 모습

![Untitled 13](https://github.com/user-attachments/assets/77105515-b116-487b-ac0c-3be2d17dba7d)

메모리 탭을 열면 리액트 개발 도구의 프로파일과 비슷하게 프로파일링 작업을 거쳐야 원하는 정보를 볼 수 있다.

다른 크롬 개발자 도구인 요소나 다른 탭과는 다르게 메모리 탭 그 자체만으로는 아무것도 할 수 없다.

프로파일 유형이 크게 세 가지 있는데 각 프로파일링의 유형은 다음과 같은 특징이 있다.

- `힙 스냅샷` : 스냅샷이라는 이름에 걸맞게 현재 메모리 상황을 사진 찍듯이 촬영할 수 있다. 현재 시점의 메모리 상황을 알고 싶다면 힙 스냅샷을 활용하면 된다.
- `타임라인의 할당 계측` : 현재 시점의 메모리 상황이 아닌, 시간의 흐름에 따라 메모리의 변화를 살펴보고 싶다면 타임라인의 할당 계측을 사용하면 된다. 주로 로딩이 되는 과정의 메모리 변화 또는 페이지에서 어떠한 상호작용을 했을 때 메모리의 변화 과정을 알고 싶을 때 사용한다.
- `할당 샘플링` : 메모리 공간을 차지하고 있는 자바스크립트 함수를 볼 수 있다.

## 🖌️ 자바스크립트 인스턴스 VM 선택

하단에 위치한 자바스크립트 VM 인스턴스 선택 항목을 살펴보면 현재 실행 중인 자바스크립트 VM 인스턴스를 확인할 수 있다.

![Untitled 14](https://github.com/user-attachments/assets/328b9626-e304-4c4e-a6b7-41f206e473e8)

→ 메모리에서 자바스크립트 가상머신 인스턴스를 선택할 수 있는데, 이곳에서 메모리 현황을 알고 싶은 인스턴스를 선택하고 시작하면 된다.

→ 개발자가 디버깅하고 싶은 자바스크립트 VM 환경을 선택하면 된다.

→ 환경별 힙 크기가 나오는데, 실제 해당 페이지가 자바스크립트 힙을 얼마나 점유하고 있는지 나타낸다.

(! 이 크기만큼 사용자의 브라우저에 부담을 주기 때문에 불필요하게 크기가 늘어나지 않는지 눈여겨볼 필요가 있다)

## 🖌️ 힙 스냅샷

힙 스냅샷은 현재 페이지의 메모리 상태를 확인해 볼 수 있는 메모리 프로파일 도구이다.

힙 스냅샷을 촬영하는 시점을 기준으로 마치 사진으로 촬영하듯 메모리 현황을 보여준다.

아래는 힙 스냅샷 도구를 유용하게 활용하는 방법을 알려주기 위해 극단적으로 잘못된 코드로 디버깅을 해보았다.

```jsx
const DUMMY_LIST = []

export default function App() {
	function handleClick() {
		Array.form({ length: 10_000_000 }).forEach((_, idx) =>
			DUMMY_LIST.push(Math.random() * idx),
		)
		alert('complete!')
	}

	return <button onClick={handleClick}>BUG</dutton>
}
```

→ 이 코드는 버튼을 클릭하면 컴포넌트 외부에 있는 배열에 천만 개의 랜덤한 값을 push한다. 이로 인해 실제 메모리에서는 어떤 일이 벌어지는지 알아보자.

우선 페이지에 진입하고, 페이지 로딩이 완료되면 힙 스냅샷 촬영을 한 번 수행한다.

![Untitled 15](https://github.com/user-attachments/assets/21fd26e9-3938-43ef-bcbf-0d69973c2cbb)
최초로 촬영한 힙 스냅샷을 보면 메모리에 많은 정보들이 존재하는 것을 확인할 수 있다.

→ 그 이유는 리액트 기반 애플리케이션이 기본적으로 차지하는 내용, 그리고 window 객체 등 브라우저가 차지하는 내용이 존재하기 때문이다.

아래는 BUG 버튼을 한 번 더 클릭해 DOMMY_LIST에 다량의 데이터가 push되게 한 다음 다시 힙 스냅샷을 촬영해 보았다.

![Untitled 16](https://github.com/user-attachments/assets/196ac2d9-2342-4721-b188-fef0272f648a)

촬영한 힙 스냅샷 두 개를 비교하기 위해 **모든 객체** 메뉴를 클릭하고 **스냅샷 1에서 스냅샷 2 사이에 할당된 객체**를 클릭해 **얕은 크기** 항목을 기준으로 내림차순 정렬하였다.

이를 통해 메모리를 많이 잡아먹고 있는 변수를 확인할 수 있다. 또한 두 스냅샷 간 사이에 일어났던 유저 인터렉션, 즉 버튼 클릭으로 인해 이러한 메모리 사용량 차이가 발생했다는 것을 명확히 확인할 수 있다.

추가적으로 메모리를 크게 차지하고 있는 것이 객체(배열)라는 점, 그리고 이 액션이 handleClick이라는 함수를 통해 빚어졌다는 점도 파악할 수 있다.

→ 해당 배열의 값도 확인 가능

![Untitled 17](https://github.com/user-attachments/assets/2aedb56d-6703-45b4-a08a-157adb51ec5d)

→ 해당 객체를 대상으로 마우스 오른쪽 버튼을 클릭해 **전역 변수로 저장**을 누르면 해당 변수의 값이 전역 변수에 저장된다.

⭐ 얕은 크기와 유지된 크기의 차이점

- 얕은 크기는 객체 자체가 보유하는 메모리 바이트의 크기를 말한다.
- 유지된 크기는 해당 객체 자체뿐만 아니라 다른 부모가 존재하지 않는 모든 자식 객체들의 크기까지 더한 값이다.

```jsx
var counter = 0
var instances = []

function Y() {
	this..j = 5
}

function X() {
	this.i = counter++
	this.y = new Y()
}

export default function App() {
	function handleClick() {
		instances.push(new X())
	}

	return <button onClick={handleClick}>+</button>
}
```

→ 버튼을 클릭하면 X라는 이름의 새로운 객체를 생성하는데, 이 생성자 내부에서는 또 Y라고 하는 새로운 생성자를 생성해 할당한다.

👇 변수 X와 Y의 값과 크기를 확인

![Untitled 18](https://github.com/user-attachments/assets/2db405a6-ecef-426a-8e5c-b167dcd5a4fb)

- 새롭게 할당된 X늬 크기는 유지된 크기가 100, 얕은 크기가 52로 선언되어 있다.
- 그리고 X 내부에는 앞서 선언한 Y 객체가 있는데, 왼쪽에 있는 메모리 아이디 @374491을 따라가면 Y 객체가 있으며, 이 객체의 얕은 크기와 유지된 크기가 각각 48임을 알 수 있다.
- 즉, X의 유지된 크기는 100이지만, Y를 제외하고 X라는 객체 자체가 가지고 있는 크기 자체는 52다. 리고 여기서 비롯된 차이 48은 객체 자체가 참조를 보유하고 있는 Y객체의 크기를 의미한다.

❣️ 메모리 누수를 찾을 때는 얕은 크기(객체 자체의 크기)는 작으나 유지된 크기(객체가 참조하고 있는 모든 객체들의 크기)가 큰 객체를 찾아야 한다. 두 크기의 차이가 큰 객체는 다수의 다른 객체를 참조하고 있다는 뜻이며, 이는 해당 객체가 복잡한 참조 관계를 가지고 있다는 뜻이다.

→ 또한 이런 객체가 오랜 시간 동안 메모리에 남아있으면 그로 인해 많은 메모리를 점유하고 있을 수 있다. 따라서 메모리 누수가 의심스럽다면 이러한 두 크기의 차이가 큰 객체를 최우선으로 찾아야 한다.

스냅샷 촬영을 제대로 활용하려면 하나의 스냅샷을 가지고 파악하는 것보다 스냅샷을 두 개 이상을 촬영한 다음, 그 차이만 비교하는 것이 훨씬 수월하다.

→ 거의 아무것도 없는 빈 리액트 애플리케이션도 14MB 정도를 차지하고 있는 것을 봤던 것처럼 아무것도 없는 페이지라도 리액트와 브라우저가 웹페이지 실행을 위해 많은 것을 준비해 두기 때문이다.

<html /> 만 있는 페이지의 스냅샷을 보면 자바스크립트 코드가 존재하지 않는 웹페이지임에도 불구하고 메모리 탭에 정말 다양한 내용이 담겨 있는 것을 볼 수 있다.

하지만 하나의 스냅샷으로 정확하게 디버깅하는 것은 어렵기때문에 스냅샷을 활용할 때는 의심이 되는 지점을 먼저 추측해 본 뒤에 두 개 이상의 스냅샷을 보는 것이 훨씬 쉽다.

또한 스냅샷을 활용하면 useMemo나 useCallback과 같은 의존성이 있는 값들이 정말로 렌더링 사이에 그대로 유지되는지 직접 확인할 수 있다.

```jsx
function MemoComponent({ num }: { num: number }) {
  const callbackHandleClick = useCallback(
    function callbackHandleClick() {
      console.log(num);
    },
    [num]
  );

  const handleClick = () => {
    console.log(num);
  };

  return (
    <>
      <button onClick={callbackHandleClick}>1번</button>
      <button onClick={handleClick}>2번</button>
    </>
  );
}

export default function App() {
  // 리렌더링을 발생시키는 용도
  const [toggle, setToggle] = useState(false);

  function handleToggle() {
    setToggle((prev) => !prev);
  }

  return (
    <>
      <button onClick={handleToggle}>{toggle ? "ON" : "OFF"}</button>
      <MemoComponent num={5} />
    </>
  );
}
```

→ 이 코드는 callbackHandleClick과 handleClick의 차이, 즉 정말로 의존성 배열이 변경되지 않는다면 useCallback 함수가 재생성되는지 확인하기 위해 만든 코드다.

부모 컴포넌트인 App은 useState를 수행해 MemoComponent가 고정된 props를 갖고 있다 하더라도 부모 컴포넌트가 리렌더링되기 때문에 리렌더링될 것이다.

그리고 MemoComponent의 callbackHandleClick은 절대 변경되지 않는 num을 의존성 배열로 가지고 있으므로 재생성되지 않는 것이 맞을 것이다.

아래는 스냅샷으로 살펴보기 위해 토글 버튼을 클릭하기 전과 후의 스냅샷을 비교한 사진이다.

![Untitled 19](https://github.com/user-attachments/assets/86ef2227-b42f-47ab-ad89-56f8bb681fd8)

→ 예제 코드를 useState 변경 전후로 스냅샷을 촬영해 비교한 모습

여기서 확인할 수 있는 것은 두 가지 있따.

1. `스냅샷 사이에 재생성되지 않은 callbackHandleClick`

   스냅샷 촬영 사이에 useCallback으로 감싼 callbackHandleClick은 재생성되지 않았기 때문에 스냅샷 사이에 할당된 객체에서 확인할 수 없었다.

   반면 useCallback으로 감싸지 않은 handleToggle은 이 스냅샷 사이에 재생성된 것을 확인할 수 있다.

   즉, useCallback은 리액트 개발자가 예측한 대로 올바르게 작동했다.

2. `세번째로 보이는 익명 함수 ()`

   이것은 코드 참조에서도 알 수 있듯이 setToggle((prev) ⇒ !prev);. 즉setToggle 내부의 익명 함수다.

   익명 화살표 함수는 사용할 때는 간단하지만 디버깅할 때는 그다지 도움이 되지 ㅇ낳는다.

   만약 setToggle 내부의 함수를 기명 함수로 바꾼다면 힙 스냅샷에서 바로 확인할 수 있다.

   ```jsx
   function handleToggle() {
     setToggle(function 토글함수(prev) {
       return !prev;
     });
   }
   ```

이 코드를 실행해서 개발자 도구에서 확인하면 다음과 같이 기명 함수를 명확하게 확인할 수 있다.

![Untitled 20](https://github.com/user-attachments/assets/ea0d58e1-1c7d-485c-9e52-5b679e49425f)

→ useState의 setter를 익명 함수 대신 기명 함수로 바꿨다.

setter를 기명 함수로 바꾸고 난 후에 스냅샷에서 함수를 더욱 명확히 확인할 수 있게 됐다.

→ 소스 탭이든, 현재 메모리 탭이든, 디버깅을 빠르고 원활하게 하려면 기명 함수를 사용하는 편이 좋다.

## 🖌️ 타임라인 할당 계측

앞에서 스냅샷 촬영은 해당 시점의 메모리 내용만 촬영하는 프로파일링 기법이지만 타임라인 할당 계측은 시간의 흐름에 따라 메모리 변화를 확인할 수 있는 기능이다. 시간의 흐름에 따라 메모리의 변화를 모두 기록하기 때문에 상대적으로 많은 부담이 발생한다.

아래 예제 코드로 확인해보자.

```jsx
import { useState } from "react";

export default function App() {
  const [number, setNumber] = useState(0);
  const [list, setList] = useState < Array < string >> [];
  const handleClick = () => {
    const newNumber = number + 1;
    setNumber(newNumber);

    setList((prev) => [
      ...prev,
      ...Array.from({ length: newNumber * 3000 }).map(
        (_, index) => `${index + number * 3000}`
      ),
    ]);
  };

  return (
    <>
      <button onClick={handleClick}>+</button>
      <ul>
        {list.map((item, index) => (
          <li key={`${item}_${index}`}>{item}</li>
        ))}
      </ul>
    </>
  );
}
```

아래 사진은 타임라인 할당 계측으로 메모리 변화를 관측한 모습니다.

![Untitled 21](https://github.com/user-attachments/assets/25115cca-e31a-4131-bc4d-97bfd315041d)

- 버튼을 누를 때마다 3000, 6000, 9000개씩 배열에 새로운 아이템이 생기며, 리액트는 이 배열을 모두 DOM에 그려야 한다.
- 그 결과, DOM을 그리기 위해 리액트가 1:1 구조로 생성하는 FiberNode와 해당 배열을 담아야 하는 array가 엄청난 크기로 커졌다. 여기서 해당 객체가 어떤 값을 가지고 있는지 살펴보고 싶다면 >을 눌려보면 된다.

![Untitled 22](https://github.com/user-attachments/assets/3c464d0e-ce9b-41b8-bb7e-319e9b5392cb)

→ 이 사진과 같이 메모리 메뉴를 통해 배열의 세부 내용을 들여다 본 모습이다. 배열의 구체적인 크기를 비롯해 어떤 요소로 구성되어 있는지 명확하게 알 수 있다.

이는 타임라인 할당 계측의 또 다른 장점은 기간을 좁혀서 확인해 볼 수 있다는 것이다. 상단 그래프에서 검색을 원하는 범위를 좁히면 해당 기간에 메모리에 할당된 내용만 골라서 볼 수 있다.

![Untitled 23](https://github.com/user-attachments/assets/06a26a31-1f86-425f-8daa-3387c0fd5e3f)

→ 해당 기간 동안 배열 변수에 어떤 값이 들어가 있는지 확인할 수 있다.

그리고 특정 변수를 클릭해서 전역 변수로 저장을 누르면 해당 변수가 무슨 값을 가지고 있는 객체인지 확인할 수도 있다. 👇

![Untitled 24](https://github.com/user-attachments/assets/98700897-5a62-44cf-83b9-b6697a8a9b03)

전역 변수로 저장하면 다음과 같이 콘솔에서 해당 변수를 확인할 수 있다.

![Untitled 25](https://github.com/user-attachments/assets/71a7fc9f-c707-4fb8-a043-4132422cac62)

- 타임라인 계측을 활용하면 이처럼 시간의 흐름에 따른 메모리 변화를 비롯해 메모리 변화를 일으킨 변수가 무엇인지, 그리고 해당 변수가 어느 정도 크기를 차지하고 있는지 등을 확인할 수 있다.
- 시간의 흐름에 따른 메모리 점유율을 자세히 알고 싶다면 타임라인 할당 계측을 활용해보면 좋다.

## 🖌️ 할당 샘플링

할당 샘플링은 시간의 흐름에 따라 발생하는 메모리 점유를 확인할 수 있다는 점에서 할당 계측과 비슷하지만 자바스크립트 실행 스택별로 분석할 수 있고, 이 분석을 함수 단위로 한다는 차이점이 있다.

이 차이점을 이해하기 위해 아래 예제코드로 확인해 보자.

```jsx
const DUMMY_LIST = []

export default function App() {
	function handleClick() {
		Array.form({ length: 10_000_000 }).forEach((_, idx) =>
			DUMMY_LIST.push(Math.random() * idx),
		)
		alert('complete!')
	}

	return <button onClick={handleClick}>BUG</dutton>
}
```

페이지가 로딩된 이후에 할당 샘플링을 시작하고 버튼을 눌러 어떤 변화가 일어나는지 살펴보자.

![Untitled 26](https://github.com/user-attachments/assets/7dc7c336-5cf5-4e1e-9c16-45ec2120da58)

→ 크롬 개발자 도구에서 메모리 탭을 방문하면 할당 샘플링 도구를 확인할 수 있다.

이제 할당 샘플링을 하고 싶은 VM을 선택하고 시작을 누르면 할당 샘플링을 시작한다.

![Untitled 27](https://github.com/user-attachments/assets/f81392d3-9d44-456f-9841-15ae64dbec15)

최초에는 6.5MB 정도만 차지하던 힙이, 버튼을 클릭한 이후에는 395MB까지 치솟은 것을 확인할 수 있다.

즉, 버튼을 클릭하는 사이에 엄청나게 많은 메모리 할당 작업이 이뤄진 것을 볼 수 있다.

그리고 중지를 눌러 할당 샘플링을 살펴보자.

![Untitled 28](https://github.com/user-attachments/assets/191df594-3f84-472a-9773-49acb28f9926)

→ 할당 프로파일링이 끝나고 이를 무거움(상향식)으로 정렬하면 가장 무거운 변수와 이 변수가 무엇 때문에 할당됐는지 구체적으로 알 수 있다.

할당 샘플링을 무거운 순으로 정렬하면 가장 많은 바이트를 차지한 함수의 작업이 맨 위로 올라오는데, 여기서는 addDummy 함수가 문제임을 확인할 수 있다.

여기서는 문제가 되는 함수뿐만 아니라 오른쪽의 파일명을 누르거나 마우스 오른쪽 버튼을 클릭한 후 소스 패널에 표시를 선택해 해당 함수가 어느 파일에서 어떻게 정의됐는지도 확인할 수 있다.

할당 샘플링은 타임라인 할당 계측과 유사하지만 프로파일링할 때 브라우저에 주는 부담을 최소화할 수 있어 장시간에 걸쳐 디버깅을 수행해야 할 때 유리하다.

만약 메모리 누수가 짐작되지만 정확히 어디에서 발생하는지 확인하기 어려워 힙 스냅샷을 촬영해 비교하기 어려운 경우, 오랜 기간 메모리 누수가 의심되어 프로파일링을 장기간 수행해야 하는 경우에는 할당 샘플링을 활용하는 것이 좋다.

# 📑 Next.js 환경 디버깅하기

서버 환경도 동일하게 크롬 개발자 도구로 디버깅이 가능하니 서버 환경을 디버깅하는 방법을 자세히 알아보자.

## 🖌️ Next.js 프로젝트를 디버그 모드로 실행하기

가장 먼저 할 일은 Next.js 프로젝트를 디버그 모드로 실행하는 것이다. 디버그 모드로 실행하려면 다음과 같은 방법으로 Next.js 프로젝트를 실행한다.

```jsx
"dev": NODE_OPTIONS='--inspect' next dev
```

`NODE_OPTIONS='--inspect'` 라는 인수와 함께 `next dev`를 실행하면 다음과 같이 디버거가 활성화되면서 디버그 모드가 켜진 것을 확인할 수 있다.

```jsx
>> npm run dev

> my-app@0.1.0 dev
> NODE_OPTIONS='--inspect' next dev

Debugger listening on ws://127.0.0.1:9229/b9d825b1-3046-4237-8c76-80e2a985ceea
For help, see: https://nodejs.org/en/docs/inspector
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
```

이와 같이 웹소켓 주소가 나타나면 디버거에 연결된 준비가 된 것이다. 그 다음 크롬 브라우저에서 `chrome:// inspect`로 이동하자.

✅ 크롬의 장치 개발자 도구

![Untitled 29](https://github.com/user-attachments/assets/2ac104eb-fbff-4377-b05e-30b39c687126)

여기서 Open dedicated DevTools for Node를 클릭하면 다음과 같이 새로운 창에서 개발자 도구가 나타나는 것을 확인할 수 있다.

![Untitled 30](https://github.com/user-attachments/assets/4d3d53d6-c88a-485a-a804-45ad6d4f3675)

→ 이 사진에서와 같이 Node로 실행한 next를 이곳에서 확인할 수 있다.

이제 크롬 개발자 도구에서 디버깅할 준비가 끝났다.

## 🖌️ Next.js 서버에 트래픽 유입시키기

브라우저에서 발생하는 메모리 누수의 경우 사용자가 웹페이지에서 이용할 수 있는 몇 가지 시나리오를 흉내내면서 메모리 누수 여부를 확인할 수 있었다. 그러나 서버 사이드 렌더링과 같이 서버에서 제공되는 서비스의 경우 서버를 실행한 뒤 사용자가 서서히 유입되면서 메모리 누수가 발생하는 경우가 많다.

따라서 서버에 직접 트래픽을 발생시켜서 확인하는 편이 제일 확실한 방법이다.

디버그 모드로 Next.js를 실행하기 위해 새로고침이나 다른 컴퓨터를 이용해서 접속하는 것보다 오픈 소스 도구인 ab를 사용하는 것이 더 편리한 방법이다.

ab는 아파치 재단에서 제공하는 웹서버 성능 검사 도구로, HTTP 서버의 성능을 벤치마팅할 수 있는 도구이다.

터미널에서 다음과 같이 실행해보자.

```jsx
>> ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
```

→ 이 명령어는 `http://127.0.0.1:3000/`을 향해 한 번에 50개의 요청을 총 10,000회 시도한다.

→ 로컬에서 테스트할 경우 주소를 localhost로 하면 정상적으로 실행되지 않으니 반드시 IP나 올바른 주소를 기재해야 한다.

위 명령어 실행 결과는 다음과 같다.

```jsx
This is ApacheBench, Version 2.3 <$Revision: 1901567 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking 127.0.0.1 (be patient)
Completed 1000 requests
Completed 2000 requests
Completed 3000 requests
Completed 4000 requests
Completed 5000 requests
Completed 6000 requests
Completed 7000 requests
Completed 8000 requests
Completed 9000 requests
Completed 10000 requests
Finished 10000 requests

Server Software:
Server Hostname:        127.0.0.1
Server Port:            3000
Document Path:          /
Document Length:        1304 bytes

Concurrency Level:       50
Time taken for tests     7.378 seconds
Complete requests:       10000
Failed requests:         0
Keep-Alive requests:     0
Total transferred:       15370000 bytes
HTML transferred:        15370000 bytes
Requests per second:     1355.34 [#/sec] (mean)
Time per requset:        36.891 [ms] (mead)
Time per request:        0.738 [ms] (mean, across all concurrent requests)
Transfer rate:           2034.33 [Kbytes/sec] received

Connection Times (ms)
							min mean[+/-sd] median max
Connect:        0    3   1.9      2   17
Processing:     8   34   8.6     33   98
Waiting:        3   17   6.7     16   92
Total:         11   36   9.0     35   99

Percentage of the requests served within a certain thime (ms)
  50%    35
  66%    37
  75%    39
  80%    40
  90%    45
  95%    51
  98%    63
  99%    71
 100%    99 (longest request)
```

ab를 사용하면 단순히 요청을 수행하는 것뿐만 아니라 요청으로부터 응답받는 데 걸린 시간, 바이트 크기 등 다양한 정보를 확인할 수 있다. (`자세한 내용은 공식 문서 참고`)

## 🖌️ Next.js의 메모리 누수 지점 확인하기

아래 예제는 getServerSideProps가 있는 Next.js 페이지로서 getServerSideProps가 실행될 때마다 전역 변수로 선언된 access_users에 끊임없이 push를 수행한다.

→ 이 페이지는 사용자가 방문할 때마다 메모리 사용이 점차 늘어날 것으로 예상된다.

```jsx
import type { GetServerSidePropsContext, NextPage } from "next";

const access_users = [];

function Home({ currentDateTime }: { currentDateTime: number }) {
  return <>{currentDateTime}</>;
}

export const getServerSideProps = (ctx: GetServerSidePropsContext) => {
  const currentDateTime = new Date().getTime();

  access_users.push({
    user: `user-${Math.round(Math.random() * 1000000)}`,
    currentDateTime,
  });

  return {
    props: {
      currentDateTime,
    },
  };
};

export default Home;
```

아래는 디버그 모드로 실행한 화면이다.

![Untitled 31](https://github.com/user-attachments/assets/236627a1-8a61-4af1-b098-b5934ea50180)

→ 메모리 누수가 있는 next 애플리케이션을 메모리 탭에서 확인한 모습이다.

그리고 브라우저에서 next 애플리케이션을 방문한 뒤 다시 메모리 탭에서 메모리 변화를 살펴보자.

![Untitled 32](https://github.com/user-attachments/assets/acc05282-1f60-4359-92dc-808ec9ea292e)

→ Next.js를 크롬으로 디버깅한 모습. getServerSideProps 내부에서 지속적으로 객체가 쌓이는 모습을 확인할 수 있다.

메모리 도구를 프로파일링한 결과, getServerSideProps의 다수 실행과 메모리 누수를 확인할 수 있다.

getServerSideProps는 페이지 접근 요청이 있을 때마다 실행되는 7 함수이므로 최대한 부수 효과가 없는 순수 함수로 만들어야 한다.

만약 이 함수 내부에서 외부 스코프의 변수에 의존하는 작업을 한다면 지금과 같은 메모리 누수 상황을 마주할 수도 있을 것이다.

대부분의 경우에는 메모리 누수의 원인이 불명확하고, 코드를 아무리 봐도 잘 이해되지 않는 경우가 많기 때문에 메모리 누수가 의심되는 지점을 찾고, 코드를 수정하고, 다시 또 프로파일링해서 문제가 해결되는지 확인해야 하는 지루하고 긴 과정을 반복해야 한다.

이렇게 찾은 우너인이 본인의 코드일수도, 혹은 npm 라이브러리일 수도 있기 때문에 많은 가능성을 열어두고 봐야 한다.

✅ 크롬 개발자 도구에서는 앞에서 다뤘던 5가지 탭 외에도 다양한 기능이 있는데, 나머지 기능은 이후 9장에서 다룰 예정이다.

✅ 알 수 없는 문제에 부딪혔을 때, 사용 중인 라이브러리의 작동 방식을 알고 싶을 때, 마지막으로 꼭 리액트로 만들어진 웹페이지가 아니더라도 웹페이지의 작동 방식을 자세히 이해하고 싶다면 개발자 도구를 적극적으로 활용하자!
