# 리액트와 상태 관리 라이브러리

# 📑 상태 관리는 왜 필요한가?

상태 관리를 알아보기 전에 ‘상태’가 무언인지 알아보자.

**상태란?**

- 흔히 웹 애플리케이션을 개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.
- 웹 애플리케이션에서 상태로 분류될 수 있는 것들은 대표적으로 다음과 같다.
  - `UI` : 기본적으로 웹 애플리케이션에서 상태라 함은 상호 작용이 가능한 모든 요소의 현재 값을 의미한다. 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림창의 노출 여부 등 많은 종류의 상태가 존재한다.
  - `URL` : 브라우저에서 관리되고 있는 상태값으로, `https://www.airbnb.co.kr/rooms/34113796?adults=2`와 같은 주소에서 `roomId=34113796`과 `adults=2`라고 하는 상태가 존재하는 것을 알 수 있으며 이 상태는 라우팅에 따라 변경된다.
  - `폼(form)` : 폼에도 상태가 존재한다. 로딩 중인지(loading), 현재 제출됐는지(submit), 접근이 불가능한지(disabled), 값이 유효한지(validation) 등 모두가 상태로 관리된다.
  - `서버에서 가져온 값` : 클라이언트에서 서버로 요청을 통해 가져온 값도 상태로 볼 수 있다. 대표적으로 API 요청이 있다.

애플리케이션 전체적으로 관리해야 할 상태가 있을 경우, 추가적으로 그 상태에 따라 다양한 요소들이 각 상태에 맞는 UI를 보여줘야 할 경우

- 상태를 어디에 둘 것인가?
- 전역 변수에 둘 것인가?
- 별도의 클로저를 만들 것인가?
- 그렇다면 그 상태가 유효한 범위는 어떻게 제한할 수 있을까?
- 상태의 변화에 따라 변경돼야 하는 자식 요소들은 어떻게 이 상태의 변화를 감지할 것인가?
- 이러한 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 형상(이를 tearing이라고 하며, 하나의 상태에 따라 서로 다른 결과물을 사용자에게 보여주는 현상을 말한다)을 어떻게 방지할 것인가?

등등의 고민을 하게된다. 따라서 상태관리에 대해 잘 알고 있어야 한다.

## 🖌️ 리액트 상태 관리의 역사

### Flux 패턴

양방향 데이터 바인딩으로 인해 복잡해지고 관리하기 어렵다고 판단한 페이스북 팀은 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안했는데 이것이 바로 Flux 패턴의 시작이다.

![Untitled](https://github.com/user-attachments/assets/e844307d-505d-4d33-b745-bb63c74a18bf)

- `액션(action)` : 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 디스패치로 보낸다.
- `디스채피(dispatcher)` : 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
- `스토어(store)` : 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.
- `뷰(view)` : 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있을 것이다. 이 경우에는 다음 그림처럼 뷰에서 액션을 호출하는 구조로 구성된다.
  ![Untitled 1](https://github.com/user-attachments/assets/e08e7a7c-ffb2-4520-afb9-57b78e2a4c15)

  → Flux 패턴에서 뷰 또한 액션을 호출할 수 있으며, 이후 프로세스는 동일하다.

리액트 코드로 확인해보자.

```jsx
type StoreState = {
  count: number,
};

type Action = { type: "add", payload: number };

function reducer(prevState: StoreState, action: Action) {
  const { type: ActionType } = action;
  if (ActionType === "add") {
    return {
      count: prevState.count + action.payload,
    };
  }

  throw new Error(`Unexpected Action [${ActionType}]`);
}

export default function App() {
  const [state, dispatcher] = useReducer(reducer, { count: 0 });

  function handleClick() {
    dispatcher({ type: "add", payload: 1 });
  }

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={handleClick}>+</button>
    </div>
  );
}
```

- type Action으로 액션이 어떤 종류가 있고 어떤 데이터를 필요로 하는지 정의
- 스토어의 역할을 하는 것이 useReducer와 reducer인데, 각각 현재 상태와 상태에 따른 값이 어떻게 변경되는지를 정의
- dispatcher로 이 액션을 실행
- 뷰인 App에서 보여줌

이와 같이 데이터의 흐름이 한 방향(단방향)이면 데이터의 흐름을 추적하기 쉽고 코드를 이해하기 수월해진다.

상태와 그 상태의 변경에 대한 흐름과 방식을 단방향으로 채택한 것이 바로 리액트 기반 Flux의 특징이라고 볼 수 있다.

### 리덕스

리덕스는 Flux 구조를 구현하기 위해 만들어진 라이브러이며, Elm 아키텍처도 도입한 라이브러리이다.

아래는 Elm으로 HTML을 작성한 예제이다.

```jsx
module Main exposing (..)

import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)

-- MAIN
main =
	Browser.sandbox { init = init, update = update, view = view }

-- MODEL
type allias Model = Int

init : Model
init =
	0

-- UPDATE
type Msd
	= Increment
	| Decrement

update : Msg -> Model -> Model
update msg model =
	case msg of
		Increment ->
			model + 1

		Decrement ->
			model -1

-- VIEW

view : Model -> Html Msg
view model =
	div []
		[ button [ onClick Decrement ] [ text "-" ]
		, div [] [ text (String.formInt model} ]
		, button [ onClick Increment ] [ text "+" ]
		]
<div>
	<button>-</button>
	<div>2</div>
	<button>+</button>
</div>
```

→ Elm 아키텍처의 핵심은 `model`, `update`, `view` 이다.

- `모델(model)` : 애플리케이션의 상태를 의미한다. 여기서는 Model을 의미하며, 초깃값으로는 0이 주어졌다.
- `뷰(view)` : 모델을 표현하는 HTML을 말한다. 여기서는 Model을 인수로 받아서 HTML을 표현한다.
- `업데이트(update)` : 모델을 수정하는 방식을 말한다. Increment, Decrement를 선언해 각각의 방식이 어떻게 모델을 수정하는지 나타냈다.

⇒ 즉, Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고, 이를 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력했다. 그리고 이 영향으로 리덕스가 탄생했다.

리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다. 이러한 작업은 reducer 함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 된다.

리덕스의 등장으로 인해 하나의 글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props를 깊이 전파해야 하는 prop 내려주기 문제를 해결할 수 있었고, 스토어가 필요한 컴포넌트라면 단지 connect만 쓰면 스토어에 바로 접근할 수 있었다.

하지만 리덕스는 단순히 하나의 상태를 바꾸고 싶어도 해야 할 일이 너무 많았다. 먼저 어떠한 액션인지 타입을 선언해야 하고, 이 액션을 수행할 creator, 함수를 만들어야 한다. 그리고 dispatcher와 selector도 필요하고, 새로운 상태가 어떻게 기존의 리듀서 내부에서 어떤 식으로 변경돼야 할지, 혹은 새로 만들어야 할지도 새로 정의해야 했다. → 현재는 이러한 작업이 많이 간소화되어있어 리액트와 리덕스는 일종의 표준처럼 굳어졌다.

### Context API와 useContext

Context API는 리액트 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 API로, props로 상태를 넘겨주지 않더라도 Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 된다.

리액트 16.3 버전 이전에도 context가 존재했으며, 이를 다루기 위한 getChildContext()를 제공했다.

다음 예제를 확인해보자.

```jsx
class MyComponent extends React.Component {
  static childContextTypes = {
    name: PropTypes.string,
    age: PropTypes.number,
  };

  getChildContext() {
    return {
      name: "foo",
      age: 30,
    };
  }

  render() {
    return <ChildComponent />;
  }
}

function ChildComponent(props, context) {
  return (
    <div>
      <p>Name: {context.name}</p>
      <p>Age: {context.age}</p>
    </div>
  );
}

ChildComponent.contextTypes = {
  name: PropTypes.string,
  age: PropTypes.number,
};
```

→ 이와 같은 방식에는 몇가지 문제점이 있다.

- 상위 컴포넌트가 렌더링되면 getChildContext도 호출됨과 동시에 shouldComponentUpdate가 항상 true를 반환해 불필요하게 렌더링이 일어난다.
- getChildContext를 사용하기 위해서는 context를 인수로 받아야 하는데 이 때문에 컴포넌트와 결합도가 높아진다.

다음은 Context API를 사용해 하위 컴포넌트에 상태를 전달하는 예이다.

```jsx
type Counter = {
  count: number,
};

const CounterContext = (createContext < Counter) | (undefined > undefined);

class CounterComponent extends Component {
  render() {
    return (
      <CounterContext.Consumer>
        {(state) => <p>{state?.count}</p>}
      </CounterContext.Consumer>
    );
  }
}

class DummyParent extends Component {
  render() {
    return (
      <>
        <CounterComponent />
      </>
    );
  }
}

export default class MyApp extends Component<{}, Counter> {
  state = { count: 0 };

  componentDidMount() {
    this.setState({ count: 1 });
  }

  handleClick = () => {
    this.setState((state) => ({ count: state.count + 1 }));
  };

  render() {
    return (
      <CounterContext.Provider value={this.state}>
        <button onClick={this.handleClick}>+</button>
        <DummyParent />
      </CounterContext.Provider>
    );
  }
}
```

- 부모 컴포넌트인 MyApp에 상태가 선언되어 있고, 이를 Context로 주입하고 있다.
- Provider로 주입된 상태는 자식의 자식인(MyApp 밑 DummyParent 밑 CounterComponent) CounterComponent에서 사용하고 있다.
- 즉, prop 내려주기로 원하는 값을 props로 번거롭게 넘겨주지 않아도 사용이 가능해졌다.

### **훅? React Query와 SWR**

훅 API는 기존에 무상태 컴포넌트를 선언하기 위해서만 제한적으로 사용했던 함수 컴포넌트가 클래스 컴포넌트 이상의 인기를 구가할 수 있도록 많은 기능을 제공했다.

이 가운데 가장 큰 변경점 중 하나로 꼽을 수 있는 것은 state를 매우 손쉽게 재사용 가능하도록 만들 수 있다는 것이다. 다음 코드를 보자.

```jsx
function useCounter() {
  const [count, setCount] = useState(0);

  function increase() {
    setCount((prev) => prev + 1);
  }

  return { count, increase };
}
```

- useCounter는 단순히 count state와 이를 1씩 올려주는 increase로만 구성돼 있지만 내부적으로 관리하고 있는 state도 있으며, 또 이를 필요한 곳에서 재사용할 수 있다.
  → 클래스 컴포넌트보다 간결하고 직관적인 방법

또 다른 상태 관리 훅으로 `React Query`와 `SWR`가 있다.

두 라이브러리 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만, API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

다음은 SWR을 사용한 코드이다.

```jsx
import React from "react";
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

export default function App() {
  const { data, error } = useSWR(
    "https://api.github.com/repos/vercel/swr",
    fetcher
  );

  if (error) return "An error has occurred.";
  if (!data) return "Loading...";

  return (
    <div>
      <p>{JSON.strungify(data)}</p>
    </div>
  );
}
```

- useSWR의 첫 번째 인수로 조회할 API 주소, 두 번째 인수로 조회에 사용되는 fetch를 넘겨준다.
- 첫 번째 인수인 API 주소는 키로도 사용되며, 이후에 다른 곳에서 동일한 키로 호출하면 재조회하는 것이 아니라 useSWR이 관리하고 있는 캐시의 값을 활용한다.

### **Recoil, Zustand, Jotai, Valtio**

코드로 보면 다음과 같다.

```jsx
// Recoil
const counter = atom({ key: "count", defulat: 0 });
const todoList = useRecoilValue(counter);

// Jotai
const countAtom = atom(0);
const [count, setCount] = useAtom(countAtom);

// Zustand
const useCounterStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
}));
const count = useCounterStore((state) => state.count);

// Valtio
const state = proxy({ count: 0 });
const snap = useSnapshot(state);
state.count++;
```

- 이러한 상태 관리 라이브러리들은 기존의 리덕스 같은 라이브러리와는 다르게, 바로 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다는 점이다.
- Recoil, Jotai, Zustand, Valtio의 저장소를 방문해 보면 모두 peerDependencies로 리액트 16.8버전 이상을 요구하고 있다. 따라서 리액트와의 연동을 전제로 작동해 별도로 다른 라이브러리를 설치하지 않아도 된다.
- 이는 전역 상태 관리 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었고, 훅을 지원함으로써 함수 컴포넌트에서 손쉽게 사용할 수 있다는 장점도 있다.

# 📑 리액트 훅으로 시작하는 상태 관리

기존에는 리덕스가 상태관리를 위한 라이브러리로 업계 표준으로 여겨졌지만 현재는 새로운 Context API, useReducer, useState의 등장으로 컴포넌트에 걸쳐서 재사용하거나 혹은 컴포넌트 내부에 걸쳐서 상태를 관리할 수 있는 방법들이 점차 등장하기 시작했고, 덕분에 리덕스 외의 다른 상태 관리 라이브러리를 선택하는 경우도 많아지고 있다.

## 🖌️ 가장 기본적인 방법: useState와 useReducer

### useState

useState로 인해 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있다.

```jsx
function useCounter(initCount: number = 0) {
  const [counter, setCounter] = useState(initCount);

  function inc() {
    setCounter((prev) => prev + 1);
  }

  return { counter, inc };
}
```

- 이 훅은 함수 컴포넌트 어디에서든 사용할 수 있는 컴포넌트이다.
- 외부에서 받은 숫자 혹은 0을 초깃값으로 상태를 관리하며, inc라는 함수를 선언해 이 숫자를 1씩 증가시킬 수 있게 구현했다. 그리고 상태값인 counter와 inc 함수를 객체로 반환한다.

위 훅은 다음과 같이 사용하면 된다.

```jsx
function Counter1() {
  const { counter, inc } = useCounter();

  return (
    <>
      <h3>Counter1: {counter}</h3>
      <button onClick={inc}>+</button>
    </>
  );
}
```

```jsx
function Counter2() {
  const { counter, inc } = useCounter();

  return (
    <>
      <h3>Counter2: {counter}</h3>
      <button onClick={inc}>+</button>
    </>
  );
}
```

→ 만약 useCounter라는 훅이 없었다면 이러한 기능이 필요한 각각의 컴포넌트에서 모두 위와 같은 내용을 구현해야만 했다.

- 리액트의 훅을 기반으로 만든 사용자 정의 훅은 함수 컴포넌트라면 어디서든 손쉽게 재사용 가능하다는 장점이 있다.

### useReducer

- useReducer도 지역 상태를 관리할 수 있는 훅이다.
- useState가 useReducer로 구현되어있다.

✅ useState를 useReducer로 구현하는 예제

```jsx
type Initializer<T> = T extends any ? ((prev: T) => T) : never

function useStateWithUseReducer<T>(initialState: T) {
	const [state, dispatch] = useReducer(
		(prev: T, action: Initializer<T>) =>
			typeof action === 'function' ? action(prev) : action,
		initialState,
	)

	return [state, dispatch]
}
```

- useReducer의 첫 번째 인수로 rdeucer, 즉 state와 action을 어떻게 정의할지를 넘겨줘야 하는데 useState와 동일한 작동, 즉 T를 받거나 (prev: T) ⇒ T를 받아 새로운 값을 설정할 수 있게끔 코드를 작성했다.

✅ useReducer를 useState로 구현하는 예제

```jsx
function useReducerWithUseState(reducer, initialState, initializer) {
  const [state, setState] = useState(
    initializer ? () => initializer(initialState) : initialState
  );

  const dispatch = useCallback(
    (action) => setState((prev) => reducer(prev, action)),
    [reducer]
  );

  return [state, dispatch];
}
```

- useReducer를 타입스크립트로 작성하려면 다양한 형태의 오버로딩이 필요한데 코드의 대략적인 구성만 간단하게 설명하기 위해 자바스크립트로 작성했다.

⇒ useState나 useReducer 모두 약간의 구현상의 차이만 있을 뿐, 두 훅 모두 지역 상태 관리를 위해 만들어졌다.

사용자 지정 훅은 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수밖에 없다.

위 예제의 경우 counter는 useCounter가 선언될 때마다 새롭게 초기화되어, 결론적으로 컴포넌트별로 상태의 파편화를 만들어 버린다.

이렇게 기본적인 useState를 기반으로 한 상태를 지역 상태(local state)라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

```jsx
function Counter1({ counter, inc }: { counter: number, inc: () => void }) {
  return (
    <>
      <h3>Counter1: {counter}</h3>
      <button onClick={inc}>+</button>
    </>
  );
}

function Counter2({ counter, inc }: { counter: number, inc: () => void }) {
  return (
    <>
      <h3>Counter2: {counter}</h3>
      <button onClick={inc}>+</button>
    </>
  );
}

function Parent() {
  const { counter, inc } = useCouneter();

  return (
    <>
      <Counter1 counter={counter} inc={inc} />
      <Counter2 counter={counter} inc={inc} />
    </>
  );
}
```

- useCounter에서 제공하는 counter를 올리는 함수는 지금처럼 동일하게 사용하되, 두 컴포넌트가 동일한 counter 상태를 바라보게 하였다.
- 즉, 현재 지역 상태인 counter를 여러 컴포넌트가 동시에 사용할 수 있는 전역 상태(global state)로 만들어 컴포넌트가 사용하는 모든 훅이 동일한 값을 참조할 수 있게 하였다.
  ⇒ 상태를 컴포넌트 밖으로 한 단계 끌어올렸다.
- useCounter를 각 컴포넌트에서 사용하는 대신, Parent라고 불리는 상위 컴포넌트에서만 useCounter를 사용하고, 이 훅의 반환값을 하위 컴포넌트의 props로 제공했다. 즉, 지역 상태인 useCounter를 부모 컴포넌트로 한 단계 끌어올린 다음, 이 값을 하위 컴포넌트에서 참조해 재사용하게끔 만들었다.

→ Parent 내부에서는 위의 props 규칙만 잘 지킨다면 하나의 counter 값과 하나의 counter 값과 하나의 inc 함수로 상태를 관리할 수 있게 된다. 즉, 컴포넌트 내부의 지역 상태를 전역으로 사용하기 위해 이 상태가 필요한 모든 컴포넌트인 Counter1과 Counter2를 Parent 내부로 이동시켜서 두 컴포넌트가 동일하게 사용할 수 있도록 만들었다.

## 🖌️ 지역 상태의 한계에서 벗어나기: useState의 상태를 바깥으로 분리하기

현재 리액트의 useState는 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성되기 때문에 해당 컴포넌트에서만 사용할 수 있다는 단점이 있다.

- 만약 useState가 이 리액트 클로저가 아닌 다른 자바스크립트 실행 문맥 어디에선가, 즉 완전히 다른 곳에서 초기화돼서 관리되면 어떨까?
- 그리고 그 상태를 참조하는 유효한 스코프 내부에서는 해당 객체의 값을 공유해서 사용할 수도 있지 않을까?
- 즉. 어딘가에서 해당 값을 업데이트하면 그 값을 참조하고 있는 컴포넌트나 훅에서도 그 업데이트된 값을 사용할 수도 있지 않을까?

라는 궁금증이 생긴다.

```jsx
// counter.ts
export type State = { counter: number }

// 상태를 아예 컴포넌트 밖에 선언했다. 각 컴포넌트가 이 상태를 바라보게 할 것이다.
let state: State = {
	counter: 0,
}

// getter
export function get(): State {
	return state
}

// useState와 동일하게 구현하기 위해 게으른 초기화 함수나 값을 받을 수 있게 했다.
type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

// setter
export function set<T>(nextState: Initializer<T>) {
	state = typeof nextState === 'function' ? nextState(state) : nextState
}

// Counter
function Counter() {
	const state = get()

	function handleClick() {
		set((prev: State) => ({ counter: prev.counter + 1}))
	}

	return (
		<>
			<h3>{state.counter}</h3>
			<button onClick={handleClick}>+</button>
		</>
	)
}
```

→ 이 코드는 컴포넌트가 리렌더링이 되지 않아 리액트 환경에서는 작동하지 않는 코드이다. 그 이유는 리액트의 렌더링 방식 때문이다.

→ 새로운 상태를 사용자의 UI에 보여주기 위해서는 반드시 리렌더링이 필요하다. 이 리렌더링은 함수 컴포넌트의 재실행(호출), useState의 두 번째 인수 호출 등 다양한 방식으로 일어나지만 위 코드에서는 리렌더링을 일으키는 장치가 어디에도 존재하지 않는다.

즉, 업데이트되는 값을 가져오려면 상태를 업데이트하는 것뿐만 아니라 상태가 업데이트됐을 때 이를 컴포넌트에 반영시키기 위한 리렌더링이 필요하며, 함수 컴포넌트에서 리렌더링을 하려면 다음과 같은 작업 중 하나가 일어나야 한다.

- useState, useReducer의 반환값 중 두 번째 인수가 어떻게든 호출된다. 만약 그것이 컴포넌트 렌더링과 관계없는 직접적인 상태를 관리하지 않아도 상관없다. 어떠한 방식으로든 두 번째 인수가 호출되면 리액트는 다시 컴포넌트를 렌더링한다.
- 부모 함수(부모 컴포넌트)가 리렌더링되거나 해당 함수(함수 컴포넌트)가 다시 실행돼야 한다. 그러나 위 경우 부모 컴포넌트가 없으며, props도 없기 때문에 일일이 Counter()를 재실행시켜야 하지만 그것은 매우 비효율적이다.

이를 useState의 인수로 컴포넌트 밖에서 선언한 state를 넘겨주는 방식으로 코드를 변경해보았다. 👇

```jsx
function Counter1() {
  const [count, setcount] = useState(state);

  function handleClick() {
    // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음, 그 값을 로컬 상태값에도 넣었다.
    set((prev: State) => {
      const newState = { counter: prev.counter + 1 };
      // setCount가 호출되면서 컴포넌트 리렌더링을 야기한다.
      setCount(newState);
      return newState;
    });
  }

  return (
    <>
      <h3>{count.counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

```jsx
function Counter2() {
  const [count, setcount] = useState(state);

  // 위 컴포넌트와 동일한 작동을 추가
  function handleClick() {
    set((prev: State) => {
      const newState = { counter: prev.counter + 1 };
      setCount(newState);
      return newState;
    });
  }

  return (
    <>
      <h3>{count.counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- useState의 초깃값으로 컴포넌트 외부에 있는 값을 사용 (일반적인 리액트 코드 작성 방식)
- handleClick으로 state를 업데이트
- useState의 두 번째 인수로 업데이트하는 것은 해당 지역 상태에만 영향을 미치기 때문에 여기서는 외부에 선언한 set을 실행해 외부의 상태값 또한 업데이트하도록 수정했다.
- 외부의 상태를 수정하고 useState의 두 번째 인수도 실행한다면 리액트 컴포넌트는 렌더링될 것이고 계속해서 외부의 값을 안정적으로 참조할 수 있게 된다.

- 하지만 외부에 상태가 있음에도 불구하고, 함수 컴포넌트의 렌더링을 위해 함수의 내부에 동일한 상태를 관리하는 useState가 존재하는 구조로 이는 상태를 중복해서 관리하므로 비효율적인 방식이라고 볼 수 있다.
- 또한 실제로 각 컴포넌트의 버튼을 누르면 이상하게 작동하는 것을 확인할 수 있는데 버튼을 누르면 해당 컴포넌트가 렌더링되면서 원하는 값을 안정적으로 렌더링하지만 같은 상태를 바라봐야 하는 반대쪽 컴포넌트에서는 렌더링되지 않는다.
- 반대쪽 컴포넌트는 버튼을 눌러야 그제서야 렌더링되어 최신값을 불러온다. 그러면 또 다시 반대족은 렌더링되지 않는다.

❓ 왜 같은 상태를 공유하지만 동시에 렌더링되지 않을까?

useState로 멈포넌트의 리렌더링을 실행해 최신값을 가져오는 방법은 해당 컴포넌트 자체에서만 유효한 전략이다.

즉. 반대쪽의 다른 컴포넌트에서는 여전히 상태의 변화에 다른 리렌더링을 일으켜 무언가가 없기 대문에 클릭 이벤트가 발생하지 않는 다른 쪽은 여전히 렌더링이 되지 않는다.

결론을 말하자면 함수 외부에서 상태를 참조하고 이를 통해 헨더링까지 자연스럽게 일어나려면 다음과 같은 조건을 만족해야 한다.

1. 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야 한다. 이 상태 감지는 상태를 변경시키는 컴포넌트뿐만 아니라 이 상태를 참조하는 모든 컴포넌트에서 동이랗게 작동해야 한다.
3. 상태가 원시값이 아닌 객체인 경우에 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안 된다. 예를 들어, {a: 1, b: 2}라는 상태가 있으며 어느 컴포넌트에서 a를 2로 업데이트했다고 가정해보자. 이러한 객체 값의 변화가 단순히 b의 값을 참조하는 컴포넌트에서는 리렌더링을 일으켜서는 안 된다는 뜻이다.

위 조건을 만족하는, 컴포넌트 레벨의 지역 상태를 벗어나는 새로운 상태 관리 코드를 아래에서 확인해보자.

```jsx
type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

type Store<State> = {
	get: () => State
	set: (action: Initializer<State>) => State
	subscribe: (callback: () => void) => () => void
}
```

- get : 항상 최신값을 가져와야 하므로 함수로 구현했다. 이 get을 변수 대신 함수로 만들어두면 항상 새롭게 값을 가져오기 위해 시도할 것이므로 최신값을 가져올 수 있다.
- set : 기존에 많이 사용하고 있는 useState와 동일하게 값 또는 함수를 받을 수 있도록 생성
- subscribe : 이 store의 변경을 감지하고 싶은 컴포넌트들이 자신의 callback 함수를 등록해 두는 곳
  → callback을 인수로 받으며, store는 값이 변경될 때마다 자신에게 등록된 모든 callback을 실행하게 할 것이다.
  → 또한 이 store를 참조하는 컴포넌트는 subscribe에 컴포넌트 자기 자신을 렌더링하는 코드를 추가해서 컴포넌트가 리렌더링을 실행할 수 있게 만들 것이다.

이제 `Store<State>` 함수를 실제로 작성해보자.

```jsx
export const createStore = <State extends unknown>(
	initialState: Initializer<State>,
): Store<State> => {
	// useState와 마찬가지로 초깃값을 게으른 초기화를 위한 함수 또한
	// 그냥 값을 받을 수 있도록 한다.
	// state의 값은 스토어 내부에서 보관해야 하므로 변수로 선언한다.
	let state = typeof initialState !== 'function' ? initialState : initialState()

	// callbacks는 자료형에 관계없이 유일한 값을 저장할 수 있는 Set을 사용한다.
	const callbacks = new Set<() => void>()
	// 언제든 get이 호출되면 최신값을 가져올 수 있도록 함수로 만든다.
	const get = () => state
	const set = (nextState: State | ((prev: State) => State)) => {
		//인수가 함수라면 함수를 실행해 새로운 값을 받고,
		// 아니라면 새로운 값을 그대로 사용한다.
		state =
			typeof nextState === 'function'
				? (nextState as (prev: State) => State)(state)
				: nextState

		// 값의 설정이 발생하면 콜백 목록을 순회하면서 모든 콜백을 실행한다.
		callbacks.forEach((callback) => callback())

		return state
}

	// subscribe는 콜백을 인수로 받는다.
	const subscribe = (callback: () => void) => {
		// 받은 함수를 콜백 목록에 추가한다.
		callbacks.add(callback)
		// 클린업 실행 시 이를 삭제해서 반복적으로 추가되는 것을 막는다.
		return () => {
			callbacks.delete(callback)
		}
	}
	return { get, set, subscribe }
}
```

→ store를 만드는 createStore를 구현한 코드이다. 하나씩 단계별로 살펴보자.

1. 먼저 store의 초깃값을 state 또는 게으른 초기화 함수를 받아 store의 기본값을 초기화할 수 있게 해뒀다.
2. 1번에서 받은 인수를 바탕으로 함수를 실행하거나 초깃값 그 자체를 할당해 state 초깃값을 할당한다.
3. 컴포넌트로 넘겨받는 콜백 함수를 저장하기 위해 callbacks를 Set으로 선언한다. Set은 원시값이나 객체에 관계없이 유일한 값을 저장할 수 있어 중복 없이 콜백 함수를 저장하는 용도로 유용하다.
4. get을 함수로 만들어 매번 최신값을 가져올 수 있게 만든다.
5. set을 만들어 새로운 값을 넣을 수 있도록 만든다. useState의 두 번째 인수와 마찬가지로 함수일 수도, 단순히 값을 받을 수도 있다. 그리고 값을 설정한 이후에 callbacks를 순회해 등록된 모든 콜백을 실행한다. set으로 값을 설정하는 순간 콜백을 모두 실행해 컴포넌트의 렌더링을 유도할 것이다.
6. subscribe는 callbacks Set에 callback을 등록할 수 있는 함수다 . callbacks.add와 더불어, 반환값으로는 등록된 callback을 삭제하는 함수를 반환한다. 이는 callbacks에 callback이 무난히 추가되는 것을 방지하게 만들어져 있으며, useEffect의 클린업 함수와 동일한 역할을 한다.
7. 마지막으로 get, set, subscribe를 하나의 객체로 반환해 외부에서 사용할 수 있도록 한다.

⇒ createStore는 자신이 관리해야 하는 상태를 내부 변수로 가진 다음, get 함수로 해당 변수의 최신값을 제공하며, set 함수로 내부 변수를 최신화하며, 이 과정에서 등록된 콜백을 모두 실행하는 구조이다.

마지막으로 createStore로 만들어진 store의 값을 참조하고, 이 값의 변화에 따라 컴포넌트 렌더링을 유도할 사용자 정의 훅이 필요하다.

useStore라는 훅을 만들어 이 store의 변화를 감지할 수 있게 코드를 작성해보자.

```jsx
export const useStore = <State extends unknown>(store: Store<State>) => {
	const [state, setState] = useState<State>(() => store.get())

	useEffect(() => {
		const unsubscribe = store.subscribe(() => {
			setState(store.get())
		})
		return unsubscribe
	}, [store])

	return [state, store.set] as const
}
```

1. 먼저 훅의 인수로 사용할 store를 받는다.
2. 이 스토어의 값을 초깃값으로 하는 useState를 만든다. 이제 이 useState가 컴포넌트의 렌더링을 유도한다.
3. useEffect는 store의 현재 값을 가져와 setState를 수행하는 함수를 store의 subscribe로 등록해 두었다. createStore 내부에서 값이 변경될 때마다 subscribe에 등록된 함수를 실행하므로 useStore 내부에서는 store의 값이 변경될 때마다 state의 값이 변경되는 것을 보장받을 수 있다.
4. 마지막으로 useEffect의 클린업 함수로 unsubscribe를 등록해 둔다. useEffect의 작동이 끝난 이후에는 callback에서 해당 함수를 제거해 callback이 계속해서 쌓이는 현상을 방지했다.

이 상태 관리 방식이 잘 작동하는지 확인해보자.

```jsx
const store = createStore({ count: 0 });

function Counter1() {
  const [state, setState] = useStore(store);

  function handleClick() {
    setState((prev) => ({ count: prev.count + 1 }));
  }

  return (
    <>
      <h3>Counter1: {state.count}</h3>
      <button onclick={handleClick}>+</button>
    </>
  );
}

function Counter2() {
  const [state, setState] = useStore(store);

  function handleClick() {
    setState((prev) => ({ count: prev.count + 1 }));
  }

  return (
    <>
      <h3>Counter2: {state.count}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}

export default function App() {
  return (
    <div className="App">
      <Counter1 />
      <Counter2 />
    </div>
  );
}
```

- Counter1과 Counter2의 버튼을 각각 클릭하면 store의 상태가 변경됨과 동시에 두 컴포넌트가 모두 정상적으로 리렌더링된다.
- 하지만 스토어의 구조가 원시값이 아나라 객체로써 객체의 일부값만 변경될 경우, 즉, store의 값이 바뀌면 무조건 useState를 실행하므로 스토어에 어떤 값이 바뀌든지 간에 리렌더링이 일어난다.

그럼 이제 객체의 원하는 값이 변했을 때만 리렌더링 되도록 훅을 구성해보자.

- useState 훅에서 subscribe는 위 예제와 동일하게 수행하되 변경 감지가 필요한 값만 setState를 호출해 객체 상태에 대한 불필요한 리렌더링을 막을 수 있을 것이다.

```jsx
export const useStoreSelector = <State extends unknown, Value extends unknown>(
	store: Store<State>,
	selector: (state: State) => Value,
) => {
	const [state, setState] = useState(() => selector(store.get()))

	useEffect(() => {
		const unsubscribe = store.subscribe(() => {
			const value = selector(store.get())
			setState(value)
		})

		return unsubscribe
	}, [store, selector])

	return state
}
```

- useStoreSelector는 useStore를 기반으로 만들어졌지만 두 번째 인수로 selector라고 하는 함수를 받는다는 차이점이 있다.
- 이 함수는 store의 상태에서 어떤 값을 가져올지 정의하는 함수로, 이 함수를 활용해 store.get()을 수행한다.
- useState는 값이 변경되지 않으면 리렌더링을 수행하지 않으므로 store의 값이 변경됐다 하더라도 selector(store.get())이 변경되지 않는다면 리렌더링이 일어나지 않는다.

이 useStoreSelector 훅을 사용하는 예제를 확인해보자.

```jsx
const store = createStore({ count: 0, text: "hi" });

function Counter() {
  const counter = useStroeSelector(
    store,
    useCallback((state) => state.count, [])
  );

  function handleClick() {
    store.set((prev) => ({ ...prev, count: prev.count + 1 }));
  }

  useEffect(() => {
    console.log("Counter Rendered");
  });

  return (
    <>
      <h3>{counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}

const textSelector = (state: ReturnType<typeof store.get>) => state.text;

function TextEditor() {
  const text = useStoreSelector(store, textSelector);

  useEffect(() => {
    console.log("TextEditor Rendered");
  });

  function handleChange(e: ChangeEvent<HtmlInputElement>) {
    store.set((prev) => ({ ...prev, text: e.target.value }));
  }

  return (
    <>
      <h3>{text}</h3>
      <input value={text} onChange={handleChange} />
    </>
  );
}
```

→ useStoreSelector를 사용하면 store가 객체로 구성되어 있어도 컴포넌트에서 필요한 값만 select해서 사용할 수 있고, 이 select 또한 실제로 객체에서 변경된 값에 대해서만 수행할 것이다.

→ 이 때 주의할 점은 useStoreSelector에 제공하는 두 번째 인수인 selector를 컴포넌트 밖에 선언하거나, 이것이 불가능하다면 useCallback을 사용해 참조를 고정시켜야 한다. 만약 컴포넌트 내에 이 selector 함수를 생성하고 useCallback으로 감싸두지 않는다면 컴포넌트가 리렌더링될 때마다 함수가 계속 재생성되어 store의 subscribe를 반복적으로 수행할 것이다.

지금까지 만들어 본 useStroeSelector 훅은 useSubscription으로 이미 존재하는 훅이다.

아래는 동일한 내용을 useSubscription으로 구현한 코드이다.

```jsx
function NewCounter() {
  const subscription = useMemo(
    () => ({
      // 스토어의 모든 값으로 설정해 뒀지만 selector 예제와 마찬가지로
      // 특정한 값에서만 가져오는 것도 가능하다.
      getCurrentValue: () => store.get(),
      subscribe: (callback: () => void) => {
        const unsubscribe = store.subscribe(callback);
        return () => unsubscribe();
      },
    }),
    []
  );

  const value = useSubscription(subscription);

  return <>{JSON.stringfy(value)}</>;
}
```

→ useSubscription을 사용하면 외부에 있는 데이터를 가져와서 사용하고 리렌더링까지 정상적으로 수행된다.

하지만 useSubscription은 useStore와 몇 가지 차이점이 있다. 다음 코드를 확인해보자.

useSubscription을 타입스크립트로 구현한 코드이다.

```jsx
import { useDebugValue, useEffect, useState } from 'react'

export function useSubscription<Value>({
	getCurrentValue,
	subscribe,
}: {
	getCurrentValue: () => Value
	subscribe: (callback: Function) => () => void
}): Value {
	// 현재값을 가져오는 함수, subscribe, 그리고 현재값을 모두 한꺼번에 객체로 저장해 둔다.
	const [state, setState] = useState(() => ({
		getCurrentValue,
		subscribe,
		value: getCurrentValue(),
	}))

	// 현재 가져올 값을 따로 변수에 저장해 둔다.
	let valueToReturn = state.value

	// useState에 저장돼 있는 최신값을 가져오는 함수 getCurrentValue와
	// 함수의 인수로 받은 getCurrentValue가 다르거나
	// useState에 저장돼 있는 subscribe와 함수의 인수로 받은 subscribe가 다르다면
	if (
		state.getCurrentValue !== getCuurentValue ||
		state.subscribe !== subscribe
	) {
		// 어디선가 두 함수의 참조가 바뀐 것이므로 이 바뀐 참조를 존중해
		// 반환 예정인 현재값을 함수의 인수의 getter로 다시 실행한다.
		valueToReturn = getCurrentValue()

		// 참조가 변경됐으므로 이 값을 일괄 업데이트한다.
		setState({
			getCurrentValue,
			subscribe,
			value: valueToReturn,
		})
	}

	// 디버깅을 위해 현재 반환할 값을 리액트 개발자 모드로 기록한다.
	useDegubValue(valueToReturn)

	// useEffect 실행 시 위에서 실행된 if문 덕분에 getCurrentValue와
	// subscribe의 참조를 최신 상태로 유지할 수 있다.
	// 이 두 함수를 의존성으로 두고 다음 useEffect를 실행한다.
	useEffect(() => {
		// subscribe가 취소됐는지 여부
		let disUnsubscribe = false

		// 값의 업데이트가 일어났는지 확인하는 함수
		const checkForUpdates = () => {
			// 이미 subscribe가 취소됐다면 아무것도 하지 않는다.
			if (disUnsubscribe) {
				return
			}

			// 현재 값을 가져온다.
			const value = getCurrentValue()

			// useSubscription을 사용하는 컴포넌트의 렌더링을 일으키는 코드
			setState((prevState) => {
				// 이전과 비교해 단순히 함수의 차이만 존재한다면 이전 값을 반환한다.
				if (
					prevState.getCurrentValue !== getCurrentValue ||
					prevState.subscribe !== subscribe
				) {
					return prevState
				}

				// 이전 값과 현재 값이 같다면 이전 값을 반환한다.
				if (prevState.value === value) {
					return prevState
				}

				//이전 prevState와 현재 값을 합성해 새로운 객체를 만들고 렌더링을 일으킨다.
				return { ...prevState, value }
			})
		}

		// 콜백 목록에 변경 여부를 체크하는 함수를 등록한다.
		const unsubscribe = subscribe(checkForUpdates)

		checkForUpdates()

		return () => {
			disUnsubscribe = true
			unsubscribe()
		}
	}, [getCurrentValue, subscribe])

	return valueToReturn
}
```

- 차이점은 selector(여기서는 getCurrentValue)와 subscribe에 대한 비교 추가
- useStore나 useStoreSelector 모두 useEffect의 의존성 배열에 store나 selector가 들어가 있어 이 객체가 임의로 변경될 경우 불필요하게 리렌더링이 발생한다는 문제점이 있다.

  → useSubscription 내부에는 예외 처리를 추가해 이러한 변경이 알려지는 동안에는 store나 selector의 변경을 무시하고 한정적으로 원하는 값을 반환하게끔 훅이 작성돼있다.

  → 이로 인해 훨씬 더 안정적인 상태를 제공할 수 있다.

- 리액트 18버전의 useSubscription는 훅 자체가 useSyncExternalStore로 재작성되어 있다.

## 🖌️ useState와 Context를 동시에 사용해보기

앞에서 다뤘던 useStore 또는 useStoreSelector 훅을 활용해 useState로 관리하지 않는 외부 상태값을 읽어오고 리렌더링까지 일으켜서 상태 관리 라이브러리 처럼 사용되는 훅에도 단점이 있다.

→ 이 훅과 스토어를 사용하는 구조는 반드시 하나의 스토어만 가지게 된다.

→ 하나의 스토어를 가지면 이 스토어는 마치 전역 변수처럼 작동하게 되어 동일한 형태의 여러 개의 스토러를 가질 수 없게 된다.

❓ 만약 훅을 사용하는 서로 다른 스코프에서 스토어의 구조는 동일하되, 여러 개의 서로 다른 데이터를 공유해 사용하고 싶다면 어떻게 해야 할까?

- createStore를 이용해 동일한 타입으로 스토어를 여러 개 만든다.
  ```jsx
  const store1 = createStore({ count: 0 });
  const store2 = createStore({ count: 0 });
  const store3 = createStore({ count: 0 });
  ```
  - 해당 스토어가 필요할 때마다 반복적으로 스토어를 생성해야 한다.
  - 스토어에 의존적인 1:1 관계를 맺고 있으므로 스토어를 만들 때마다 해당 스토어에 의존적인 useStore와 같은 훅을 동일한 개수로 생성해야 한다.
  - 이 훅이 어느 스토어에서 사용 가능한지를 가늠하려면 오직 훅의 이름이나 스토어의 이름에 의지해야 한다.

👇 이러한 문제를 해결하기 좋은 방법은 바로 `리액트의 Context`이다 ❣️

- Context를 활용해 해당 스토어를 하위 컴포넌트에 주입한다면 컴포넌트에서는 자신이 주입된 스토어에 대해서만 접근할 수 있게 될 것이다.

```jsx
// Context를 생성하면 자동으로 스토어도 함께 생성한다.
export const CounterStoreContext = createContext<Store<CounterStore>>(
	createStore<CounterStore>({ count: 0, text: 'hello' }),
)

export const CounterStoreProvider = ({
	initialState,
	children,
}: PropsWithChildren<{
	initialState: CounterStore
}>) => {
	const storeRef = useRef<Store<CounterStore>>()

	// 스토어를 생성한 적이 없다면 최초에 한 번 생성한다.
	if (!storeRef.current) {
		storeRef.current = createStore(initialState)
	}

	return (
		<CounterStoreContext.Provider value={storeRef.current}>
			{children}
		</CounterStoreContext.Provider>
	)
}
```

- CounterStoreContext를 통해 먼저 어떠한 Context를 만들지 타입과 함께 정의
- 타입과 함께 정의된 Context를 사용하기 위해 CounterStoreProvider를 정의

  - 이 Provider에서는 storeRef를 사용해서 스토어를 제공하는데, 그 이유는 Provider로 넘기는 props가 불필요하게 변경돼서 리렌더링되는 것을 막기 위해서이다.
  - 이렇게 useRef를 사용했기 때문에 CounterStoreProvider는 오직 최초 렌더링에서만 스토러를 만들어서 값을 내려준다.

- 이 Context에서 내려주는 값을 사용하기 위해 useStore나 useStoreSelector 대신에 다른 접근이 필요하다.
  → 기존의 두 훅은 스토어에 직접 접근하는 방식이지만 이 훅은 Context에서 제공하는 스토어에 접근해야 하기 때문이다.
- useContext를 사용해 스토어에 접근할 수 있는 새로운 훅이 필요하다.

```jsx
export const useCounterContextSelector = <State extends unknown> (
	selector: (state: CounterStore) => State,
) => {
	const store = useContext(CounterStoreContext)
	// useStoreSelector를 사용해도 동일하다.
	const subscription = useSubscription(
		useMemo(
			() => ({
				getCurrentValue: () => selector(store.get()),
				subscribe: store.subscribe,
			}),
			[store, selector],
		),
	)

	return [subscription, store.set] as const
}
```

→ 위에서 작성한 useStoreSelector와의 차이점에 대해 알아보자.

- useStoreSelector 대신에 리액트에서 제공하는 useSubscription을 사용
  - 불필요한 반복을 제거하기 위해 useSubscription 사용
- 스토어에 접근하기 위해 useContext 사용
  - 즉, 스토어에 서 값을 찾는 것이 아니라 Context.Provider에서 제공된 스토어를 찾게 만드는 것이다.

다음은 이 훅과 Context를 사용하는 코드이다.

```jsx
const ContextCounter = () => {
	const id = useId()

	const [counter, setStore] = useCounterContextSelector(
		useCallback((state: CounterStore) => state.count, []),
	}

	function handleClick() {
		setStore((prev) => ({ ...prev, count: prev.count + 1 }))
	}

	useEffect(() => {
		console.log(`${id} Counter Rendered`)
	})

	return (
		<div>
			{counter} <button onClick={handleClick}>+</button>
		</div>
	)
}

const ContextInput = () => {
	const id = useId()
	const [text, setStore] = useCounterContextSelector(
		useCallback((state: CounterStore) => state.text, []),
	)

	function handleChange(e: ChangeEvent<HTMLInputElement>) {
		setStore((prev) => ({ ...prev, text: e.target.value }))
	}

	useEffect(() => {
		console.log(`${id} Counter Rendered`)
	}

	return (
		<div>
			<input value={text} onChange={handleChange} />
		</div>
	)
}

export default function App() {
	return (
		<>
			{/* 0 */}
			<ContextCounter />
			{/* hi */}
			<ContextInput />
			<CounterStoreProvider initialState={{ count: 10, text: 'hello' }}>
				{/* 10 */}
				<ContextCounter />
				{/* hello */}
				<ContextInput />
				<CounterStoreProvider initialState={{ count: 20, text: 'welcome' }}>
					{/* 20 */}
					<ContextCounter />
					{/* welcome */}
					<ContextInput />
				</CounterStoreProvider>
			</CounterStoreProvider>
		</>
	)
}
```

- <ContextCounter />와 <ContextInput /> 컴포넌트는 부모에 <CounterStoreProvider />가 존재하지 않아도 각각 초깃값을 가져온다.
  → 그 이유는 CounterStoreContext의 작동 방식 때문이다.
- CounterStoreContext를 만들 때 초깃값을 인수로 넘겨줬는데, 이 인수는 Provider가 없을 경우 사용하게 된다. 즉, Provider가 없는 상황에서는 앞선 스토어 예제와 마찬가지로 전역으로 생성된 스토어를 바라보게 될 것이다.
- 두 번째 <ContextCounter />와 <ContextInput />은 { count: 10, text: ‘hello’ }로 초기화된 CounterStoreProvider 내부에 있다. 따라서 각 컴포넌트는 10, hello를 값으로 가져오게 된다.
- 마지막 <ContextCounter />와 <ContextInput />은 앞의 Provider 외에도 또 가까운 Provider를 하나 더 가지고 있는데, 이 Provider는 { count: 20, text: ‘welcome’ }으로 초기화되어 있다. Context는 가장 가까운 Provider를 참조하므로 여기서 각 컴포넌트는 20, welcome을 값으로 가지게 된다.

⇒ Context와 Provider를 기반으로 각 store 값을 격리해서 관리함으로써

1. 먼저 스토어를 사용하는 컴포넌트는 해당 상태가 어느 스토어에서 온 상태인지 신경 쓰지 않아도 된다. (`해당 스토어를 기반으로 어떤 값을 보여줄지만 고민하면 되므로 좀 더 편리하게 코드를 작성할 수 있다.`)
2. Context와 Provider를 관리하는 부모 컴포넌트의 입장에서는 자신이 자식 컴포넌트에 따라 보여주고 싶은 데이터를 Context로 잘 격리하기만 하면 된다.
3. 부모와 자식 컴포넌트의 책임과 역할을 이름이 아닌 명시적인 코드로 나눌 수 있어 코드 작성이 한결 용이해진다.

✅ 정리

- useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다. 이는 컴포넌트의 최상단 내지는 상태가 필요한 부모가 될 수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있다.
- 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

👉 이 두 가지를 염두에 두고 코드를 작성하거나 라이브러리를 설치해 본다면 리액트에서의 상태 관리와 렌더링에 대해 좀 더 넓은 시야를 가질 수 있게 된다.

## 🖌️ 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

`Recoil`과 `Jotai`는 Context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞추고 있다.

`Zustand`는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리이다. Recoil, Jotail와 다르게 이 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식이다.

### Recoil - 페이스북이 만든 상태 관리 라이브러리

Recoil은 리액트를 만든 페이스북에서 만든 리액트를 위한 상태 관리 라이브러리다.

리액트에서 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리 중 하나이며, 최소 상태 개념인 Atom을 처음 리액트 생태계에서 선보였다.

Recoil은 실제 프로덕션에 사용하기에는 안정성이나, 성능, 사용성 등을 보장할 수 없으며, 유의적 버전에 따라 부(minor) 버전이 변경돼도 호환성이 깨지는 변경 사항이 발생할 수도 있다.

⭐ 그렇다면 Recoil이 어떻게 작동하는지 직접 소스코드를 통해 살펴보자.

Recoil의 핵심 API인 RecoiRoot, atom, useRecoilValue, useRecoilState를 살펴보고 Recoil에서는 상태값을 어디에 어떻게 저장하고, 또 컴포넌트의 렌더링은 어떻게 발생시키는지 그 원리를 알아볼 예정이다.

**RecoilRoot**

Recoil을 사용하기 위해서는 `RecoilRoot`를 애플리케이션의 최상단에 선언해 둬야 한다.

```jsx
export default function App() {
  return <RecoilRoot>{/* some components */}</RecoilRoot>;
}
```

→ `RecoilRoot`는 Redoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성하는 것을 확인할 수 있다.

✅ RecoilRoot 코드

```jsx
function RecoilRoot(props: Props): React.Node {
  const { override, ...propsExceptOverride } = props;

  const ancestorStoreRef = useStoreRef();
  if (override === false && ancestorStoreRef.current !== defaultStore) {
    // If ancestorStoreRef.current !== defaultStore, it means that this
    // RecoilRoot is not nested within another
    return props.children;
  }

  return <RecoilRoot_INTERNAL {...propsExceptOverride} />;
}
```

→ useStoreRef는 ancestorStoreRef의 존재를 확인하고, 이는 Recoil에서 생성되는 atom과 같은 상태값을 저장하는 스토어를 의미한다. 그리고 이 useStoreRef가 가리키는 것은 AppContext가 가지고 있는 스토어이다.

✅ useStoreRef 코드

```jsx
const AppContext = React.createContext < StoreRef > { current: defaultStore };
const useStoreRef = (): StoreRef => useContext(AppContext);
```

스토어의 기본값을 의미하는 defatulStore는 다음과 같다.

```jsx
function notInAContext() {
  throw err("This component must be used inside a <RecoilRoot> component.");
}

const defualtStore: Store = Object.freeze({
  storeID: getNextStoreID(),
  getState: notInAContext,
  replaceState: notInAContext,
  getGraph: notInAContext,
  subscribeToTransactions: notInAContext,
  addTransactionMetadata: notInAContext,
});
```

- 스토어의 아이디 값을 가져올 수 있는 함수인 getNextStoreID()
- 스토어의 값을 가져오는 함수인 getState
- 값을 수정하는 함수인 replaceState

⇒ 해당 스토어 아이디를 제외하고는 모두 에러로 처리되어 있어 RecoilRoot로 감싸지 않은 컴포넌트에서는 스토어에 접근할 수 없다.

✅ Recoil의 replaceState 코드

```jsx
const replaceState = (replacer: (TreeState) => TreeState) => {
  startNextTreeIfNeeded(storeRef.current);
  // Use replacer to get the next state:
  const nextTree = nullthrows(storeStateRef.current.nextTree);
  let replaced;
  try {
    stateReplacerIsBeingExecuted = true;
    replaced = replacer(nextTree);
  } finally {
    stateReplacerIsBeingExecuted = false;
  }
  if (replaced === nextTree) {
    return;
  }

  // ...생략

  // Save change to nextTree and schedule a React update:
  storeStateRef.current.nextTree = replaced;
  if (reactMode().early) {
    notifyComponents(storeRef.current, storeStateRef.current, replaced);
  }
  // ...
};
```

→ 상태가 변할 때 이 변경된 상태를 하위 컴포넌트로 전파해 컴포넌트에 리렌더링을 일으키는 notifyComponents가 있는데 아래에서 이 구조도 살펴보자.

✅ notifyComponents 구조

```jsx
function notifyComponents(
  store: Store,
  storeState: StoreState,
  treeState: TreeState
): void {
  const dependentNodes = getDownstreamNodes(
    store,
    treeState,
    treeState.dirtyAtoms
  );
  for (const key of dependentNodes) {
    const comps = storeState.nodeToComponentSubscriptions.get(key);
    if (comps) {
      for (const [_subID, [_debugName, callback]] of comps) {
        callback(treeState);
      }
    }
  }
}
```

→ notifyComponents는 store, 그리고 상태를 전파할 storeState를 인수로 받아 이 스토어를 사용하고 있는 하위 의존성을 모두 검색한 다음, 여기에 있는 컴포넌트들을 모두 확인해 콜백을 실행하는 것을 볼 수 있다. 값이 변경됐을 때 콜백을 실행해 상태 변화를 알린다는 사실은, 앞서 구현해 본 바닐라 스토어와 크게 다르지 않다.

✅ 정리

- Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
- 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
- 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.

**atom**

atom은 상태를 나타내는 Recoil의 최소 상태 단위다.

```jsx
type Statement = {
	name: string
	amount: number
}

const InitialStatement: Array<Statement> = [
	{ name: '과자', amount: -500 },
	{ name: '용돈', amount: 10000 },
	{ name: '네이버페이충전', amount: -5000 },
]

// Atom 선언
const statementsAtom = atom<Array<Statement>>({
	key: 'statements',
	default: InitialStatements,
})
```

- atom은 key 값을 필수로 가지며, 이 키는 다른 atom과 구별하는 식별자가 되는 필수 값이다. 이 키는 애플리케이션 내부에서 유일한 값이어야 하기 때문에 atom과 selector를 만들 때 반드시 주의를 기울여야 한다.
- default는 atom의 초깃값을 의미한다.

이 atom의 값을 컴포넌트에서 읽어오고 이 값의 변화에 따라 컴포넌트를 리렌더링하려면 다음 두가지 훅을 사용하면 된다.

**useRecoilValue**

`useRecoilValue`는 atom의 값을 읽어오는 훅이다. 이 훅을 사용하면 다음과 같이 atom의 값을 가져올 수 있다.

```jsx
function Statements() {
  const statements = useRecoilValue(statementsAtom);
  return (
    <>{/* something.. */}</>
    // ...
  );
}
```

그럼 이 useRecoilValue 훅이 어떻게 구현됐는지 확인해보자.

✅ useRecoilValue 훅의 구현

```jsx
// useRecoilValue
function useRecoilValue<T>(recoilValue: RecoilValue<T>): T {
  if (__DEV__) {
    validateRecoilValue(recoilValue, "useRecoilValue");
  }
  const storeRef = useStoreRef();
  const loadable = useRecoilValueLoadable(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}

// ...

// useRecoilValueLoadable
function useRecoilValueLoadable_LEGACY<T>(
  recoilValue: RecoilValue<T>
): Loadable<T> {
  const storeRef = useStoreRef();
  const [, forceUpdate] = useState([]);
  const componentName = useComponentName();

  const getLoadable = useCallback(() => {
    if (__DEV__) {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode().early
      ? storeState.nextTree ?? storeState.currentTree
      : storeState.currentTree;
    return getRecoilValueAsLoadable(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);

  const loadable = getLoadable();
  const prevLoadableRef = useRef(loadable);
  useEffect(() => {
    prevLoadableRef.current = loadable;
  });

  useEffect(() => {
    const store = storeRef.current;
    const storeState = store.getState();
    // 현재 recoil의 값을 구독하는 함수다.
    const subsription = subscribeToRecoilValue(
      store,
      recoilValue,
      (_state) => {
        if (!gkx("recoil_suppress_rerender_in_callback")) {
          return forceUpdate([]);
        }
        const newLoadable = getLoadable();
        // is는 두 객체가 같은지 비교하고, 다르다면 렌더링을 유도한다.
        if (!prevLoadableRef.current?.is(newLoadable)) {
          forceUpdate(newLoadable);
        }
        prevLoadableRef.current = newLoadable;
      },
      componentNAme
    );
    if (storeState.nextTree) {
      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
        prevLoadableRef.current = null;
        forceUpdate([]);
      });
    } else {
      if (!gkx("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getLoadable();
      // 값을 비교해서 값이 다르다면 forceUpdate를 실행한다.
      if (!prevLoadableRef.current?.is(newLoadable)) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }

    // 클린업 함수에 substribe를 해제하는 함수를 반환한다.
    return subscription.release;
  }, [componentName, getLoadable, recoilValue, storeRef]);

  return loadable;
}
```

- useRecoilValue와 useRecoilValueLoadable 코드로, 코드를 직관적으로 이해할 수 있게 useRecoilValueLoadable_LEGACY를 가져왔다.
- getLoadable은 현재 Recoil이 가지고 있는 상태값을 가지고 있는 클래스인 loadable을 반환하는 함수다.
- 이 값을 이전값과 비교해 렌더링이 필요한지 확인하기 위해 렌더링을 일으키지 않으면서 값을 저장할 수 있는 ref에 매번 저장한다.
- useEffect를 통해 recoilValue가 변경됐을 때 forceUpdate를 호출해 렌더링을 강제로 일으킨다.
- forceUpdate는 렌더링을 강제로 실행시키기 위한 함수다. useState의 두 번째 인수로, useState 값을 사용하기 위함이 아닌 렌더링만 발생시키기 위해 실행된다.

**useRecoilState**

`useRecoilState`는 useState와 유사하게 값을 가져오고, 또 이 값을 변경할 수도 있는 훅이다.

✅ useRecoilState

```jsx
// useRecoilState
function useRecoilState<T>(
  recoilState: RecoilState<T>
): [T, SetterOrUpdater<T>] {
  if (__DEV__) {
    validateRecoilValue(recoilState, "useRecoilState");
  }
  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];
}
```

- useRecoilState는 useState와 유사한 구조로 작성되어 있다.
- 현재 값을 가져오기 위해 useRecoilValue를 그대로 사용하고 있고, 상태를 설정하는 훅으로 useSetRecoilState 훅을 사용하고 있다.
- 이 훅은 내부에서 먼저 스토어를 가져온 다음에 setRecoilValue를 호출해 값을 업데이트하고 있다.

✅ useSetRecoilState

```jsx
// useSetRecoilState
/**
	Returns a function that allows the value of a RecoilState to be updated, but does not subscribe the component to changes to that RecoilState
	- RecoilState의 값을 업데이트할 수 있지만 해당 RecoilState에 대한 변경 사항을 구성 요소에 등록하지 않는 함수를 반환합니다.
*/

function useSetRecoilState<T>(recoilState: RecoilState<T>): SetterOrUpdater<T> {
	if (__DEV__) {
		validateRecoilValue(recoilState, 'useSetRecoilState')
	}
	const storeRef = useStoreRef()
	return useCallback(
		(newValueOrUpdater: ((T) => T | DefaultValue | T | DefaultValue) => {
			setRecoilValue(storeRef.current, recoilState, newValueOrUpdater)
		},
		[storeRef, recoilState],
	)


}
```

- setRecoilValue 내부에서는 queueOrPerformStateUpdate 함수를 호출해 상태를 업데이트하거나 업데이트가 필요한 내용을 등록하는 것을 확인할 수 있다.

✅ setRecoilValue

```jsx
// setRecoilValue
function setRecoilValue<T>(
  store: Stroe,
  recoilValue: AbstractRecoilValue<T>,
  valueOrUpdater: T | DefaultValue | ((T) => T | DefaultValue)
): void {
  queuueOrPerformStateUpdate(stroe, {
    type: "set",
    recoilValue,
    valueOrUpdater,
  });
}
```

✅ 정리

- Recoil을 사용하려면 애플리케이션의 최상단에 <RecoilRoot />를 선언해 하나의 스토어를 만들고, atom이라는 상태 단위를 <RecoilRoot />에서 만든 스토어에 등록한다.
- atom은 Recoil에서 관리하는 작은 상태 단위이며, 각 값은 고유한 값인 key를 바탕으로 구별된다.
- 컴포넌트는 Recoil에서 제공하는 훅을 통해 atom의 상태 변화를 구독(subscribe)하고, 값이 변경되면 forceUpdate 같은 기법을 통해 리렌더링을 실행해 최신 atom 값을 가져오게 된다.

**간단한 사용법**

```jsx
const counterState = atom({
  key: "counterState",
  default: 0,
});

function Counter() {
  const [, setCount] = useRecoilState(counterState);
  function handleButtonClick() {
    setCount((count) => count + 1);
  }

  return (
    <>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

// atom을 기반으로 또 다른 상태를 만들 수 있다.
const isBiggerThan10 = selector({
  key: "above10State",
  get: ({ get }) => {
    return get(counterState) >= 10;
  },
});

function Count() {
  const count = useRecoilValue(counterState);
  const biggerThan10 = useRecoilValue(isBiggerThan10);

  return (
    <>
      <h3>{count}</h3>
      <p>count is bigger than 10: {JSON.strigify(biggerThan10)}</p>
    </>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter />
      <Count />
    </RecoilRoot>
  );
}
```

- selector라는 함수를 사용하였는데 selector는 한 개 이상의 atom 값을 바탕으로 새로운 값을 조립할 수 있는 API로, useStoreSelector와 유사한 역할을 수행하다.
- 이 외에도 atom에 비동기 작업도 추가할 수 있으며, useRecoilStateLoadable, waitForAll, waitForAnywaitForAllSettled와 같이 강력한 비동기 작업을 지원하기 위한 API도 지원한다.

**특징**

- selector를 처음으로 다양한 비동기 작업을 지원하는 API를 제공하고 있기 때문에 리덕스와 달리 redux-saga나 redux-thunk 등 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리할 수 있다.
- Recoil은 아직 정식 버전인 1.0.0이 출시가 되지 않아 다른 주 버전과 다르게 부 버전이 변경돼도 호환성이 깨지는 변경 사항이 발생할 수 있는 초기 버전으로 간주되어 라이브러리를 사용할 때에 주의가 필요하다.
  (2024.7월 시점으로도 0.7.7 이다)

## 🖌️ Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai

Jotai는 공식 홈페이지에도 나와있는 것처럼, Recoil의 atom 모델에 영감을 받아 만들어진 상태 관리 라이브러리다.

Jotail는 상향식(bottom-up) 접근법을 취하고 있다고 나와 있는데 이는 리덕스와 같이 하나의 큰 상태를 애플리케이션에 내려주는 방식이 아니라, 작은 단위의 상태를 위로 전파할 수 있는 구조를 취하고 있다.

리액트 Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결하고자 설계돼 있으며, 추가적으로 개발자들이 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계되어 있다.

**atom**

여기서 atom은 Recoil과 마찬가지로 최소 단위의 상태를 의미한다.

하지만 Recoil과는 다르게, atom 하나만으로도 상태를 만들 수도, 또 이에 파생된 상태를 만들 수도 있다.

atom이 최소한의 상태 단위라는 것까지는 동일하지만 atom 하나로 파생된 상태까지 만들 수 있다는 점에서 차이가 있다.

atom은 아래와 같이 만들수있다.

```jsx
const counterAtom = atom(0);
```

이렇게 만든 textAtom에는 다음과 같은 정보가 담긴다.

```jsx
console.log(counterAtom);

// ...
// {
//   init: 0,
//   read: (get) => get(config),
//   write: (get, set, update) =>
//      set(config, typeof update === 'function' ? update(get(config)) : update)
// }
```

Jotail의 내부 atom 구현은 다음과 같다.

✅ Jotai의 atom 코드

```jsx
export function atom<Value, Update, Result extends void | Promise<void>>(
	read: Value | Read<Value>,
	write?: Write<Update, Result>,
) {
	const key = `atom${++keyCount}`
	const config = {
		toString: () => key,
	} as WritableAtom<Value, Update, Result> & { init?: Value }
	if (typeof read === 'function') {
		config.read = read as Read<Value>
	} else {
		config.init = read
		config.read = (get) => get(config)
		config.write = (get, set, update) =>
			set(config, typeof update === 'function' ? update(get(config)) : update)
		}
		if (write) {
			config.write = write
		}
		return config
	}
```

- 각 atom을 생성할 때마다 고유한 key를 필요로 했던 Recoil과는 다르게, Jotai는 atom을 생성할 때 별도의 key를 넘겨주지 않아도 된다.
  → atom 내부에는 key라는 변수가 존재하긴 하지만 외부에서 받는 값은 아니며 단순히 toString()을 위한 용도로 한정돼 있다.
- 그리고 config라는 객체를 반환하는데, 이 config에는 초깃값을 의미하는 init, 값을 가져오는 read, 값을 설정하는 write만 존재한다.
- 즉, Jotai에서의 atom에 따로 상태를 저장하고 있지 않다.
  → 그렇다면 그 상태는 `useAtomValue`에 저장해 두면 된다.

**useAtomValue**

✅ Jotai의 useAtomValue 구현

```jsx
export function useAtomValue<Value>(
	atom: Atom<Value>,
	scope?: Scope,
): Awaited<Value> {
	const ScopeContext = getScopeContext(scope)
	const scopeContainer = useContext(ScopeContext)
	const { s: store, v: versionFromProvider } = scopeContainer

	const getAtomValue = (version?: VersionObject) => {
		const atomState = store[READ_ATOM](atom, version)
		// ...
	}

	// Pull the atoms's state from the store into React state.
	// - 원자의 상태를 저장소에서 React 상태로 가져옵니다.
	const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] =
		useReducer<
			Reducer<
				readonly [VersionObject | undefined, Awaited<Value>, Atom<Value>],
				VersionObject | undefined
			>,
			VersionObject | undefined
		>(
			(prev, nextVersion) => {
				const nextValue = getAtomValue(nextVersion)
				if (Object.is(prev[1], nextValue) && prev[2] === atom) {
					return prev
				}
				return [nextVersion, nextValue, atom]
			},
			versionFromProvider,
			(initialVersion) => {
				const initilaValue = getAtomValue(initialVersion)
				return [initialVersion, initialValue, atom]
			}
		)

	let value = valueFromReducer
	if (atomFromReducer !== atom) {
		rerenderIfChanged(version)
		value = getAtomValue(version)
	}

	useEffect(() => {
		const { v: versionFromProvider } = scopeContainer
		if (versionFromProvider) {
			store[COMMIT_ATOM](atom, versionFromProvider)
		}

		const unsubscribe = store[SUBSCRIBE_ATOM](
			atom,
			rerenderIfChange,
			versionFromProvider,
		)
		rerenderIfChanged(vrsionFromProvider)
		return unsubscribe
	}, [store, atom, scopeContainer])

	// ...
	return value
}
```

- useReducer에서 반환하는 상태값은 3가지로 `[version, valueFromReducer, atomFromReducer]`인데, 첫 번째는 `store의 버전`, 두 번째는 `atom에서 get을 수행했을 때 반환되는 값`, 세 번째는 `atom 그 자체`를 의미한다.
- Recoil과는 다르게, 컴포넌트 루트 레벨에서 Context가 존재하지 않아도 되는데, Context가 없다면 앞의 예제에서처럼 Provider가 없는 형태로 기본 스토어를 루트에 생성하고 이를 활용해 값을 저장하기 때문이다.
- Jotai에서 export하는 Provider를 사용한다면 앞의 예제에서 여러 개의 Provider를 관리했던 것처럼 각 Provider별로 다른 atom 값을 관리할 수도 있다.

- 이 atom의 값은 store에 존재한다는 것을 알 수 있다. store에 atom 객체 그 자체를 키로 활용해 값을 저장한다.
  → 이러한 방식을 WeakMap이라고 하며, 자바스크립트에서 객체만을 키로 가질 수 있는 독특한 방식의 Map을 활용해 recoil과는 다르게 별도의 key를 받지 않아도 스토어에 값을 저장할 수 있다.
- `rerenderIfChanged`는 리렌더링을 일으키기 위해 사용하는 것으로, `rerenderIfChanged`가 일어나는 경우는
  1. 넘겨받은 atom이 Reducer를 통해 스토어에 있는 atom과 달라지는 경우
  2. 앞의 예제에서 구현해 본 것처럼 subscribe를 수행하고 있다가 어디선가 이 값이 달라지는 경우
     이다.

⇒ 이러한 로직 덕분에 atom의 값이 어디서 변경되더라도 useAtomValue로 값을 사용하는 쪽에서는 언제든 최신 값의 atom을 사용해 렌더링할 수 있게 된다.

**useAtom**

useAtom은 useState와 동일한 형태의 배열을 반환한다.

1. atom의 현재 값을 나타내는 useAtomValue 훅의 결과를 반환
2. useSetAtom 훅을 반환

→ 이 훅은 atom을 수정할 수 있는 기능을 제공한다.

✅ Jotai의 useAtom 구현

```jsx
export function useSetAtom<Value, Update, Result extends void | Promise<void>>(
	atom: WritableAtom<Value, Update, Result>,
	scope?: Scope,
): SetAtom<Update, Result> {
	const ScopeContext = getScopeContext(scope)
	const { s: store, w: versionedWrite } = useContext(ScopeContext)
	const setAtom = useCallback(
		(update: Update) => {
			// ...
			const write = (version?: VersionObject) =>
				store[WRITE_ATOM](atom, update, version)
			return versionedWrite ? versionedWrite(write) : write()
		},
		[store, versionedWrite, atom],
	)
	return setAtom as SetAtom<Update, Result>
}
```

- setAtom으로 명명돼 있는 콜백 함수 내부에서 사용하고 있는 write 함수는 스토어에서 해당 atom을 찾아 직접 값을 업데이트하고 있다.
- 그리고 스토어에서 새로운 값을 작성한 이후에는 해당 값의 변화에 대해 알고 있어야 하는 listener 함수를 실행해 값의 변화가 있음을 전파하고, 사용하는 쪽에서 리렌더링이 수행되게 한다.

**간단한 사용법**

다음은 Jotai에서 간단한 상태를 선언하고, 만들어진 상태로부터 파생된 상태를 사용하는 예제이다.

```jsx
import { atom, useAtom, useAtomValue } from "jotai";

const counterState = atom(0);

function Counter() {
  const [, setCount] = useAtom(counterState);

  function handleButtonClick() {
    setCount((count) => count + 1);
  }

  return (
    <>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

const isBiggerThan10 = atom((get) => get(counterState) > 10);

function Count() {
  const count = useAtomValue(counterState);
  const biggerThan10 = useAtomValue(isBiggerThan10);

  return (
    <>
      <h3>{count}</h3>
      <p>count is bigger than 10: {JOSN.stringofy(biggerThan10)}</p>
    </>
  );
}

export default function App() {
  return (
    <>
      <Counter />
      <Count />
    </>
  );
}
```

- Jotai에서 상태를 선언하기 위해서는 atom이라는 API를 사용하는데, 이 API는 리액트의 useState와는 다르게 컴포넌트 외부에서도 선언할 수 있다는 장점이 있다.
- 또한 atom은 값뿐만 아니라 함수를 인수로 받을 수 있는데, 이러한 특징을 활용해 다른 atom의 값으로부터 파생된 atom을 만들 수도 있다.
- 그리고 이 atom은 컴포넌트 내부에서 useAtom을 활용해 useState와 비슷하게 사용하거나 useAtomValue를 통해 getter만 가져올 수 있다.
- 기본적인 API 외에도 localStoreage와 연동해 영구적으로 데이터를 저장하거나, Next.js, 리액트 네이티브와 연동하는 등 상태와 관련된 다양한 작업을 Jotai에서 지원한다.

**특징**

- Recoil의 atom 개념을 도입하면서도 API가 간결하다
- Recoil의 atom에서는 각 상태값이 모두 별도의 키를 필요로 하기 때문에 이 키를 별도를 관리해야 하는데, Jotai는 이러한 부분을 추사오하해 사용자가 키를 관리할 필요가 없다.
  → Jotai가 별도의 문자열 키가 없이도 각 값들을 관리할 수 있는 것은 객체의 참조를 통해 관리하기 때문이다.
- 객체의 참조를 WeakMap에 보관해 해당 객체 자체가 변경되지 않는 한 별도의 키가 없이도 객체의 참조를 통해 값을 관리할 수 있다.
- Recoil에서는 atom에서 파생된 값을 만들기 위해서는 selector가 필요했지만, Jotail에서는 selector가 없이도 atom만으로 atom 값에서 또 다른 파생된 상태를 만들 수 있다.
  → Recoil에 비해 간결하다.
- Jotai 자체도 다른 라이브러리와 마찬가지로 타입스크립트로 작성돼 있어 타입을 잘 지원하고 있으며, 이는 Flow로 작성되어 별도로 d.ts를 제공하는 Recoil 대비 장점으로 볼 수 있다.
- Jotai 또한 리액트 18의 변경된 API를 원활하게 지원하며, 현재 v2.x 버전까지 정식으로 출시돼있어 실제 서비스하는 애플리케이션에서도 무리 없이 사용할 수 있을 것으로 보인다.
- Recoil 대비 장점이 많아 Recoil의 atom 형태의 상태 관리를 선호하지만, 아직 정식 버전이 출시되지 않아 Jotai를 채택해 개발하는 경우도 많다.

## 🖌️ 작고 빠르며 확장에도 유연한 Zustand

atom이라는 개념으로 최소 단위의 상태를 관리하는 것이 아니라 Zustand에서는 하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리하고 있다.

따라서 Zustand를 이해하려면 하나의 큰 스토어가 어떻게 만들어지는지를 먼저 살펴봐야 한다.

**Zustand의 바닐라 코드**

✅ Zustand의 스토어 코드

```jsx
const createStoreImpl: CreateStoreImpl = (createState) => {
	type TState = ReturnType<typeof createState>
	type Listener = (state: TState, prevState: TState) => void
	let state: TState
	const listeners: Set<Listener> = new Set()

	const setState: SetStateInternal<TState> = (parital, replace) => {
		// ...
		const nextState =
			typeof partial === 'function'
				? (partial as (state: TState) => TState)(state)
				: partial
			if (nextState !== state) {
				const previousState = state
				state =
					replace ?? typeof nextState !== 'object'
						? (nextState as TState)
						: Object.assign({}, state, nextState)
				listeners.forEach((listener) => listener(state, previousState))
			}
	}

	const getStateL () => TState = () => state

	const subscribe: (listener: Listener) => () => void = (listener) => {
		listeners.add(listener)
		// Unsubscribe
		return () => listeners.delete(listener)
	}

	const destroy: () => void = () => listeners.clear()
	const api = { setState, getState, subscribe, destroy }
	state = (createState as PopArgument<typeof createState>)(
		setState,
		getState,
		api
	)
	return api as any
}
```

- 스토어와 유사하게 state의 값을 useState 외부에서 관리한다.
- state라고 하는 변수가 스토어의 상태값을 담아두는 곳이며, setState는 이 state 값을 변경하는 용도로 만ㄷ늘어졌다.
- partial과 replace로 나워져 있는데, partial은 state의 일부분만 변경하고 싶을 때 사용하고, replace는 state를 완전히 새로운 값으로 변경하고 싶을 때 사용한다.
- 따라서 state의 값이 객체일 때 필요에 따라 나눠서 사용할 수 있다.
- getState는 클로저의 최신 값을 가져오기 위해 함수로 만들어져 있다.
- subscribe는 listener를 등록하는데, listener는 마찬가지로 Set 형태로 선언되어 추가와 삭제, 그리고 중복 관리가 용이하게끔 설계되어 있다.
- 즉, 상태값이 변경될 때 리렌더링이 필요한 컴포넌트에 전파될 목적으로 만들어졌음을 알 수 있다. destroy는 listeners를 초기화하는 역할을 한다.
- createStore는 이렇게 만들어진 getState, setState, subscribe, destroy를 반환하고 있다.

이 스토어 코드가 있는 파일을 들어가서 유심히 살펴보면 다음과 같은 몇가지를 확인할 수 있는데 아래에서 살펴보자.

- 이 파일은 ./src/vanilla.ts인데, 이 파일에서 export하는 유일한 함수 및 변수는 바로 이 createStore이며, 그 외에는 모두 이 createStore를 이용하는 데 필요한 타입뿐이다.
- import를 하고 있지 않은 데, 이 store는 리액트를 비롯한 그 어떤 프레임워크와는 별개로 오나전히 독립적으로 구성되어 있다는 것을 의미한다.

따라서 이 store 파일의 이름처럼, 순수하게 자바스크립트 환경에서도 사용할 수 있다.

```jsx
type CounterStore = {
	count: number
	increase: (num: number) => void
}

const store = createStore<CounterStore>((set) => ({
	count: 0,
	increase: (num: number) => set((state) => ({ count: state.count + num })),
}))

store.subscribe((state, prev) => {
	if (state.count !== prev.count) {
		console.log('count has been changed', state.count)
	}
})

store.setState((state) => ({ count: state.count + 1 })

store.getState().increase(10)
```

- createStroe로 스토어를 만들 때 set이라는 인수를 활용해 생성할 수 있다.
  - Zustand의 createStore 예제 코드와 같이 state를 생성할 때 setState, getState, api를 인수로 넘겨줬기 때문에 가능하다.
- set을 통해 현재 스토어의 값을 재정의할 수도 있고, 두 번째 인수로 get을 추가해 현재 스토어의 값을 받아올 수도 있다.
  → 이렇게 생성된 스토어는 getState와 setState를 통해 현재 스토어의 값을 받아오거나 재정의할 수 있다.
  또한 subscribe를 통해 스토어의 값이 변경될 때마다 특정 함수를 실행할 수도 있다.
  → 이 subscribe는 현재 값과 이전 값 둘 다 확인할 수 있으므로 특정 값이 변경될 때만 실행되게끔 최적화할 수도 있다.

**Zustand의 리액트 코드**

Zustand를 리액트에서 사용하기 위해서는 어디선가 store를 읽고 리렌더링을 해야 한다.

Zustand 스토어를 리액트에서 사용할 수 있도록 도와주는 함수들은 ./src/react.ts에서 관리되고 있다.

타입을 제외하고 여기에서 export하는 함수는 바로 `useStore`와 `create`다.

우선 useStore를 살펴보자.

✅ Zustand의 useStore 구현

```jsx
export function useStore<TState, StateSlice>(
	api: WithReact<StoreApi<TState>>,
	selector: (state: TState) => StateSlice = api.getState as any,
	equalityFn?: (a: StateSlice, b: StateSlice) => boolean,
) {
	const slice = useSyncExternalStoreWithSelector(
		api.subscribe,
		api.getState,
		api.getServerState || api.getState,
		selector,
		equalityFn,
	)
	useDebugValue(slice)
	return slice
}
```

- useStore 코드 또한 매우 간결하다.
- useSyncExternalStoreWithSelector를 사용해서 앞의 useStore의 subscribe, getState를 넘겨주고, 스토어에서 선택을 원하는 state를 고르는 함수인 selector를 넘겨주고 끝난다.
- useSyncExternalStoreWithSelector는 useSyncExternalStore와 완전히 동일하지만 원하는 값을 가져올 수 있는 selector와 동등 비교를 할 수 있는 equalityFn 함수를 받는다는 차이가 있다.
- 즉, 객체가 예상되는 외부 상태값에서 일부 값을 꺼내올 수 있도록 useSyncExternalStoreWithSelector를 사용했다.

useSyncExternalStore는 리액트 18에서 새롭게 만들어진 훅으로, 리액트 외부에서 관리되는 상태값을 리액트에서 사용할 수 있도록 도와준다.

또 한 가지, ./src/react.ts에서 export하는 변수는 create인데, 이는 리액트에서 사용할 수 있는 스토어를 만들어주는 변수다.

```jsx
const createImpl = <T>(createState: StateCreator<T, [], []>) => {
	const api =
		typeof createState === 'function' ? createStore(createState) : createState

	const useBoundStore: any = (selector?: any, equalityFn?: any) =>
		useStore(api, selector, equalityFn)

	Object.assign(useBoundStore, api)

	return useBoudnStore
}

const create = (<T>(createState: StateCreator<T, [], []> | undefined) =>
	createState ? createImpl(createState) : createImpl as Create

export defualt create
```

- useStore를 사용해 해당 스토어가 즉시 리액트 컴포넌트에서 사용할 수 있도록 만들어졌다.
- useBoundStore에 api를 Object.assign으로 복사했는데, 이는 useBoundStore에 api의 모든 함수를 복사해서 api도 동일하게 사용할 수 있게 제공했다.

⇒ 이러한 간결한 구조 덕분에 리액트 환경에서도 스토어를 생성하고 사용하기가 매우 쉽다.

```jsx
interface Stroe {
	count: number
	text: string
	increase: (count: number) => void
	setText: (text: string) => void
}

const store = createStore<Store>((set) => ({
	count: 0,
	text: '',
	increate: (num) => set((state) => ({ count: state.count + num })),
	setText: (text) => set({ text }),
}))

const counterSelector = ({ count, increase }: Store) => ({
	count,
	increase,
})

function Counter() {
	const { count, increase } = useStore(store, counterSelector)

	function handleClick() {
		increase(1)
	}

	return (
		<>
			<h3>{count}</h3>
			<button onClick={handleClick}>+</button>
		</>
	)
}

const inputSelector = ({ text, setText }: Store) => ({
	text,
	setText,
})

function Input() {
	const { text, setText } = useStore(store, inputSelector)

	useEffect(() => {
		console.log('Input Changed')
	})

	function handleChange(e: ChangeEvent<HTMLInputElement>) {
		setText(e.target.value)
	}

	return (
		<div>
			<input value={text} onChange={handleChange} />
		</div>
	)
}
```

- 스토어 생성 자체는 위 예제와 동일하다.
- useStore를 사용하면 이 스토어를 리액트에서 사용할 수 있게 된다.
- create를 사용해 스토어를 만들면 useStore를 굳이 사용하지 않더라도 바로 사용할 수 있다.

**간단한 사용법**

리액트에서 Zustand로 간단하게 스토어를 만들어보고, 다음과 같은 코드를 작성해보자.

```jsx
import { create } from "zustand";

const useCounterStore = create((set) => ({
  count: 1,
  inc: () => set((state) => ({ count: state.count + 1 })),
  dec: () => set((state) => ({ count: state.count - 1 })),
}));

function Counter() {
  const { count, inc, dec } = useCounterStore();
  return (
    <div class="counter">
      <span>{count}</span>
      <button onClick={inc}>up</button>
      <button onClick={dec}>down</button>
    </div>
  );
}
```

- Zustand의 create를 사용해 스토어를 만들고, 반환 값으로 이 스토어를 컴포넌트 내부에서 사용할 수 있는 훅을 받았다.
- 이 훅을 사용하면 스토어 내부에 있는 getter와 setter 모두에 접근해 사용할 수 있게 된다.
- 또한, 리액트 컴포넌트 외부에 store를 만드는 것도 가능하다. 다음 예제를 보자.

  ```jsx
  import { createStore, useStore } from "zustand";

  const counterSoter = createStore((set) => ({
    count: 1,
    inc: () => set((state) => ({ count: state.count + 1 })),
    dec: () => set((state) => ({ count: state.count - 1 })),
  }));

  function Counter() {
    const { count, inc, dec } = useStore(counterSoter);

    return (
      <div class="counter">
        <span>{count}</span>
        <button onClick={inc}>up</button>
        <button onClick={dec}>down</button>
      </div>
    );
  }
  ```

  - createStore를 사용하면 리액트와 상관없는 바닐라 스토어를 만들 수 있으며, 이 바닐라 스토어는 useStore 훅을 통해 접근해 리액트 컴포넌트 내부에서 사용할 수 있게 된다.

**특징**

- Zustand는 특별히 많은 코드를 작성 않아도 빠르게 스토어를 만들고 사용할 수 있다는 큰 장점이 있다.
- Jotail와 마찬가지로 타입스크립트 기반으로 작성돼 있기 때문에 별도로 @types를 설치하거나 임의로 작성된 d.ts에 대한 우려 없이 타입스크립트를 자연스럽게 쓸 수 있다.
- Zustand는 리덕스와 마찬가지로 미들웨어를 지원한다.
  - create의 두 번째 인수로 원하는 미들웨어를 추가하면 되는데, 스토어 데이터를 영구히 보전할 수 있는 persist, 복잡한 객체를 관리하기 쉽게 도와주는 immer, 리덕스와 함께 사용할 수 있는 리덕스 미들웨어 등 여러 가지 미들웨어를 제공해 필요한 미들웨어를 사용할 수 있게 해준다.
  - 이 미들웨어를 사용하면 상태를 sessionStoreage에 추가로 저장하는 등의 기본적인 상태 관리 작동 외에 추가적인 작업을 정의할 수도 있다.

👉 이와 같이 상태관리 해주는 라이브러리들이 많아지고 있는데 각 라이브리별로 특징을 잘 파악하고, 현재 애플리케이션의 상황과 철학에 맞는 상태 관리 라이브러리를 적절하게 선택해 사용한다면 효율적인 애플리케이션을 만드는 데 도움이 될 것이다.

또한 npm에서 제공하는 모든 라이브러리와 마찬가지로 메인테이너가 많고 다운로드가 활발하며 이슈가 관리가 잘되고 있는 라이브러리를 선택하는 것이 좋다.
