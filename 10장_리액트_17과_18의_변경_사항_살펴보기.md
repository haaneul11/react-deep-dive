# 리액트 17과 18의 변경 사항 살펴보기

리액트에 의존적인 라이브러리를 사용한다면 peerDependencies를 통해 리액트에 의존하고 있으므로 버전 없을 위해서는 이 라이브러리가 지원하는 버전에 대해 꼼꼼히 살펴봐야 한다.

# 📑 리액트 17 버전 살펴보기

리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다는 점이 특징이다.

10만 개 이상의 컴포넌트 중 호환성이 깨지는 변경 사항에 영향을 받은 것은 20개 미만으로, 리액트 16버전에서 17 버전으로 업그레이드는 큰 변화를 겪지 않고 순조롭게 업그레이드 할 수 있었다.

그럼 아래에서 17버전에서 어떤게 변경됐는지 알아보자.

## 🖌️ 리액트의 점진적인 업그레이드

리액트는 유의적 버전을 기반으로 업데이트를 거치고 있고, 지난 7년간 최초 공개된 0.3.0부터 16버전으로 오기까지 이러한 유의적 버전 전략에 맞춰 업데이트 되고 있다.

→ 즉, 새로운 주 버전이 릴리스되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구하고 있었다.

그러나 리액트 17 버전부터는 점진적인 업그레이드가 가능해진다.

리액트 17을 설치하고, 이후에 리액트 18로 업데이트하는 상황에서 18에서 제공하는 대부분의 기능을 사용할 수도 있지만 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능해진다.

즉, 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다.

→ 이러한 점진적인 업레이드를 지원하기 위한 리액트의 일부 컴포넌트 변경이 리액트 17 업데이트의 주요 변경 사항 중 하나다. 일종의 업데이트르 위한 업데이트라 볼 수 있다.

그렇다면 여기서 언급한 ‘한 애플리케이션 내에 여러 버전의 리액트가 존재하는 시나리오’는 어떤것일까?

다음 코드를 보자.

`createLegacyRoot.js`

https://github.com/wikibook/react-deep-dive-example/blob/main/chapter10/react-gradual-demo/src/legacy/createLegacyRoot.js

```jsx
import React from "react";
import ReactDOM from "react-dom";

import ThemeContext from "./shared/ThemeContext";

export default function createLegacyRoot(container) {
  return {
    // 렌더링
    render(Component, props, context) {
      ReactDOM.render(
        <ThemeContext.Provider value={context.theme}>
          <Component {...props} />
        </ThemeContext.Provider>,
        container
      );
    },
    // 이 컴포넌트의 부모 컴포넌트가 제거될 때 호출될 unmount
    unmount() {
      ReactDOM.unmountComponentAtNode(container);
    },
  };
}
```

`lazyLegacyRoot.js`

https://github.com/wikibook/react-deep-dive-example/blob/main/chapter10/react-gradual-demo/src/modern/lazyLegacyRoot.js

```jsx
import React, { useContext, useMemo, useRef, useLayoutEffect } from "react";

import ThemeContext from "./shared/ThemeContext";

// 모듈을 promiise로 불러오는 변수
const rendererModule = {
  status: "pending",
  promise: null,
  result: null,
};

// 이전 버전의 리액트 16의 루트를 가져오는 코드다.
// 일반적인 React.lazy를 쓰지 못한 이유는 컴포넌트를 불러오는 작업은 외부
// 리액트 버전에서, 렌더링하는 작업은 내부 리액트 버전에서 수행해야 하기 때문이다.
export default function lazyLegacyRoot(getLegacyComponent) {
  const componentModule = {
    status: "pending",
    promise: null,
    result: null,
  };

  return function Wrapper(props) {
    // legacy/createLegacyRoot 를 promise 로 layzy 하게 불러온다.
    const createLegacyRoot = readModule(rendererModule, () =>
      import("../legacy/createLegacyRoot")
    ).default;

    const Component = readModule(componentModule, getLegacyComponent).default;
    // 구 리액트를 렌더링할 위치
    const containerRef = useRef(null);
    // 구 리액트의 루트 컴포넌트
    const rootRef = useRef(null);

    const theme = useContext(ThemeContext);
    const context = useMemo(
      () => ({
        theme,
      }),
      [theme]
    );
    useLayoutEffect(() => {
      // 루트 컴포넌트가 없다면
      if (!rootRef.current) {
        // 루트 컴포넌트를 만든다.
        rootRef.current = createLegacyRoot(containerRef.current);
      }
      const root = rootRef.current;

      // cleanUp 시에 unmount
      return () => {
        root.unmount();
      };
    }, [createLegacyRoot]);

    useLayoutEffect(() => {
      if (rootRef.current) {
        // 루트 컴포넌트가 존재하면 적절한 props와 context로 렌더링한다.
        rootRef.current.render(Component, props, context);
      }
    }, [Component, props, context]);

    return <div style={{ display: "contents" }} ref={containerRef} />;
  };
}

function readModule(record, importStatement) {
  // promise가 없으면 아직 import 하지 못한 것이므로 import 를 실행한다.
  if (!record.promise) {
    /* eslint-disable */
    record.promise = importStatement().then(
      (value) => {
        if (record.status === "pending") {
          record.status = "fulfilled";
          record.promise = null;
          // 성공시 import 반환 값
          record.result = value;
          return value;
        }
      },
      (error) => {
        if (record.status === "pending") {
          record.status = "rejected";
          record.promise = null;
          // 실패시 에러
          record.result = error;
        }
      }
    );
  }

  // 성공 또는 실패시에 결과를 반환한다.
  if (record.status === "fulfilled" || record.status === "rejected") {
    return record.result;
  }

  throw record.promise;
}
```

`app.jsx`

https://github.com/wikibook/react-deep-dive-example/blob/main/chapter10/react-gradual-demo/src/modern/App.js

```jsx
import React, { useState, Suspense } from "react";

import AboutPage from "./AboutPage";
import ThemeContext from "./shared/ThemeContext";

export default function App() {
  const [theme, setTheme] = useState("slategrey");

  function handleToggleClick() {
    if (theme === "slategrey") {
      setTheme("hotpink");
    } else {
      setTheme("slategrey");
    }
  }

  return (
    <ThemeContext.Provider value={theme}>
      <div style={{ fontFamily: "sans-serif" }}>
        <div
          style={{
            margin: 20,
            padding: 20,
            border: "1px solid black",
            minHeight: 300,
          }}
        >
          <button onClick={handleToggleClick}>Toggle Theme Context</button>
          <br />
          <Suspense fallback={<Spinner />}>
            <AboutPage />
          </Suspense>
        </div>
      </div>
    </ThemeContext.Provider>
  );
}

function Spinner() {
  return null;
}
```

`abount.jsx`

https://github.com/wikibook/react-deep-dive-example/blob/main/chapter10/react-gradual-demo/src/modern/AboutPage.js

```jsx
import React, { useContext } from "react";

import Clock from "./shared/Clock";
import ThemeContext from "./shared/ThemeContext";
import lazyLegacyRoot from "./lazyLegacyRoot";

const Greeting = lazyLegacyRoot(() => import("../legacy/Greeting"));

export default function AboutPage() {
  const theme = useContext(ThemeContext);
  return (
    <>
      <h2>src/modern/AboutPage.js</h2>
      <h3 style={{ color: theme }}>
        This component is rendered by the outer React ({React.version}).
      </h3>
      <Clock />
      <Greeting />
      <br />
    </>
  );
}
```

![Untitled](https://github.com/user-attachments/assets/d540f220-db57-4423-8c3b-83f85d2af3b4)

→ 한 애플리케이션 내에서 여러 버전의 리액트가 존재한다.

이 예제는 크게 리액트 17로 구성된 애플리케이션과 리액트 16으로 구성된 애플리케이션으로 나눠서 살펴볼 수 있다. 리액트 17 애플리케이션은 내부에서 리액트 17을 게으르게(lazy) 불러온다.

불러오는 과정에서 리액트 16을 위한 별도의 루트 요소를 만들고, 여기에 불러온 리액트 16 모듈을 렌더링하는 구조로 구성돼 있다.

→ 그 결과 서로 렌더링하는 과정에서 버전의 불일치로 인한 에러도 발생하지 않고 하나의 웹사이트에서 두 개의 리액트가 존재하게 됐다. 그리고 이 두 개의 리액트 루트는 단 하나만 존재하는 컴포넌트와 훅을 서로 불러와서 사용할 수 있다.

→ 즉, 리액트 16과 17 버전을 모두 지원하는 컴포넌트나 훅이라면 버전이 다른 두 리액트에서도 무리없이 사용 가능하다.

→ Context도 마찬가지로 ThemeContext의 값을 리액트 16과 17이 모두 동일하게 사용하고 있으며, 이 Context가 제공하는 값을 마찬가지로 동일하게 사용할 수 있음을 알 수 있다.

이러한 점진적인 업그레이드를 채택하기 위해서라도 반드시 리액트 버전을 17까지는 업데이트할 필요가 있다.

## 🖌️ 이벤트 위임 방식의 변경

이벤트 위임 방식의 변화를 이해하려면 먼저 리액트에서 이벤트가 어떻게 추가되는지를 이해해야 한다.

다음 예제 코드를 보자.

```jsx
import { useEffect, useRef } from "react";

export default function Button() {
  const buttonRef = (uesRef < HTMLButtonElement) | (null > null);

  useEffect(() => {
    if (buttonRef.current) {
      buttonRef.current.onClick = function click() {
        alert("안녕하세요!");
      };
    }
  }, []);

  function 안녕하세요() {
    alert("안녕하세요!");
  }

  return (
    <>
      <button onClick={안녕하세요}>리액트 버튼</button>
      <button ref={buttonRef}>그냥 버튼</button>
    </>
  );
}
```

먼저 ‘리액트 버튼’은 일반적으로 리액트 애플리케이션에서 DOM에 이벤트를 추가하는 방식으로 onClick 이벤트를 추가했다. 반면, ‘그냥 버튼’의 이벤트는 직접 DOM을 참조해서 가져온 다음, DOM의 onclick에 직접 함수를 추가하는 고전적인 이벤트 핸들러 추가 방식을 사용했다.

이 두 방법이 실제 웹에서 어떻게 다른지 살펴보자.

아래 사진은 일반적인 onclick 방식으로 이벤트 핸들러를 추가한 모습이다.

![Untitled 1](https://github.com/user-attachments/assets/2eeb60ca-984f-43a2-8d0c-2259e5f13e1d)

→ ‘그냥 버튼’은 해당 버튼의 이벤트 리스너에 click으로 추가되어 있는 것을 볼 수 있다. 해당 핸들러를 클릭해 보면 앞에서 작성한 click 함수를 가리키고 있다.

그럼 리액트로 부착한 이벤트는 어떨까? 아래는 리액트에서 이벤트를 추가한 button의 onClick 핸들러를 확인한 모습이다.

![Untitled 2](https://github.com/user-attachments/assets/c4eb03f7-ff0b-4572-8944-516bff242112)

<button>의 onClick 이벤트에 noop이라는 핸들러가 추가되어 있는 것을 볼 수 있다.

![Untitled 3](https://github.com/user-attachments/assets/684bec01-411f-4370-a995-fc0e04bdbf02)

→ 리액트 방식으로 이벤트 핸들러를 추가한 모습으로, 앞에 방식과 다르게 추가한 이벤트가 직접적으로 보이지 않음을 알 수 있다.

해당 버튼의 click에는 noop이라고 하는 함수가 달려 있고, 이 noop은 문자 그대로(no opertaion) 아무런 일도 하지 않는 것을 볼 수 있다. 그러나 두 버튼 모두 동일하게 작동한다.

그렇다면 리액트에서는 이벤트를 어떻게 처리할까?

리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다. 이를 이벤트 위임이라고 한다. 이벤트 위임을 이해하려면 이벤트가 어떤 단계로 구성되어 있는지 먼저 알아야 한다.

1. 캡처(capture) : 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미한다.
2. 타깃(target) : 이벤트 핸들러가 타깃 노드에 도달하는 단계다. 이 단계에서 이벤트가 호출된다.
3. 버블링(bubbling) : 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다.

→ 이벤트 위임이란 이러한 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다.

다음 코드를 보자.

```html
<ul>
  <li />
  <li />
  <li />
  <li />
  <!-- ... -->
</ul>
```

- 만약 모든 li 요소에 이벤트가 필요하다면 이 li에 이벤트를 다 추가할 수도 있지만 ul에만 추가해서 이벤트를 위임한다면 더욱 많은 이점을 얻을 수 있다.
- ul의 자식에 li가 추가 또는 삭제되더라도 이벤트 핸들러도 똑같은 추가 수정할 필요가 없고, 이벤트 추가를 한 번만 하면 되므로 좀 더 효율적으로 관리할 수 있게 된다.

리액트는 이벤트 위임을 적극적으로 사용하여, 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀 더 효율적으로 관리한다.

위 예제에서 루트는 div#\_\_next이고, 해당 엘리먼트에 이벤트가 달려 있는 것을 볼 수 있다.

그러나 이러한 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행되고 있었다. 다음과 같은 리액트 16 코드를 보자.

```jsx
import React from "react";
import ReactDOM from "react-dom";

export default function App() {
  function 안녕하세요() {
    alert("안녕하세요!");
  }

  return <button onClick={안녕하세요}>리액트 버튼</button>;
}

ReactDOM.render(<App />, document.getElementById("root"));
```

![Untitled 4](https://github.com/user-attachments/assets/1af8f49b-b0e8-405d-8d6f-b15d44b47645)

→ 리액트의 이벤트가 16 버전에서는 document에 부착된 것을 볼 수 있다.

그런데 리액트 17부터는 이러한 이벤트 위임이 모두 docuemnt가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었다.

![Untitled 5](https://github.com/user-attachments/assets/75d9a242-1882-476c-af38-b6d022d748dd)

→ 리액트 17 버전에서는 리액트의 이벤트가 루트인 div#root에 부착된 것을 볼 수 있다.

→ 그 이유는 점진적인 업그레이드 지원때문이다. 그리고 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재되어 있는 경우 혼란을 방지하기 위해서이다.

⁉️ 만약 점진적인 업그레이드 지원이 활성화 됐고, 그 덕분에 리액트 버전이 한 서비스에서 공존한다면

기존 리액트 16의 방식대로 모든 이벤트가 document에 달려 있으면 어떻게 될까?

```jsx
import React from "react"; // 16.14
import ReactDOM from "react-dom"; // 16.14

function React1614() {
  function App() {
    function 안녕하세요() {
      alert("안녕하세요! 16.14");
    }
    return <button onClick={안녕하세요}>리액트 버튼</button>;
  }

  return ReactDOM.render(<App />, document.getElementById("React-16-14"));
}

import React from "react"; // 16.8
import ReactDOM from "react-dom"; // 16.8

function React168() {
  function App() {
    function 안녕하세요() {
      alert("안녕하세요! 16.8");
    }
    return <button onClick={안녕하세요}>리액트 버튼</button>;
  }
  return ReactDOM.render(<App />, document.getElementById("React-16-8"));
}
```

위 코드는 다음과 같이 렌더링될 것이다.

```jsx
<html>
  <body>
    <div id="React-16-14">
      <div id="React-16-8"></div>
    </div>
  </body>
</html>
```

리액트 16의 이벤트 위임의 원리에 따라 모든 이벤트는 document에 부착된다. 만약 이 상황에서 React168 컴포넌트가 이벤트 전파를 막는 e.stopPropagation을 실행하면 어떻게 될까? 이미 모든 이벤트는 document로 올라가 있는 상태이기 때문에 stopPropagation을 실행한다 하더라도 이미 모든 이벤트는 document에 있으므로 document의 이벤트 전파는 막을 수 없게 된다.

따라서 e.stopPropagation() 실행이 무색하게 바깥에 있는 React1614에도 이 이벤트를 전달받게 될 것이다.

이처럼 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해 이벤트 위임의 대상을 document에서 컴포넌트의 최상위로 변경했다.

이렇게 수정하게 되면 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되므로 이벤트 버블링으로 인한 혼선을 방지할 수 있다.

이러한 문제는 리액트끼리만 발생하는 것은 아니고 한 애플리케이션에서 jQeury 같은 다른 라이브러리와 리액트 16 등이 혼재되어 있는 상황인 경우에도 이와 동일한 문제가 충분히 발생할 수 있다.

리액트 16 버전에서 document와 리액트가 렌더링되는 루트 컴포넌트 사이에서 이벤트를 막는 코드를 추가하면 리액트의 모든 핸들러가 작동하지 않도록 막을 수 있다.

```jsx
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1, shrink-to-fit=no"
		/>
	</head>
	<body>
		<!-- 리액트 컴포넌트 루트 -->
		<div id="main">
			<div id="root"></div>
		</div>
		<script>
			// 여기에 클릭 이벤트로 이벤트 전파를 막아버리면 리액트의
			// 클릭 이벤트 핸들러가 모두 막힌다.
			document.getElementById('main').addEventListener(
				'click',
				function (e) {
					e.stopPropagation()
				},
				false,
			)
		</script>
	</body>
</html>
```

→ 하지만 이러한 작동 방식 또한 이벤트 위임 방식이 변경되면서 사라지게 됐다.

아래 사진은 리액트 17에서의 이벤트 위임 방식 변경을 도식화한 그림이다. 리액트의 이벤트는 이제 document가 아닌 리액트 최상단 요소에 추가된다.

![Untitled 6](https://github.com/user-attachments/assets/07c04d0f-94a4-4997-919f-51707107ab86)

이러한 변경으로 인해 코드에 document.addEventListener를 활용해 리액트의 모든 이벤트를 document에서 확인하는 코드가 있다면 이벤트가 전파되지 않는 경우도 존재할 수 있으므로 꼭 확인해 봐야 한다.

다음 예제를 보자.

```jsx
import React, { MouseEvent, useEffect } from "react";
import ReactDOM from "react-dom";

export default function App() {
  useEffect(() => {
    document.addEventListener("click", (e) => {
      console.log("이벤트가 document까지 올라옴");
    });
  }, []);

  function 안녕하세요(e: MouseEvent<HTMLButtonElement>) {
    e.stopPropagation();
    alert("안녕하세요!");
  }

  return <button onClick={안녕하세요}>리액트 버튼</button>;
}

ReactDOM.render(<App />, docuemnt.getElementById("root"));
```

→ 이 코드는 리액트 16과 17에서 다르게 작동한다.

→ 리액트 16에서는 모든 이벤트가 document에 달려 있으므로 stopPropagation의 의미가 없지만 리액트 17의 경우네는 컴포넌트 루트에 달려 있으므로 document에 부탁한 console 이벤트를 볼 수 없을 것이다.

→ 리액트의 이러한 이벤트 작동 방식을 기반으로 작성한 코드가 있다면 리액트 17을 적용하면서 함께 반드시 수정해야 한다.

## 🖌️ import React from ‘react’가 더 이상 필요 없다: 새로운 JSX transform

JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요하다.

일반적으로 create-react-app을 활용해서 개발하면 이러한 작업을 따로 처리한 경험은 거의 없겠지만 대부분의 경우에는 이 변환 작업이 개발자에게 보이지 않는 리액트 단에서 이뤄지고 있었다.

16 버전까지는 이러한 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라도 `import React from ‘react’`가 필요했고, 이 코드가 없다면 에러가 발생했다.

그러나 ❣️ 리액트 17부터 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐다.

→ 이 새로운 변환 식은 import React가 필요 없다는 장점 외에도, 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있고, 컴포넌트 작성을 더욱 간결하게 해준다.

먼저 구 버전에서 JSX가 어떻게 변화되는지 살펴보자.

```jsx
const Component = (
  <div>
    <span>hello world</span>
  </div>
);

// 리액트 16에서는 이렇게 변환된다.
var Component = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello world")
);
```

변환 결과를 보면 왜 import React from ‘react’ 구문이 필요했는지 알 수 있다.

JSX 코드를 변경은 해주지만 React.createElement를 수행할 때 필요한 import React from ‘react’까지 추가해주지는 않기 때문이다.

그리고 17 버전에서는 앞의 코드가 다음과 같이 변환된다.

```jsx
"use strict";

var _jsxRuntime = require("react/jsx-runtime");

var Component = (0, _jsxRuntime.jsx)("div", {
  children: (0, _jsxRuntime.jsx)("span", {
    children: "hello world",
  }),
});
```

React.createElement가 사라진 것 이외에 require() 구문이 추가되었는데,

이제 JSX를 변환할 때 필요한 모듈인 react/jsx-runtime을 불러오는 require 구문도 같이 추가되므로 import React from ‘react’를 작성하지 않아도 된다.

→ 기존 코드에서 코드 import React를 삭제하지 않고 둬도 상관없지만 번들링 사이즈를 조금이라도 줄이고 싶다면 react-codemod를 다음 명령어를 사용해 모두 삭제할 수 있다.

```powershell
npx react-codemod update-react-imports
```

❣️나중에 import React가 추가되는 혹시 모를 상황을 방지하고 싶다면 8장에 ‘ESLint를 활용한 정적 코드 분석’에서 이야기 한 ESLint를 활용한 정적 분석 방식을 사용해보자.

❣️ jsx를 작성하는 코드가 간결해지는 것 외에 실제로 어떤 이점이 있을까?

1. react/jsx-runtime을 React.createElement와 비교해서 내부 소스코드를 직접 살펴보면 두 함수 모두 ReactElement를 반환하지만 리액트 내부 코드를 살펴보면 react/jsx-runtime의 jsx쪽이 훨씬 더 내부 로직이 간결하다.
2. import React 구문이 사라져서 번들 사이즈도 조금 줄어들었다.

→ **즉! 특별한 이유가 없다면 import React를 지우고, tsconfig.json의 jsx를 react-jsx 등으로 변경하여 아에서 설명한 이점을 모두 누리자!**

## 🖌️ 그 밖의 주요 변경 사항

### 이벤트 풀링 제거

과거 리액트 16에서는 이른바 이벤트 풀링이라 불리는 기능이 있었다.

리액트에는 이벤트를 처리하기 위한 SyntheticEvent라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체다.

리액트는 이렇게 브라우저 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때마다 이 이벤트를 새로 만들어야 했고, 그 과정에서 항상 새로 이벤트를 만들 때마다 메모리 할당 작업이 일어날 수밖에 없다.

또한 메모리 누수를 방지하기 위해 이렇게 만든 이벤트를 주기적으로 해제해야 하는 번거로움도 있다.

→ 여기서 `이벤트 풀`링이란 SyntheticEvent 풀을 만등러서 이벤트가 발생할 때마다 가져오는 것을 의미한다.

아래 사진은 이벤트 풀링의 원리이다.

![Untitled 7](https://github.com/user-attachments/assets/2e4f0682-5e84-41de-817e-609fe3ccaecf)

즉, 이벤트 풀링 시스템에서는 다음과 같이 이벤트가 발생한다.

1. 이벤트 핸들러가 이벤트를 발생시킨다.
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다.
4. 유저가 지정한 이벤트 리스너가 실행된다.
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

언뜻 보기에는 이벤트 풀에 있는 합성 이벤트를 반복적으로 사용할 수 있어서 효과적으로 보이지만 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 초기화하는(null로 변경하는) 방식은 분명 사용하는 쪽에서는 직관적이지 않았다.

다음 코드를 보자.

```jsx
export default function App() {
  const [value, setValue] = useState("");
  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setValue(() => {
      return e.target.value;
    });
  }

  return <input onChange={handleChange} value={value} />;
}
```

이 코드는 다음과 같은 에러를 발생시킨다.

> // Cannot read properties of null (reading ‘value’)

// Warning: This systhetic event is reused for performance reasons. If you’re seeing this, you’re accessing the property `target` on a released/nullified synthetic synthetic event. This is set no null. If you must keep the original synthetic event around, use event.persist(). See [https://fb.me/re-act-event-pooling](https://fb.me/re-act-event-pooling) for more information.

>

→ 이 에러는 리액트 16 이하 버전에서는 이벤트 풀링 방식을 통해 서로 다른 이벤트 간에 이벤트 객체를 재사용하고, 그리고 이 재사용하는 사이에 모든 이벤트 필드를 null로 변경하기 때문에 발생했다.

→ 좀 더 쉽게 표현하자면 한번 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화된다. 따라서 비동기 코드 내부에서 SyntheticEvent인 e에 접근하면 이미 사용되고 초기화된 이후이기 때문에 null만 얻게 된다.

비동기 코드 내부에서 이 합성 이벤트 e에 접근하기 위해서는 추가적인 작업인 e.persist() 같은 처리가 필요했다.

```jsx
export default function App() {
  const [value, setValue] = useState("");
  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    e.persist();
    setValue(() => {
      return e.targetvalue;
    });
  }

  return <input onChange={handleChange} value={value} />;
}
```

비동키 코드로 이벤트 핸들러에 접근하기 위해서는 이러한 방식으로 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 그리고 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안 된다는 점 때문에 이러한 이벤트 풀링 개념이 삭제됐다.

그리고 모던 브라우저에서는 이러한 이벤트 처리에 대한 성능이 많이 개선됐기 때문에 이러한 처리는 더욱 의미가 퇴색하게 되었다.

따라서 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 코딩할 수 있게 됐다.

### useEffect 클린업 함수의 비동기 실행

먼저 리액트의 useEffect에 있는 클린업 함수는 **리액트 16 버전까지는** 동기적으로 처리됐다. 동기적으로 실행되기 때문에 이 클린업 함수가 완료되기 전까지는 다른 작업을 방해하므로 불필요한 성능 저하로 이어지는 문제가 존재했다.

**그러나 리액트 17 버전부터는** 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다. 조금 더 정확히 이야기하자면 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다.

즉, 화면이 업데이트가 완전히 끝난 이후에 실행되도록 바뀌었으며, 이로써 약간의 성능적인 이점을 볼 수 있게 됐다.

다음 예제를 보자.

```jsx
import React, { useState, Profiler, useEffect, useCallback } from 'react'

export default function App() {
	const callback = useCallback(
		(id, phase, actualDuration, baseDuration, startTime, commitTime) => {
			console.group(phase)
			console.table({ id, phase, commitTime })
			console.groupEnd()
		},
		[],
	)

	return (
		<Profiler id="React16" onRender={callback}>
			<Button>
				<Users />
			</Button>
		</Profiler>
	)
}

function Button({ children }) {
	const [toogle, setToogle] = useState(false)

	const handleClick = useCallback(() => setToggle((prev) => !prev), [])

	return (
		<seciont>
			<button onClick={handleClick}>{toggle ? 'show' : 'hide'}</button>
			{toggle && children}
		</section>
	)
}

function Users() {
	const [users, setUsers] = useState(null)

	useEffect(() => {
		const abortController = new AbortController()
		const signal = abortController.signal

		fetch('https://jsonplaceholder.typicode.com/users', { signal: signal })
			.then((results) => results.json())
			.then((data) => {
				setUsers(data)
			})
		return () => {
			console.log('claenup!')
			abortController.abort()
		}
	}, [])

	return <p>{users === null ? 'Loading' : JSON.stringify(users)}</p>
}
```

이 코드는 버튼을 클릭하면 API를 호출해 유저 목록을 불러오고 클린업 함수로 해당 호출을 abort하는 useEffect를 가진 컴포넌트로 구성되어 있다.

여기서 Profiler를 보면, 이 API는 리액트 애플리케이션의 성능 최적화를 측정하기 위해 사용된다.

Profiler를 활용해 클린업 함수의 변경으로 인한 리액트 커밋 단계가 얼마나 효율적으로 변경됐는지 살펴보자.

- 리액트 16에서 확인한 모습

![Untitled 8](https://github.com/user-attachments/assets/3ca045ba-7af5-42cb-90f0-ef16d80dd15f)

→ 리액트 16에서는 cleanup! 콘솔의 호출이 업데이트 이전에 발생하는 것을 볼 수 있다.

- 리액트 17에서 확인한 모습

![Untitled 9](https://github.com/user-attachments/assets/7994e28b-489a-4ac0-a00b-79c5ed6e8274)

→ 동일한 코드를 기준으로 리액트 16에서는 클린업 함수가 ‘update’(Profiler에서 update는 리렌더링을 의미한다) 이전에 실했됐지만 리액트 17에서는 리렌더링이 일어난 뒤에 실행되어 화면에 업데이트가 반영되는 시간인 commitTime이 조금이나마 빨라진 것을 볼 수 있다.

### 컴포넌트의 undefined 반환에 대한 일관적인 처리

리액트 16과 17 버전은 컴포넌트 내부에 undefined를 반환하면 오류가 발생한다.

→ 의도치 않게 잘못된 반환으로 인한 실수를 방지하기 위해서

```jsx
function Button() {
  return <>버튼</>;
}

export default function App() {
  // 반환되는 게 없으므로 undefined가 반환됨
  <Button />;
}
```

```jsx
//App(...): Noting was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.
```

하지만 리액트 16에서 farwardRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러가 발생하지 않는 문제가 있었다. 👇

```jsx
const ForwardedButton = forwardRef(() => {
  <Button />;
});

const MemoizedButton = memo(() => {
  <Button />;
});

export default function App() {
  // 에러도 안 나지만 아무것도 나타나지 않음
  return (
    <>
      <ForwardedButton />
      <MemoizedButton />
    </>
  );
}
```

❣️ 그러나 리액트 17부터는 에러가 정상적으로 발생한다. 참고로 리액트 18부터는 undefined를 반환해도 에러가 발생하지 않는다.

✅ 리액트 17 버전의 변경 사항을 좀 더 자세히 알고 싶다면 아래 링크에서 확인해보자.

- https://ko.legacy.reactjs.org/blog/2020/10/20/react-v17.html
- https://ko.legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html
- https://ko.legacy.reactjs.org/blog/2020/08/10/react-v17-rc.html
- https://github.com/facebook/react/releases/tag/v17.0.0

# 📑 리액트 18 버전 살펴보기

## 🖌️ 새로 추가된 훅 살펴보기

### useId

useId는 컴포넌트별로 유니크한 값을 생성하는 새로운 훅이다.

사실 컴포넌트 내부에서 사용할 수 있는 유니크한 값을 생성하는 것은 생각보다 쉽지 않은 일이다. 하나의 컴포넌트가 여러 군데에서 재사용되는 경우도 고려해야 하며, 리액트 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 겹치지 않고 다 달라야 한다는 제약도 있다.

또한 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때도 서버와 클라이언트에서 동일한 값을 가져야 에러가 발생하지 않으므로 이러한 점도 고려해야 한다.

다음 컴포넌트가 서버 사이드에서 렌더링 되어 클라이언트에 제공된다고 해보자.

```jsx
export default function UniqueComponent() {
  return <div>{Math.random()}</div>;
}
```

이 컴포넌트를 서버 사이드에서 렌더링하면 다음과 같은 에러가 발생한다.

```jsx
// Text content did not match. Server: "0.3238816490074648" Client: "0.9370162517955456"
```

→ 서버에서 렌더링했을 때의 Math.random() 값과 클라이언트에서 해당 결과물을 받고 이벤트를 입히기 위한 하이드레이션을 했을 때의 Math.random() 값이 다르기 때문에 에러가 발생한다.

→ 따라서 서비스에서 컴포넌트별로 고유한 값을 사용해야 한다면 반드시 하이드레이션을 고려해야 해서 리액트 17까지는 굉장히 까다로운 작업이었다.

→ useId를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 냅의 고유한 값을 생성할 수 있게 된다. 다음 예제에서 살펴보자.

```jsx
import { useId } from "react";

function Child() {
  const id = useId();
  return <div>child: {id}</div>;
}

function SubChild() {
  const id = useId();

  return (
    <div>
      Sub Child:{id}
      <Child />
    </div>
  );
}

export default function Random() {
  const id = useId();
  return (
    <>
      <div>Home: {id}</div>
      <SubChild />
      <SubChild />
      <Child />
      <Child />
      <Child />
    </>
  );
}
```

이 컴포넌트를 서버 사이드에서 렌더링하면 다음과 같은 HTML을 확인할 수 있다.

![Untitled 10](https://github.com/user-attachments/assets/1d4bcdf9-2b68-4b76-a649-1310e22ee99c)

- 같은 컴포넌트임에도 서로 인스턴스가 다르면 다른 랜덤한 값을 만들어 내며, 이 값들이 모두 유니크한 것을 볼 수 있다. 또한 서버 사이드와 클라이언트 간에 동일한 값이 생성되어 하이드레이션 이슈도 발생하지 않는 것을 알 수 있다.
- 이 useId가 생성하는 값은 :로 감싸져 있는데, 이는 CSS 선택자나 querySelector에서 작동하지 않도록 하기 위한 의도적인 결과다.

리액트에서 useID를 활용한 아이디 생성 알고리즘에 대해 간단한게 이야기해보자면

id는 기본적으로 현재 트리에서의 자신의 위치를 나타내는 32글자의 이진 문자열로 이뤄져 있으며,

왼쪽 5자리가 부모의 트리를 나타낸다.

앞 글자가 R이면 서버에서 생성된 값이며, r이면 클라이언트에서 생성된 값이다.

👉 자세한 알고리즘은 리액트 깃허브 저장소에서 확인가능

![Untitled 11](https://github.com/user-attachments/assets/f2643758-3b27-4938-848a-386c70f461bc)

### useTransition

useTransition 혹은 UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅이다.

이를 활용하면 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있으며, 사용자에게 조금 더 나은 사용자 경험을 제공할 수 있다.

다음 예제 코드를 보자.

```jsx
// App.tsx
type Tab = "about" | "posts" | "contact";

export default function App() {
  const [tab, setTab] = useState < Tab > "about";

  function selectTab(nextTab: Tab) {
    setTab(nextTab);
  }

  return (
    <>
      <TabButton isActive={tab === "about"} onClick={() => selectTab("about")}>
        Home
      </TabButton>
      <TabButton isActive={tab === "posts"} onClick={() => selectTab("posts")}>
        Posts (slow)
      </TabButton>
      <TabButton
        isActive={tab === "contact"}
        onClick={() => selectTab("contact")}
      >
        Contact
      </TabButton>
      <hr />

      {/* 일반적인 컴포넌트 */}
      {tab === "about" && <About />}
      {/* 매우 무거운 연산이 포함된 컴포넌트 */}
      {tab === "posts" && <Posts />}
      {/* 일반적인 컴포넌트 */}
      {tab === "contact" && <Contact />}
    </>
  );
}
```

```jsx
// PostTab.tsx
import { memo } from "react";

const PostTab = memo(function PostsTab() {
  const items = Array.from({ length: 1500 }).map((_, i) => (
    <SlowPost key={i} index={i} />
  ));

  return <ul className="items">{items}</ul>;
});

function SlowPost({ index }: { index: number }) {
  let startTime = performance.now();
  // 렌더링이 느려지는 상황을 가정하기 위해 느린 코드를 추가했다.
  while (performance.now() - startTime < 1) {
    // 아무것도 하지 않음
  }
  return <li className="item">Post #{index + 1}</li>;
}

export default PostsTab;
```

이 코드는 세 개의 탭 중 하나의 선택된 탭을 보여주는 코드다.

탭의 상태는 useState로 제어, 이 state에 필요한 컴포넌트를 노출.

`<Posta />`

- 내부에 굉장히 느린 작업이 포함되어 있어 렌더링하는 데 많은 시간이 소요된다.
- 그래서 코드를 실행한 후, Post를 선택한 후에 바로 Contact를 선택해 해본 결과
  <Post />를 렌더링하기 위해 잠시 브라우저가 작동을 멈춘 후, 렌더링이 끝난 이후에야 비로소 <Contact />를 렌더링하는 것을 확인할 수 있다.

이는 setTab이라는 상태 업데이트로 인해 Post를 렌더링하고, 이 Post 렌더링 작업이 상당한 시간이 소요되어 UI 렌더링을 가로막기 때문이다. 이러한 시나리오에서는 사실 사용자가 <Post /> 탭은 실수로 누른 것으로 볼 수 있기 때문에 지금까지의 <Post /> 렌더링을 중단하고 바로 <Contact />를 보여주는 것이 더 적절하였겟지만 이전까지는 리액트의 렌더링은 한번 시작하면 멈출 수 없는 작업이었기 때문에 이러한 문제가 발생했다.

이처럼 상태 변경으로 인해 무거운 작업이 발생하고, 이로 인해 렌더링이 가로막힐 여지가 있는 경우 `useTransaction`을 사용하면 이러한 문제를 해결할 수 있다.

```jsx
import { useState, useTransition } from "react";
// ...

export default function TabContainer() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState < Tab > "about";

  function selectTab(nextTab: Tab) {
    startTransition(() => {
      setTab(nextTab);
    });
  }

  return (
    <>
      {/* ... */}
      {isPending ? (
        "로딩 중"
      ) : (
        <>
          {tab === "about" && <About />}
          {tab === "posts" && <Posts />}
          {tab === "contact" && <Contact />}
        </>
      )}
    </>
  );
}
```

- useTransition은 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환한다.
- isPending은 상태 업데이트가 진행 중인지를 확인할 수 있는 boolean이고, startTransition은 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다.
- 여기서는 () ⇒ {setTab(nextTab)}을 인수로 받았지만 경우에 따라서는 여러 개의 setter를 넣어줄 수도 있다.

→ 위 코드를 실행해보면 setTab을 useTransition을 통해 처리하면 이전과 다르게 탭을 아무리 선택해도 렌더링이 블로킹되지 않는 것을 알 수 있다.

즉, <Posts />를 클릭하면 ‘로딩 중’이라는 메시지와 함께 린더렝이 시작되며, 이후에 바로 <Contact /> 탭으로 이동하면 그 즉시 <Posts /> 렌더링이 중단되고 <Contact /> 렌더링을 시작해 빠르게 완료한다.

즉, 렌더링이 시간이 소요되는 <Posts />는 동기 방식으로 브라우저의 다른 작업을 방해하면서 즉각 렌더링을 시작하지 않고, 마치 async와 await처럼 비동기로 렌더링한다. 그리고 이 <Posts /> 컴포넌트 렌더링 와중에 다른 상태 업데이트로 전환되면 <Posts /> 렌더링이 취소될 수도, 혹은 완성될 때까지 기다리지만 다른 렌더링을 가로막지 않을 수 있다.

`useTransition`은 리액트 18의 변경 사항의 핵심 중 하나인 `‘동시성(concurrency)’`을 다룰 수 있는 새로운 훅이다.

→ 과거 리액트의 모든 렌더링은 동기적으로 작동해 느린 렌더링 작업이 있을 경우 애플리케이션 전체적으로 영향을 끼쳤지만 useTransition과 같은 동시성을 지원하는 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 된다.

이는 앱의 성능을 향상시킬 뿐만 아니라 사용자에게 좀 더 자연스러운 서비스를 경험할 수 있게 해준다.

useTransition은 이름에서도 알 수 있듯 컴포넌트에서만 사용 가능한 훅이다. 훅을 사용할 수 없는 상황이라면 단순히 startTransition을 바로 import할 수도 있다.

```jsx
import { startTransition } from "react";
//....
```

이때 useTransition을 사용할 때 주의할 점이 있다.

- startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다. 만약 props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶다면 뒤에 나오는 useDefferedValue를 사용하면 된다.
- startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다. 예를 들어, 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
- startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. 만약 이 안에 setTimeout과 같은 비동기 함수를 넣으면 제대로 작동하지 않게 된다. 이는 startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나기 때문이다.

### useDeferredValue

`useDeferredValue`는 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다. 일반적으로 개발자들 사이에서 널리 사용되고 있는, 특정 시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는 디바운스와 비슷하지만 디바운스 대비 useDefferedValue만이 가진 장점이 몇 가지있다.

먼저 디바운스는 고정된 지연 시간을 필요로 하지만 useDefferedValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 이 useDeferredValue로 지연된 렌더링을 수행한다.

그러므로 이 지연된 렌더링은 중단할 수도 있으며, 사용자의 인터랙션을 차단하지도 않는다.

다음 예제를 보자.

```jsx
export default function Input() {
  const [text, setText] = useState("");
  const deferredText = useDeferredValue(text);

  const list = useMemo(() => {
    const arr = Array.from({ length: deferredText.length }).map(
      (_) => deferredText
    );
    return (
      <ul>
        {arr.map((str, index) => (
          <li key={index}>{str}</li>
        ))}
      </ul>
    );
  }, [deferredText]);

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setText(e.target.value);
  }
  return (
    <>
      <input value={text} onChange={handleChange} />
      {list}
    </>
  );
}
```

- list를 생성하는 기준을 text가 아닌 deferredText로 설정함으로써 잦은 변경이 있는 text를 먼저 업데이트해 렌더링하고, 이후 여유가 있을 때 지연된 deferredText를 활용해 list를 새로 생성하게 된다. list에 있는 작업이 더 무겁고 오래 걸릴수록 useDeferredValue를 사용하는 이점을 더욱 누릴 수 있을 것이다.

⁉️ 그럼 useDeferredValue와 useTransition은 어떤 차이점이 있을까?

useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state 값 자체만을 감싸서 사용하는 것을 볼 수 있다.

방식만 다를 뿐, 지연된 렌더링을 한다는 점에서는 모두 동일한 역할을 하는 것을 알 수 있다. 따라서 두 가지 방법 중 상황에 맞는 방법을 선택하면 된다.

- 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트할 수 있는 코드에 접근할 수 있다면 `useTransition`을 사용하는 것이 좋다.
- 컴포넌트의 props와 같이 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 상황이라면 `useDeferredValue`를 사용하는 것이 타당하다.

→ 렌더링을 지연시켜도 되는 작업에 대해 상황에 맞게 둘 중 하나를 선택하면 된다.

### useSyncExternalStroe

`useSyncExternalStore`는 일반적인 애플리케이션 코드를 작성할 때는 사용할 일이 별로 없는 훅이다. 이 훅의 기원은 알려면 리액트 17까지 존재했던 `useSubscription`에 대해 알아야 한다.

→ `useSubscription`의 구현이 리액트 18에 이르러서 `useSyncExternalStore`로 대체되었다.

이 훅이 어떤 일을 하는지 살펴보기에 앞서 `테어링(tearing)` 현상에 대해 알아보자.

리액트에서는 테어링을 하나의 state 값이 있음에도 서로 다른 값(보통 state나 props의 이전과 이후)을 기준으로 렌더링되는 현상을 말한다.

리액트 17에서는 이러한 현상이 일어날 여지가 없었지만 리액트 18에서는 앞서 useTransition, useDeferredValue의 훅처럼 렌더링을 일시 중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 동시성 이슈가 발생할 수 있다.

예를 들어, startTransition으로 렌더링을 일시 중지할 경우 일시 중지 과정에서 값이 업데이트되면 동일한 하나의 변수(데이터)에 대해서 서로 다른 컴포넌트 형태가 나타날 수 있다.

다음 그림을 보자.

![Untitled 12](https://github.com/user-attachments/assets/dd6b5bac-bf62-4e68-a2e5-9c454f9977ad)

→ 리액트 18의 동시성 렌더링으로 인해 발생할 수 있는 테어링 문제를 나타낸 그림이다.

과정은 다음과 같다.

1. 첫 번째 컴포넌트에서는 외부 데이터 스토어의 값이 파란색이었으므로 파란색을 렌더링했다.
2. 그리고 나머지 컴포넌트들도 파란색으로 렌더링을 준비하고 있었다.
3. 그러다 갑자기 외부 데이터 스토어의 값이 빨간색으로 변경됐다.
4. 나머지 컴포넌트들은 렌더링 도중에 바뀐 색을 확인해 빨간색으로 렌더링했다.
5. 결과적으로 같은 데이터 소스를 바라보고 있음에도 컴포넌트의 색상이 달라지는 테어링 현상이 발생했다.

과거 리액트에서는 중간에 데이터 업데이트가 일어나는 것과 상관없이 동기적으로 렌더링이 한 번에 발생해서 문제가 없었지만 리액트 18에서부터는 리액트가 렌더링을 앞선 훅의 예제처럼 중지했다가 다시 실행하는 등 ‘양보’하는 것이 가능해졌기 때문에 이러한 문제가 발생할 가능성이 있다.

리액트에서 관리하는 state라면 useTransition이나 useDefferedValue 예제와 같이 내부적으로 이러한 문제를 해결하기 위한 처리를 해뒀지만 리액트에서 관리할 수 없는 외부 데이터 소스에서라면 해결이 어려울 수 있다.

→ 리액트가 관리할 수 없는 외부 데이터 소스란? 리액트의 클로저 범위 밖에 있는, 관리 범위 밖에 있는 값들을 말한다.

ex) 글로벌 변수, document.body, window.innerWith, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리 등

즉, useState나 useReducer가 아닌 모든 것들이 바로 외부 데이터 소스다.

외부 데이터 소스에 리액트에서 추구하는 동시성 처리가 추가되어 있지 않으면 테어링 현상이 발생할 수 있다.

하지만 이러한 문제를 해결하기 위한 훅이 바로 `useSyncExternalStore`이다.

```jsx
import { useSyncExternalStore } from "react";

// useSyncExternalStore(
//   subscribe: (callback) => Unsubscribe
//   getSnapshot: () => State
// ) => State
```

- 첫 번째 인수는 subscribe로, 콜백 함수를 받아 스토어에 등록하는 용도로 사용된다. 스토어에 있는 값이 변경되면 이 콜백이 호출돼야 한다. 그리고 useSyncExternalStore는 이 훅을 사용하는 컴포넌트를 리렌더링한다.
- 두 번째 인수는 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수다. 이 함수는 스토어가 변경되지 않았다면 매번 함수를 호출할 때마다 동일한 값을 반환해야 한다. 스토어에서 값이 변경됐다면 이 값을 이전 값과 Object.is로 비교해 정말로 값이 변경됐다면 컴포넌트를 리렌더링한다.
- 마지막 인수는 옵셔널 값으로, 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용된다. 서버 사이드에서 렌더링되는 훅이라면 반드시 이 값을 넘겨줘야 하며, 클라이언트의 값과 불일치가 발생할 경우 오류가 발생한다.

→ useSyncExternalStore 어딘가에 콜백을 등록하고, 이 콜백이 호출될 때마다 렌더링을 트리거하는 장치가 마련되어 있다는 것을 알 수 있다.

→ 렌더링의 원리에 대해 알아봤던 것 이외에도 useSyncExternalStore 훅의 외부 스토어 데이터 변경 또한 리렌더링을 발생시킬 수 있다는 것을 알 수 있다.

실제로 이 훅을 사용하는 예를 아래 예제를 통해 보자.

```jsx
import { useSyncExternalStore } from "react";

function subscribe(callaback: (this: Window, ev: UIEvent) => void) {
  window.addEventListener("resize", callback);
  return () => {
    window.removeEventListener("resize", callback);
  };
}

export default function App() {
  const windowSize = useSyncExternalStore(
    subscribe,
    () => window.innerWidth,
    () => 0 // 서버 사이드 렌더링 시 제공되는 기본값
  );

  return <>{windowSize}</>;
}
```

- useSyncExternalStore을 통해 현재 윈도우의 innerWidth를 확인하는 코드이다.
- innerWidth는 리액트 외부에 있는 데이터 값이므로 이 값의 변경 여부를 확인해 리렌더링까지 이어지게 하려면 useSyncExternalStore를 사용하는 것이 매우 적절하다.
- 먼저 subscribe 함수를 첫 번째 인수로 넘겨 innerWidth가 변경될 때 일어나는 콜백을 등록했다. useSyncExternalStore는 subscribe 함수의 첫 번째 인수인 콜백을 추가해 resize 이벤트가 발생할 때마다 해당 콜백이 실행되게끔 할 것이다.
- 두 번째 인수로는 현재 스토어의 값인 window.innerWidth를, 마지막으로 서버 사이드에서는 해당 값을 추적할 수 없으므로 0을 제공했다.
- 이러한 것들을 하나의 훅으로 만들어서 다음과 같이 사용할 수도 있다.

  ```jsx
  function subscribe(callback: (this: Window, ev: UIEvent) => void) {
    window.addEventListener("resize", callback);
    return () => {
      window.removeEventListener("resize", callback);
    };
  }

  function useWindowWidth() {
    return useSyncExternalStore(
      subscribe,
      () => window.innerWidth,
      () => 0
    );
  }

  export default function App() {
    const windowSize = useWindowWidth();
    return <>{windowSize}</>;
  }
  ```

- 아래 코드와 같이 useSyncExternalStore가 없어도 비슷한 훅을 만들 수 있다.

  ```jsx
  function useWindowWidth() {
    const [windowWidth, setWindowWidth] = useState(0);
    uesEffect(() => {
      function handleResize() {
        setWindowWidth(window.innerWidth);
      }

      window.addEventListner("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
    }, []);
    return windowWidth;
  }
  ```

그럼 이제 useSyncExternalStore와 앞의 두 예제 사이의 차이점을 알아보자.

아래 코드에서 useTransition을 사용한 예제에서 두 가지 훅을 추가해 차이를 비교해보자.

```jsx
// posts...
const PostsTab = memo(function PostsTab() {
	const width1 = useWindowWidthWithSyncExternalStore()
	const width2 = useWindowWidth()
	const items = Array.from({ length: 1500 }).map((_, i) => (
		<SlowPost key={i} index={i} />
	))

	return (
		<>
			<div>useSyncExternalStore {width1}px</div>
			<div>useEffect + uesState {width2}px</div>
			<ul className="items">{items}</ul>
		</>
	)
}

export default PostsTab
```

Post 탭을 선택하면 렌더링을 지연시키는 startTransition이 실행된 이후에 PostTab이 노출된다.

그리고 startTransition 이후에 width를 보면 그 차이를 확실히 알 수 있는데, useSyncExternalStore를 사용한 훅은 컴포넌트 렌더링 이후에 정확하게 바로 현재 width를 가져온 반면, 사용하지 않은 쪽에 아예 값을 가져오지 못하고 초깃값인 0이 나타나는 것을 확인할 수 있다.

즉, 외부에 상태가 있는 데이터에는 반드시 useSyncExternalStore를 사용해 값을 가져와야 startTransition 등으로 인한 테어링 현상이 발생하지 않음을 알 수 있다.

useSyncExternalStore는 애플리케이션 코드에 직접적으로 사용할 일은 많지 않지만 사용 중인 관리 라이브러리가 외부에서 상태를 관리하고 있다면 이 useSyncExternalStore를 통해 외부 데이터 소스의 변경을 추적하고 있는지 반드시 확인해야 한다.

만약 해당 라이브러리가 이 훅을 사용하고 있지 않다면 렌더링 중간에 발생하는 값 업데이트를 적절하게 처리하지 못하고 테어링 현상이 발생할 것이다.

### useInsertionEffect

useSyncExternalStore가 상태 관리 라이브러리를 위한 훅이면 useInsertionEffect는 CSS-in-js 라이브러리를 위한 훅이다.

CSS 추가 및 수정은 브라우저에서 렌더링하는 작업 대부분을 다시 계산해 작업해야 하므로, 리액트 관점에서 보면 매우 무거운 작업이다.

따라서 리액트 17과 styled-components에서는 클라이언트 렌더링 시에 이러한 작업이 발생하지 않도록 서버 사이드에서 스타일 코드를 삽입했다.

→ 이러한 작업을 도와주는 훅이 useInsertionEffect다.

useInsertionEffect의 기본적인 훅 구조는 useEffect와 동일하다.

한가지 차이점은 실행 시점에 있다.

useInsertionEffect는 DOM이 실제로 변경되기 전에 동기적으로 실행된다. 이 훅 내부에 스타일을 삽입하는 코드를 집어넣음으로써 브라우저가 레이아웃을 계산하기 전에 실행될 수 있게끔 해서 좀 더 자연스러운 스타일 삽입이 가능해진다.

useEffect, useLayoutEffect, useInsertionEffect의 실행 순서는 다음과 같다.

```jsx
function Index() {
  useEffect(() => {
    console.log("useEffect!"); // 3
  });
  useLayoutEffect(() => {
    console.log("useLayoutEffect!"); // 2
  });
  useInsertionEffect(() => {
    console.log("useInsertionEffect!"); // 1
  });
}
```

두 훅 모두 브라우저에 DOM이 렌더링 되기 전에 실행된다는 공통점이 있지만 useLayoutEffect는 모든 DOM의 변경 작업이 다 끝난 이후에 실행되는 반면 useInsertionEffect는 이러한 DOM 변경 작업 이전에 실행된다.

→ 브라우저가 다시 스타일을 입혀서 DOM을 재계산하지 않아도 된다는 점에서 매우 큰 차이점이다.

📍리액트에서 권고하는 것처럼 useSyncExternalStore와 마찬가지로 useInsertionEffect는 실제 애플리케이션 코드를 작성할 때는 사용될 일이 거의 없으므로 라이브러리를 작성하는 경우가 아니라면 참고만 하고 실제 애플리케이션 코드에는 가급적 사용하지 않는 것이 좋다.

## 🖌️ react-dom/client

클라이언트에서 리액트 트리를 만들 때 사용되는 API가 변경됐다. 만약 리액트 18 이하 버전에서 만든 create-react-app으로 프로젝트를 유지보수 중이라면 리액트 18로 업그레이드할 때 반드시 `index.{t|j}jsx`에 있는 내용을 변경해야 한다.

### createRoot

기존의 react-dom에 있던 render 메서드를 대체할 새로운 메서드다.

리액트 18의 기능을 사용하고 싶다면 이 createRoot와 render를 함께 사용해야 한다.

```jsx
// before
import ReactDOM from "react-dom";
import App from "App";

const container = document.getElementById("root");

ReactDOM.render(<App />, container);

// after
import ReactDOM from "react-dom";
import App from "App";

const container = document.getElementById("root");

const root = ReactDOM.createRoot(container);
root.render(<App />);
```

→ 리액트 18로 업그레이드를 고려하고 있다면 리액트의 루트 컴포넌트가 렌더링되고 있는 곳에서 위와 같이 코드를 변경해야 한다.

### hydrateRoot

서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드다.

뒤이어 설명할 ReactDOM 서버 API와 함께 사용된다.

```jsx
// before
import ReactDOM from "react-dom";
import App from "App";

const container = document.getElementById("root");

ReactDOM.hydrate(<App />, container);

// after
import ReactDOM from "react-dom";
import App from "App";

const container = document.getElementById("root");

const root = ReactDOM.hydrateRoot(container, <App />);
```

대부분의 서버 사이드 렌더링은 프레임워크에 의존하고 있을 것이므로 사용하는 쪽에서 수정할 일은 거의 없는 코드다. → 서버 사이드 렌더링을 구현해서 사용하고 있다면 수정이 필요하다.

이렇게 API가 변경된 것 외에도 추가로 두 API는 새로운 옵션인 onRecoverableError를 인수로 받는다. 이 옵션은 리액트가 렌더링 또는 하이드레이션 과정에서 에러가 발생했을 때 실행하는 콜백 함수다.

기본값으로 reportError 또는 console.error를 사용하지만 필요하다면 원하는 내용을 추가해도 된다.

## 🖌️ react-dom/server

클라이언트의 변화와 마찬가지로 서버에서도 컴포넌트를 생성하는 API에 변경이 있다. 아래에서 알아보자.

### renderToPipeableStream

리액트 컴포넌트를 HTML로 렌더링하는 메서드이다.

이 메서드는 이름에서 알 수 있듯 스트림을 지원하는 메서드로, HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다.

이를 통해 서버에서는 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게끔 할 수 있다.

여기서 hydrateRoot를 호출하면 서버에서는 HTML을 렌더링하고, 클라이언트의 리액트에서는 여기에 이벤트만 추가함으로써 첫 번째 로딩을 매우 빠르게 수행할 수 있다.

다음 예제를 보자.

```jsx
import * as React from 'react'

// res는 HTTP 응답이다.
function render(url, res) {
	let didError = false
	// 서버에서 필요한 데이터를 불러온다.
	// 그리고 여기에서 데이터를 불러오는 데 오랜 시간이 걸린다고 가정해 보자.
	const data = createSErverData()
	const stream = renderToPipeableStream(
		// 데이터를 context API로 넘긴다.
		<DataProvider data={data}>
			<App assets={assets} />
		</DataProvider>,
		{
			// 렌더링 시에 포함시켜야 할 자바스크립트 번들
			bootstrapScripts: [assets['main.js']],
			onShellRaady() {
				// 에러 발생 시 처리 추가
				res.statusCode = didError ? 500 : 200
				res.setHeaser('Content-type', 'text/html')
				stream.pipe(res)
			},
			onError(x) {
				didError = true
				console.error(x)
			},
		},
	)
	// 렌더링 시작 이후 일정 시간이 흐르면 렌더링에 실패한 것으로 간주하고 취소한다.
	setTimeout(() => stream.abort(), ABORT_DELAY)
}

export default function App({assets}) {
	return (
		<Html assets={assets} title="Hello">
			<Suspense fallback={<Spinner />}>
				<ErrorBoundary FallbackComponent={Error}>
					<Content />
				</ErrorBoundary>
			</Suspense>
		</Html>
	);
}

function Content() {
	return (
		<Layout>
			<NavBar />
			<article className="post">
				<section classNAme="comments">
					<h2>Comments</h2>
					<!-- 데이터가 불러오기 전에 보여줄 컴포넌트 -->
					<Suspense fallback={<Spinner />}>
						<!-- 데이터가 완료된 후에 노출되는 컴포넌트 -->
						<Comments />
					</Suspense>
				</section>
				<h2>Thanks for reading!</h2>
			</article>
		</Layout>
	);
}
```

이렇게 renderToPipeableStream을 쓰면 최초에 브라우저는 아직 불러오지 못한 데이터 부분을 Suspense의 fallback으로 받는다.

```jsx
<main>
	<article class="post">
		<!--$-->
		<h1>Hello world</h1>
		<!-- ... -->
		<section class="comments">
			<h2>Comments</h2>

			<template id="B:0"></template>
			<!-- Suspense의 fallbacka이 온다. -->
			<div
				class="spinner spinner--active"
				role="progressbar"
				aria-busy="true"
			></div>
		</section>
		<h2>Thanks for reading!</h2>
	</article>
</main>
```

그리고 createServerData의 데이터 로딩이 끝나면 <Comments/>가 데이터를 가지고 렌더링될 것이다.

기존 renderToNodeStream의 문제는 무조건 렌더링을 순서대로 해야 하고, 그리고 그 순서에 의존적이기 때문에 이전 렌더링이 완료되지 않는다면 이후 렌더링도 끝나지 않는다는 것이다.

따라서 만약에 렌더링 중간에 오래 걸리는 작업이 있다면 그 작업 때문에 나머지 렌더링도 덩달아 지연된다는 문제가 있다.

그러나 이번에 새롭게 추가된 renderToPipeableStream를 활용하면 순서나 오래 걸리는 렌더링에 영향받을 필요 없이 빠르게 렌더링을 수행할 수 있게 된다.

리액트 18에서 제공하는 <Suspense />와 같은 코드 분할 내지는 지연 렌더링을 서버 사이드에서 완전히 사용하기 위해서는 renderToPipeableStream 대신에 이 메서드를 사용해야 한다.

물론 실제로 renderToPipeableStream을 가지고 서버 사이드 렌더링을 만드는 경우는 거의 없겠지만 사용하고자 하는 프레임워크에서 리액트 18을 사용하고 싶다면 해당 메서드의 지원 여부를 확인해 보는 것이 좋다.

### renderToReadableStream

renderToPipeableStream이 Node.js 환경에서의 렌더링을 위해 사용된다면, renderToReadableStream은 웹 스트림(web stream)을 기반으로 작동한다는 차이가 있다.

이는 서버 환경이 아닌 클라우드플레어(Cloudflare)나 디노(Deno) 같은 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드다.

실제로 웹 애플리케이션을 개발하는 경우에는 이 메서드를 사용할 일이 거의 없을 것이다.

## 🖌️ 자동 배치(Automatic Batching)

자동 배치, 이른바 Automatic Batching은 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다.

예를 들어, 버튼 클릭 한 번에 두 개 이상의 state를 동시에 업데이트한다고 가정해보자. 자동 배치에서는 이를 하나의 리렌더링으로 묶어서 수행할 수 있다.

다음 예제를 보자.

```jsx
import { Profiler, useEffect, useState, useCallback } from "react";

const sleep = (ms: number) => {
  return new Promise((resolve) => setTimeout(resolebe, ms));
};

export default function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlas] = useState(false);

  const callback = useCallback(
    (id, phase, actualDuration, baseDuration, startTime, commitTime) => {
      consle.group(phase);
      console.table({ id, phase, commitTime });
      console.groupEnd();
    },
    []
  );

  useEffect(() => {
    console.log("rendered!");
  });

  function handleClick() {
    sleep(3000).then(() => {
      setCount((c) => c + 1);
      setFlag((f) => !f);
    });
  }

  return (
    <Profiler id="React18" onREnder={callback}>
      <button onClick={handleClick}>Next</button>
      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </Profiler>
  );
}
```

아래 사진은 위 코드를 리액트 17과 18에서 확인한 모습니다. 17에서는 자동 배치가 되지 않아 두 번의 리렌더링이 일어났지만 18에서는 자동 배치 덕분에 리렌더링이 단 한 번만 일어났다.

![Untitled 13](https://github.com/user-attachments/assets/34db29db-8a44-4047-97db-e1680d800753)

→ 이 사진은 자동 배치가 일어나지 않은 리액트 17(위)과 자동 배치가 일어난 리액트 18(아래)의 렌더링 횟수 차이를 보여주고 있다.

예제에서 버튼을 누르면 리액트 18에서는 한 번의 rendered만 기록되지만, 리액트 17 이전 버전에서는 두번 기록되는 것을 확인할 수 있다. 그리고 또 한가지 특이한 점은 Promise를 사용해 고의로 실행을 지연시키는 sleep 함수를 호출하지 않으면 버전과 상관없이 동일하게 한 번만 렌더링된다는 것이다.

이는 리액트 17이하의 과거 버전의 경우 이벤트 핸들러 내부에서는 이러한 자동 배치 작업이 이뤄지고 있었지만 Promise, setTimeout 같은 비동기 이벤트에서는 자동 배치가 이뤄지고 있지 않았기 때문이다.

즉, 동기와 비동기 배치 작업에 일관성이 없었고, 이를 보완하기 위해 리액트 18 버전부터는 루트 컴포넌트를 createRoot를 사용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있게 됐다.

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

const rootElement = document.getElementById("root");
const root = ReactDOM.createRoot(rootElement);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

이 코드에서는 루트 요소를 document.getElementById(”root”)로 가져온 다음, ReactDOM.createRoot 활용해 렌더링하도록 설정해뒀다. 이렇게 하면 자동 배치가 활성화되어 리액트가 동기, 비동기, 이벤트 핸들러 등에 관계 없이 렌더링을 배치로 수행하게 된다.

만약 이러한 자동 배치를 리액트 18에서도 하고 싶지 않거나 이러한 작동 방식이 기존 코드에 영향을 미칠것으로 예상된다면 flushSync를 사용하면 된다.

```jsx
import { flushSync } from "react-dom";

function handleClick() {
  flushSync(() => {
    setCounter((c) => c + 1);
  });
  flushSYnc(() => {
    setFlag((f) => !f);
  });
}
```

→ flushSync는 react가 아닌 react-dom에서 제공한다는 것에 주의하자!

## 🖌️ 더욱 엄격해진 엄격 모드

### 리액트의 엄격 모드

리액트의 엄격 모드는 리액트에서 제공하는 컴포넌트 중 하나로, 리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는 데 도움이 되는 컴포넌트다. 이름에서 알 수 있듯이 리액트에서 널리 알려져 있는 Fragment나 Suspense와 마찬가지로 컴포넌트 형태로 선언해야 사용할 수 있다.

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));

root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

이 엄격 모드에서 수행하는 모드는 모두 개발자 모드에서만 작동하고, 프로덕션 모드에서는 작동하지 않는다. 컴포넌트 형태로 사용할 수 있으므로 이 예제처럼 모든 리액트 애플리케이션 전체에서 작동하게 할 수도, 원한다면 특정 컴포넌트 내부에서만 작동하게 할 수도 있다.

이제 본격적으로 리액트 엄격 모드에서 하는 작업에 대해 알아보자.

**더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고**

`componentWillMount`, `componentSillReceiveProps`, `componentWillUpdate`는 더 이상 사용할 수 없게 된 생명주기 메서드이다.

이러한 세 메서드는 16.3 버전부터 UNSAFE*가 붙게 됐고, 이후 16 버전에서는 UNSAFE*가 붙지 않는 생명주기 메서드를 사용하게 되면 경고 로그가 기록되고, 17 버전부터는 UNSAFE\_가 붙은 세 메서드만 남고 나머지는 다 삭제됐다.

그럼에도 불구하고 UNSAFE\_가 붙은 생명주기 메서드를 사용하면서 엄격 모드를 켜게 된다면 다음과 같은 로그를 확인할 수 있다.

```jsx
class UnsafeClassComponent extends Component {
  componentWillMount() {
    console.log("componentWillMount");
  }

  render() {
    return <>안녕하세요?</>;
  }
}
```

![Untitled 14](https://github.com/user-attachments/assets/aab74ae9-ed66-4963-88e0-0886b4963c8f)

**문자열 ref 사용 금지**

과거 리액트에서는 레거시 문자열 ref라 해서 createRef가 없어도 컴포넌트 내부에서 문자열로 ref를 생성하고, 이를 사용해 DOM 노드를 참조하는 것이 가능했다.

```jsx
class UnsafeClassComponent extends Component {
  componentDidMount() {
    // 'refs' is deprecated.
    // <input tyoe="text" />
    console.log(this.refs.myInput);
  }

  render() {
    return (
      <div>
        <input type="text" ref="myInput" />
      </div>
    );
  }
}
```

render()에 있는 ref를 보면 단순히 myInout이라는 문자열로 ref에 할당한 것을 볼 수 있으며, 이를 토대로 refs를 바탕으로 DOM에 접근할 수 있다는 것을 알 수 있다. 그러나 이는 몇 가지 문제가 있어 사용이 금지됐다.

따라서 엄격 모드에서는 다음과 같은 경고 문구가 출력된다.

![Untitled 15](https://github.com/user-attachments/assets/eccc8923-75f4-408e-b03c-c40eccffa0e9)

문자열 ref의 문제는 다음과 같다.

- 문자열로 값을 주는 것은 여러 컴포넌트에 걸쳐 사용될 수 있으므로 충돌의 여지가 있다.
- 앞의 코드에서도 볼 수 있듯이 단순히 문자열로만 존재하기 때문에 실제로 어떤 ref에서 참조되고 있는지 파악하기 어렵다.
- 리액트가 계속해서 현재 렌더링되고 있는 컴포넌트의 ref의 값을 추적해야 하기 때문에 성능 이슈가 있다.

**findDOMNode에 대한 경고 출력**

findDOMNode는 클래스 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는, 현재는 사용 하는 것이 권장되지 않는 메서드다. 다음 예제 코드를 보자.

```jsx
class UnsafeClassComponent extends Component {
	componentDidMount() {
		const node = ReactDOM.findDOMNode(this)
		if (node) {
			;(node as HTMLDivElement).style.color = 'red'
		}
	}

	render() {
		return <div>UnsafeClassComponent</div>
	}
}
```

예제에서는 ReactDOM에서 제공하는 findDOMNode() 메서드를 활용해 클래스 컴포넌트의 요소에 직접 접근해 해당 DOM 요소의 스타일을 수정한 것을 확인할 수 있다.

그러나 더 이상 권장되지 않는 방식으로, 엄격 모드에서 findDOMNode를 사용하면 다음과 같은 에러가 발생한다.

![Untitled 16](https://github.com/user-attachments/assets/5e5a13e1-cc0e-46bf-984c-a85bf950e013)

![Untitled 17](https://github.com/user-attachments/assets/be7905ff-9453-4ba3-8483-ba78920148ad)

![Untitled 18](https://github.com/user-attachments/assets/805e49a7-3721-4481-9329-b30de50cfef6)

**구 Context API 사용 시 발생하는 경고**

childContextTypes와 getChildContext를 사용하는 구 리액트 Context API를 사용하면 엄격 모드에서는 다음과 같은 에러를 출력한다.

![Untitled 19](https://github.com/user-attachments/assets/174f4ca2-8c25-46ea-9587-335307664a09)

![Untitled 20](https://github.com/user-attachments/assets/28b5f9db-82b9-4fa6-a463-44ea83597a3a)

**예상치 못한 부작용(side-effects) 검사**

리액트 엄격 모드 내부에서는 다음 내용을 의도적으로 이중으로 호출한다.

- 클래스 컴포넌트의 constructor, render, shouldComponentUpdate, getDrivedStateFromProps
- 클래스 컴포넌트의 setState의 첫 번째 인수
- 함수 컴포넌트의 body
- useState, useMemo, useReducer에 전달되는 함수

다음 예제 코드를 개발 모드에서 살펴보자.

```jsx
export default function App() {
  console.log("component body");

  const [number, setNumber] = useState(() => {
    console.log("initialize state");
    return 0;
  });

  const handleClick = useCallback(() => {
    setNumber((prev) => prev + 1);
  }, []);

  const tenTimes = useMEmo(() => {
    console.log("* 10!");
    return number * 10;
  }, [number]);

  return <button onClick={handleClick}>{tenTimes} 클릭</button>;
}
```

이 코드를 실행하면 브라우저 콘솔에서 다음과 같이 기록되는 것을 확ㅇ니할 수 있다.

![Untitled 21](https://github.com/user-attachments/assets/48b2a61f-edc0-4f3a-97b4-58ed89940a14)

→ console.log로 기록한 내용이 모두 두 번씩 기록되는 것으로 미루어 보아 앞에서 언급한 내용이 두 번씩 실행되는 것을 알 수 있다.

그럼 왜 엄격 모드는 두 번씩 실행되는 것일까?

![Untitled 22](https://github.com/user-attachments/assets/96e19eee-ec4e-4c99-86a8-be92adebd4a2)

그 이유는 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문이고, 엄격 모드에서는 앞에서 언급한 내용이 실제로 지켜지고 있는지, 즉 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜 주기 위해 두 번 실행하게 되는 것이다.

리액트에서는 state, props, context가 변경되지 않으면(입력 값이 변경되지 않으면) 항상 동일한 JSX를(항상 같은 결과물을) 반환해야 한다.

리액트에서는 이러한 규칙을 위배하는 컴포넌트는 잠재적으로 버그가 존재할 수 있다고 판단하기 때문에 엄격 모드에서는 순수해야 하는 함수, 메서드 등을 두 번 실행해 이러한 내용을 사전에 개발자가 파악할 수 있도록 유도하는 것이다.

### 리액트 18에서 추가된 엄격 모드

```jsx
import { userEffect } from "react";

let count = 0;
export default function App() {
  useEffect(() => {
    count += 1;
    console.log(`mount App, ${count}`);

    return () => {
      console.log(`unmount app ${count}`);
    };
  });
  return <h1>hello</h1>;
}
```

이 코드를 각각 리액트 18과 17에서 실행하면 다음과 같은 결과를 볼 수 있다.

```jsx
// react 18
// mount App, 1
// unmount app 1
// mount App, 2

// react 17
// mount App, 1
```

→ 마치 최초에 useEffect가 두 번 작동한 것처럼 보이는데, 이는 리액트 18의 StrictMode에서 의도된 작동 방식이다. 이에 대해서 리액트 팀은 다음과 같이 이야기 했다.

![Untitled 23](https://github.com/user-attachments/assets/711610b2-0f27-4d38-8000-437c29022de3)

즉, 이후에 잇을 변경을 위해 StrictMode에서 고의로 useEffect를 두 번 작동시키는 내용을 추가한 것이다.

따라서 미래에 있을 리액트 업데이트에 효과적으로 대비하려면 이 두번의 useEffect 호출에도 자유로운 컴포넌트를 작성하는 것이 좋다.

이를 위해서는 useEffect를 사용할 때 반드시 적절한 cleanup 함수를 배치해서 반복 실행될 수 있는 useEffect로 부터 최대한 자유로운 컴포넌트를 만드는 것이 좋다.

## 🖌️ Suspense 기능 강화

Suspense는 리액트 16.6 버전에서 실험 버전으로 도입된 기능으로, 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능이다.

다음 예제 코드를 보자.

```jsx
// Sample Component
export default function SampleComponent() {
	return <>동적으로 가져오는 컴포넌트</>
}

// app.tsx
import { Suspense, lazy } from 'react'

const DynamicSampleComponent = lazy(() => import('./SampleComponent'))

export default function App() {
	return (
		<Suspense fallback={<>로딩중</>}>
			<DynamicSampleComponent />
		</Suspense>
	)
}
```

예제에서는 app.tsx에서 SampleComponent를 React.lazy를 통해 불러온다. 여기서 React.lazy는 컴포넌트를 첫 번째 렌더링 시에 불러오지 않고, 최초 렌더링 이후에 컴포넌트를 지연시켜 불러오는 역할을 한다.

그리고 이렇게 불러온 SampleComponent는 Suspense로 감싸져 있는데, 이 Suspense는 React.lazy를 통해 지연시켜 불러온 컴포넌트를 렌더링하는 역할을 한다.

Suspense는 크게 두 개의 인수를 받는데, 하나는 fallback props로, 지연시켜 불러온 컴포넌트를 미처 불러오지 못했을 때 보여주는 fallback을 나타낸다.

그리고 children으로는 React.lazy로 선언한 지연 컴포넌트를 받는다. 즉, 지연 컴포넌트를 로딩하기 전에는 fallback을 보여주고, 이 lazy로 불러온 컴포넌트가 지연 로딩이 완료되면 fallback 대신 비로소 해당 컴포넌트를 보여주게 된다.

이처럼 lazy와 Suspense는 한 쌍으로 사용됐고, 애플리케이션에서 상대적으로 중요하지 않은 컴포넌트를 분할해 초기 렌더링 속도를 향상시키는 데 많은 도움을 줬다.

그러나 이 18 이전의 Suspense에는 몇 가지 문제점이 있었다.

- 기존의 Suspense는 컴포넌트가 아직 보이기도 전에 useEffect가 실행되는 문제가 존재했다. 다음 코드를 보자.
  ```jsx
  function ProfilePage() {
    // initialResource는 Promise로 데이터를 불러오는 데 어느 정도 시간이 필요함
    const [resource, setResource] = useState(initialResource);
    return (
      <>
        <Suspense
          fallback={
            <>
              <h1>Loading profile...</h1>
            </>
          }
        >
          <Suspense fallback={<h1>Loading posts...</h1>}>
            <Sibling name="two" />
            <ProfileTimelint resource={resource} />
          </Suspense>
        </Suspense>
      </>
    );
  }
  ```
  이 예제에서는 resource는 Promise를 통해 데이터를 비동기로 불러온다. 개발자의 의도는 이 비동기 데이터 로딩이 끝나기 전까지는 <Suspense> 하단의 컴포넌트가 렌더링되지 않게 하는 것이다. <Suspense>의 자식으로 존재하는 <Sibling>은 비록 비동기 데이터에 의존하지 않지만 Suspense의 자식으로 존재하므로 반드시 Suspense의 fallback이 종료된 이후에 effect가 실행돼야만 했다. 이는 UI상으로는 문제가 없었지만 실제 useEffect나 useLayoutEffect 등으로 보면 아직 <Suspense> 작업이 진행 중임에도 불구하고 <Sibling>의 effect가 실행되는 버그가 있었다.
- Suspense는 서버에서 사용할 수 없었다. 다음 코드를 보자.

  ```jsx
  // components/SampleComponent.tsx
  export default function SampleComponent() {
  	return <>동적으로 가져오는 컴포넌트></>
  }

  // pages/index.tsx
  import { Suspense, lazy } from 'react'

  const DynamicSampleComponent = lazy(
  	() => import('../components/SampleComponet'),
  )

  export default function Home() {
  	return (
  		<Suspense fallback={<>로딩중</>}>
  			<DynamicSampleComponent />
  		</Suspense>
  	)
  }
  ```

  이 코드는 Nest.js에서 Suspense를 사용하는 코드다. 그러나 코드를 실행하면 “Error: ReactDOMServer does not yet supprot Suspense” 에러가 발생한다. 실험 단계인 기존의 Suspense에서는 지연 중인 컴포넌트를 렌더링할 방법이 없었기 때문이다. 기본의 서버 사이드 렌더링 구조에서 Suspense를 활용하려면 useMount와 같은 훅을 구현해서 반드시 클라이언트에서만 작동하도록 처리해야 했다.

  ```jsx
  import { Suspense, useEffect, useState, ComponentProps } from "react";

  function useMounted() {
    const [mounted, setMounted] = useState(false);

    // useEffect는 클라이언트에서만 실행되므로 mounted가 true면
    // 클라이언트에서 실행되는 코드다.
    useEffect(() => {
      setMouted(true);
    }, []);

    return mounted;
  }

  export default function CustomSuspense(
    props: ComponentProps<typeof Suspense>
  ) {
    const isMounted = useMounted();

    if (isMounted) {
      return <Suspense {...props} />;
    }

    return <>{props.fallback}</>;
  }
  ```

이제 리액트 18버전에서는 Suspense가 실험 단계를 벗어나 정식으로 지원된다.

구체적으로 변경된 내용은 다음과 같다.

- 앞에서 언급했던, 아직 마운트됙 직전임에도 effect가 빠르게 실행되는 문제가 수정됐다. 이제 컴포넌트가 실제로 화면에 노출될 때 effect가 실행된다.
- Suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행된다. 이전에는 컴포넌트 스스로가 Suspense에 의해 현재 보여지고 있는지, 숨겨져 있는지 알 방법이 없었다. 그러나 이제 Suspense에 의해 노출이 된다면 useLayoutEffect의 effect(componentDidMount)가, 가려진다면 useLayoutEffect의 cleanUp(componentWillIUnmount)이 정상적으로 실행된다.
- Suspense를 이제 서버에서도 실행할 수 있게 된다. 앞의 예제와 같이 CustomSuspense를 구현하지 않더라도 정상적으로 Suspense를 사용할 수 있다. 서버에서는 일단 fallback 상태의 트리를 클라이언트에 제공하고, 불러올 준비가 된다면 자연스럽게 렌더링된다.
- Suspense 내에 스로틀링이 추가됐다. 화면이 너무 자주 업데이트되어 시각적으로 방해받는 것을 방지하기 위해 리액트는 다음 렌더링을 보여주기 전에 잠시 대기한다. 즉, 중첩된 Suspense의 fallback이 있다면 자동으로 스로틀되어 최대한 자연스럽게 보여주기 위해 노력한다.

Suspense의 사용이 이전보다 비교적 자연스러워졌지만 여전히 Suspense를 사용할 수 있는 시나리오는 제한적인 편이다.

앞의 예제처럼 React.lazy를 사용해 컴포넌트를 지연시켜 불러오거나, 혹은 Next.js와 같이 Suspense를 자체적으로 지원하는 프레임워크에서만 Suspense를 사용하는 것이 가능하다.

향후에는 이러한 프레임워크 없이도 Suspense를 사용할 수 있는 방법이 나올 것으로 보인다.

## 🖌️ 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

이제 리액트는 리액트를 사용하는 코드에서 다음과 같은 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포된다.

- Promise : 비동기 연산이 종료된 이후에 실패 또는 결과값을 확인할 수 있는 객체
  - 참고 : https://caniuse.com/promises
- Symbol : 자바스크립트의 새로운 데이터 형식으로, 익명의 객체 속성을 만들 수 있는 특성을 가진 객체
  - 참고 : https://caniuse.com/mdn-javascrtipt_builltins_symbol
- Object.assign : 객체의 열거 가능한 모든 속성을 다른 객체로 붙여 넣는 메서드
  - 참고 : https://caniuse.com/mdn-javascript_builtins_object_assign

이러한 세 기능을 지원하지 않는 브라우저에서 서비스해야 한다면 이 세 가지 기능을 위한 폴리필이 반드시 필요하다.

예를 들어, 인터넷 익스플로러 11 환경에서 이 세 가지 폴리필이 설치돼 있지 않다면 리액트는 정상적으로 작동하지 않을 수도 있다. → 2022년 6월 15일 부터 인터넷 익스플로러 지원 중단

리액트뿐만 아니라 요즘 출시되는 대부분의 라이브러리가 ES5 지원을 중단하는 추세이기 때문에 만약 웹서비스가 여전히 인터넷 익스플로러 11을 지원해야 한다면 폴리필 설치 및 트랜스파일에 각별히 신경 써야 한다.

## 🖌️ 그 밖에 알아두면 좋은 변경사항

- 이제 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다. undefined 반환은 null 반환과 동일하게 처리된다.
- 이와 마찬가지로 <Suspense fallback={undefined}>도 null과 동일하게 처리된다.
- renderToNodeStream이 지원 중단됐다. 그 대신 renderToPipeableStream을 사용하는 것이 권장된다.
