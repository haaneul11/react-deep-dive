# 리액트 핵심 요소 깊게 살펴보기

# 📑 JSX란?

JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법이다.

JSX는 ECMAScript라고 불리는 자바스크립트 표준의 일부가 아니며, V8이나 Deno와 같은 자바스크립트 엔진이나, 크롬, 웨일, 파이어폭스 같은 브라우저에 의해서 실행되거나 표현되도록 만들어진 구문이 아니다.

JSX가 포함된 코드를 아무런 처리 없이 그대로 실행하면 에러가 발생한다. JSX는 자바스크립트 표준 코드가 아닌 페이스북이 임의로 만든 새로운 문법이기 때문에 JSX는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환된다.

JSX는 HTML이나 XML을 자바스크립트 내부에 표현하는 것이 유일한 목적이 아니고, 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다.

즉, JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해두고, 이 JSX를 트랜스파일이라는 과정을 거쳐 자바스크립트(ECMAScript)가 이해할 수 있는 코드로 변경하는 것이 목표이다.

이 얘기는 HTML, XML 외에도 다른 구문으로 확장될 수 있게끔 고려돼 있으며 최대한 구문을 간결하고 친숙하게 작성할 수 있도록 설계되어 있다는 얘기다.

XML과 비슷하게 보이는 것은 단순히 자바스크립트 개발자로 하여금 친숙함을 느낄 수 있도록 하는 것이다.

⇒ JSX는 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는 데 많은 도움을 주는 새로운 문법이다.

## 🖌️ JSX의 정의

JSX는 기본적으로 `JSXElement`, `JSXAttibutes`, `JSXChildren`, `JSXStrings`라는 4가지 컴포넌트를 기반으로 구성되어 있다.

### JSXElement

JSX를 구성하는 가장 기본 요소로, HTML의 요소(element)와 비슷한 역할을 한다. JSXElement가 되기 위해서는 다음과 같은 형태 중 하나여야 한다.

- JSXOpeningElement : 일반적으로 볼 수 있는 요소이다. JSXOpeningElement로 시작했다면 후술할 JSXClosingElement가 동일한 요소로 같은 단계에서 선언돼 있어야 올바른 JSX 문법으로 간주된다.
  - 예: `<JSXElement JSXAttributes(optional)>`
- JSXClosingElement : JSXOpeningElement가 종료됐음을 알리는 요소로, 반드시 JSXOpeningElement와 쌍으로 사용되어야 한다.
  - 예: `</JSXElement>`
- JSXSelfClosingElement : 요소가 시작되고, 스스로 종료되는 형태를 의미한다. <script />와 동일한 모습을 띠고 있다. 이는 내부적으로 자식을 포함할 수 없는 형태를 의미한다.
  - 예 : `<JSXElement JSXAttributes(optional) />`
- JSXFragment : 아무런 요소가 없는 형태로, JSXSelfClosingElement 형태를 띨 수는 없다. </>는 불가능하다. 단 <></>는 가능하다.
  - 예 : `<>JSXChildren(optional)</>`

JSXElementName

JSXElementName은 JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다. 이름으로 가능한 것은 다음과 같다.

- `JSXIdentifier` : JSX 내부에서 사용할 수 있는 식별자를 의미한다. 이는 자바스크립트 식별자 규칙과 동일하다. 즉, `<$></$>` `<_></_>`도 가능하지만 자바스크립트와 마찬가지로 숫자로 시작하거나 $와 \_외의 다른 특수문자로는 시작할 수 없다.

  ```jsx
  function Valid1() {
    return <$></$>;
  }

  function Valid2() {
    return <_></_>;
  }
  ```

  ❣️ 아래와 같은 형식은 사용할 수 없다.

  ```jsx
  function Invalid1() {
  	return <1></1>
  }
  ```

- `JSXNamespacedName` : `JSXIdentifier:JSXIdentifier`의 조합, 즉 `:`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. `:`로 묶을 수 있는 것은 한 개뿐이다. 두 개 이상은 올바른 식별자로 취급되지 않는다.

  ```jsx
  function valid() {
    return <foo:bar></foo:bar>;
  }
  ```

  ❣️ 아래와 같은 형식은 사용할 수 없다.

  ```jsx
  function invalid() {
  	return <foo:bar:baz></foo:bar:baz>
  }
  ```

- `JSXMemberExpression` : `JSXIdentifier.JSXIdentifier`의 조합. 즉 `.`을 통해 서로 다른 식별자를 이어주는 것도 하나의 식별자로 취급된다. `:`로 묶는 `JSXNamespacedName`과는 다르게 `.`을 여러 개 이어서 하는 것도 가능하다. 단 `JSXNamespacedName`과 이어서 사용하는 것은 불가능하다.

  ```jsx
  function valid1() {
    return <foo.bar></foo.bar>;
  }

  function valid2() {
    return <foo.bar.baz></foo.bar.baz>;
  }
  ```

  ❣️ 아래와 같은 형식은 사용할 수 없다.

  ```jsx
  function valid2() {
  	return <foo:bar.baz></foo:bar.baz>
  }
  ```

### JSXAttributes

JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니고, 존재하지 않아도 에러가 나지 않는다.

- `JSXSpreadAttributes` : 자바스크립트의 전개 연산자와 동일한 역할을 볼 수 있다.
  - {…AssignmentExpression} : 이 AssignmentExpression에는 단순히 객체뿐만 아니라 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재할 수 있다. 여기에는 조건문 표현식, 화살표 함수, 할당식 등 다양한 것이 포함되어 있다.
- JSXAttribute : 속성을 나타내는 키와 값으로 짝을 이루어서 표현한다. 키는 JSXAttributeName. 값은 JSXAttribute Value로 불린다.

  - JSXAttributeName : 속성의 키 값. 키로는 앞서 JSXElementName에서 언급했던 JSXIdentifier와 JSXNamespacedName이 가능하다. 여기서도 마찬가지로 :을 이용해 키를 나타낼 수 있다.
    ```jsx
    function valid1() {
      return <foo.bar foo:bar="baz"></foo.bar>;
    }
    ```
  - JSXAttributeValue : 속성의 키에 할당할 수 있는 값으로, 다음 중 하나를 만족해야 한다.

    - “큰따옴표로 구성된 문자열” : 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
    - ‘작은따옴표로 구성된 문자열’ : 자바스크립트의 문자열과 동일하다. 안에 아무런 내용이 없어도 상관없다.
    - { AssignmentExpression } : 자바스크립트의 AssignmentExpression을 의미한다. AssignmentExpression은 자바스크립트에서 값을 할당할 때 쓰는 표현식을 말한다. 즉, 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능하다.
    - JSXElement : 값으로 다른 JSX 요소가 들어갈 수 있다. 리액트에서 자주 볼 수 없는 코드지만 다음과 같은 형태도 가능하다.

      ```jsx
      function Child({ attribute }) {
        return <div>{attribute}</div>;
      }

      export default function App() {
        return (
          <div>
            <Child attribute=<div>hello</div> />
          </div>
        );
      }
      ```

    - 대부분의 리액트 개발자들은 `<Child attribute=<div>hello</div> />` 와 같이 값으로 들어가는 리액트 컴포넌트를 {}로 감싸는 걸 보는 것이 더 익숙할 텐데, 사실 이것은 문법적인 오류가 아닌 prettier의 규칙이다. 이 prettier 규칙은 태그가 포함된 JSX 구문을 좀 더 읽기 쉽게 만들기 위해 제공된다.
    - JSXFragment: 값으로 별도 속성을 갖지 않는 형태의 JSX 요소가 들어갈 수 있다. 즉, 비어 있는 형태의 <></>가 허용된다.

### JSXChildren

JSXElement의 자식 값을 나타낸다. JSX는 앞서 언급했듯 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있으며, 그 자식을 JSXChildren이라고 한다.

- JSXChild: JSXChildren을 이루는 기본 단위다. 단어의 차이에서 알 수 있듯이 JSXChildren은 JSXChild를 0개 이상 가질 수 있다. 0개 이상이라는 의미에서 알 수 있는 것처럼 JSXChildren은 JSXChild가 없어도 상관없다.
  - JSXText : {, <, >, }을 제외한 문자열. 이는 다른 JSX 문법과 혼동을 줄 수 있기 때문이다. 만약 이 문자를 표현하고 싶다면 문자열로 표시하는 방법이 있다.
    ```jsx
    function valid() {
      return <>{"{} <>"}</>;
    }
    ```
  - JSXElement : 값으로 다른 JSX 요소가 들어갈 수 있다.
  - JSXFragment : 값으로 빈 JSX 요소인 <></>가 들어갈 수 있다.
  - { JSXChildExpression (optional) } : 이 JSXChildExpression은 자바스크립트의 AssignmentExpression을 의미한다. 다음과 같으 코드로 올바른 JSX 표현식으로 볼 수 있다.
    ```jsx
    export default function App() {
      return <>{(() => "foo")()}</>;
    }
    ```
    → 이 함수를 리액트에서 렌더링하면 “foo”라는 문자열이 출력된다.

### JSXStrings

JSXAttributeValue와 JSXText는 HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계돼 있다.

HTML에서 사용 가능한 문자열은 모두 JSXString에서도 가능하다.

정의된 문자열은 `“큰따옴표로 구성된 문자열”`, `‘작은따옴표로 구성된 문자열’` 혹은 `JSXText`를 의미한다.

\는 자바스크립트에서 특수문자를 처리할 때 상요되므로 몇 가지 제약 사항(\를 표현하기 위해서는 \\로 이스케이프해야 함)이 있지만 HTML에서는 아무런 제약 없이 사용할 수 있다.

```jsx
<!-- \을 사용하는 데 문제가 없다. -->
<button>\</button>
// Uncaught SystaxError: Invalid or unexpected token
let excape1 = "\"

// ok
let excape2 = "\\"
```

→ 현재 JSX는 HTML처럼 \을 이스케이프 문자열로 처리하고 있지 않다.

## 🖌️ JSX 예제

✅ 유효한 형태의 JSX

- 하나의 요소로 구성된 가장 단순한 형태
  ```jsx
  const ComponentA = <A>안녕하세요.</A>;
  ```
- 자식이 없이 SelfClosingTag로 닫혀 있는 형태 가능
  ```jsx
  const ComponentB = <A />;
  ```
- 옵션을 { }와 전개 연산자로 작성한 형태
  ```jsx
  const ComponentC = <A {...{ required: true }} />;
  ```
- 속성만 넣어도 가능
  ```jsx
  const ComponentD = <A required />;
  ```
- 속성과 속성값을 넣을 수 있다.
  ```jsx
  const ComponentE = <A required={false} />;
  ```
- 옵션의 값으로 JSXElement를 넣는 형태
  ```jsx
  const ComponentG = {
  	<A>
  		<B optionalChildren={<>안녕하세요.</>} />
  	</A>
  }
  ```
- 여러 개의 자식도 포함한 형태
  ```jsx
  const ComponentH = {
  	<A>
  		안녕하세요
  		<B text="리액트" />
  	</A>
  }
  ```

## 🖌️ JSX는 어떻게 자바스크립트에서 변환될까?

자바스크립트에서 JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 `@babel/plugin-transform-react-jsx` 플러그인을 알아야 한다.

✅ JSX 코드

```jsx
const ComponentA = <A required={true}>Hello World</A>

const ComponentB = <>Hello World</>

const ComponentC (
	<div>
		<span>hello world</span>
	</div>
)
```

✅ JSX 코드를 `@babel/plugin-transform-react-jsx`로 변환한 결과

```jsx
"use strict";

var ComponentA = React.createElement(
  A,
  {
    required: true,
  },
  "Heelo World"
);
var ComponentB = React.createElement(React.Fragment, null, "Hello World");
var ComponentC = React.createElement(
  "div",
  null,
  React.createElement("span", null, "hello world")
);
```

✅ JSX 코드를 `@babel/plugin-transform-react-jsx`로 변환한 결과( 리액트 17, 바벨 7.9.0 이후 버전에서 추가된 자동 런타임으로 트랜스파일한 결과)

```jsx
"use strict";

var _jsxRuntime = require("custom-jsx-library/jsx-runtime");

var ComponentA = (0, _jsxRuntime.jsx)(A, {
  required: true,
  children: "Hello World",
});
var ComponentB = (0, _jsxRuntime.jsx)(_jsxRuntime.Fragment, {
  children: "Hello World",
});
var ComponentC = (0, _jsxRuntime.jsx)("div", {
  children: (0, _jsxRuntime.jsx)("span", {
    children: "hello world",
  }),
});
```

→ 이 두 차이점은 8장에서 다룰 예정이니 8장을 참고바란다.

@babel/plugin-transform-react-jsx를 직접 써보는 방법도 있다. 아래 코드를 참고하자

```jsx
import * as Babel from "@babel/standalone";

Babel.registerPlugin(
  "@babel/plugin-transform-react-jsx",
  require("@bable/plugin-transform-react-jsx")
);

const BABEL_CONFIG = {
  presets: [],
  plugins: [
    [
      "@bable/plugin-transform-react-jsx",
      {
        throwIfNamespace: false,
        runtime: "automatic",
        importSource: "custom-jsx-library",
      },
    ],
  ],
};

const SOURCE_CODE = `const ComponentA = <A>안녕하세요.</A>`;
// code 변수에 트랜스파일된 결과가 담긴다.
const { code } = Babel.transform(SOURCE_CODE, BABEL_CONFIG);
```

두 결과물에 약간의 차이가 있지만 다른과 같은 공통점도 존재한다.

- JSXElement를 첫 번째 인수로 선언해 요소를 정의한다.
- 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리한다.

→ 이 점을 활용한다면 경우에 따라 다른 JSXElement를 렌더링해야 할 때 굳이 요소 전체를 감싸지 않더라도 처리할 수 있다. 이는 JSXElement만 다르고, JSXAttributes, JSXChildren이 완전히 동일한 상황에서 중복 코드를 최소화할 수 있어 유용하다.

✅ JSX가 변환되는 특성을 활용

```jsx
import { createElement, PropsWithChildren } from "react";

// props 여부에 따라 children 요소만 달라지는 경우
// 굳이 번거롭게 전체 내용을 삼항 연산자로 처리할 필요가 없다.
// 이 경우 불필요한 코드 중복이 일어난다.
function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return isHeading ? (
    <h1 className="text">{children}</h1>
  ) : (
    <span className="text">{children}</span>
  );
}

// JSX가 변환되는 특성을 활용한다면 다음과 같이 간결하게 처리할 수 있다.
import { createElement } from "react";

function TextOrHeading({
  isHeading,
  children,
}: PropsWithChildren<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? "h1" : "span",
    { className: "text" },
    children
  );
}
```

→ JSX 반환값이 결국 `React.createElemen`t로 귀결된다는 사실을 파악한다면 이와 같이 쉽게 리팩터링할 수 있다.

지금까지 JSX에 대해서 자세히 알아보았다. 이 외에도 JSX 문법에는 있지만 실제로 리액트에서 사용하지 않는 것도 있다.

- JSXNamespacedName
- JSXMemberExpression

→ 리액트와는 다르게 JSXNamespacedName, JSXMemberExpression을 목적에 따라 사용할 수도 있으므로 반드시 이러한 스펙도 JSX 문법임을 알아둬야 한다.

❣️리액트 내부에서 JSX가 어떻게 변환되는지, 그리고 어떤 결과물을 만들어내는지 알아두면 향후에 리액트 애플리케이션을 만드는 데 도움이 될 수 있다.

❣️JSX는 물론 대부분의 경우 편리하고 간결하고 컴포넌트를 작성하는 데 많은 도움을 주지만 때에 따라서는 직접 createElement를 사용해 컴포넌트를 구성하는 편이 더 효율적일 수 있다.

# 📑 가상 DOM과 리액트 파이버

리액트는 실제 DOM이 아닌 가상 DOM을 운영한다.

## 🖌️ DOM과 브라우저 렌더링 과정

`DOM`은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

그렇다면 DOM의 정의를 알아보기 전에 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정에 대해 알아보자.

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서이다.
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
   - 레이아웃(layout, reflow) : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정. 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
   - 페인팅(painting) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

[DOM과 CSSOM으로 렌더링 트리가 만들어지는 과정]

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled.png)

👇🏻 다음 예제 코드로 위 과정이 어떻게 일어나는지 확인해보자.

```jsx
#text {
	background-color: red,
	color: white;
}
<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="./style.css" />
		<title>Hello React!</title>
	</head>
	<body>
		<div style="width: 100%;">
			<div id="text" style="width: 50%;">Hello world!</div>
		</div>
	</body>
</html>
```

1. HTML을 다운로드한다. 다운로드와 함께 HTML을 분석하기 시작한다.
2. 스타일시트가 포함된 link 태그를 발견해 style.css를 다운로드한다.
3. body 태그 하단의 div는 width: 100%이므로 뷰포트(브라우저가 사용자에게 노출하는 영역)로 좌우 100% 너비로 잡는다.
4. 3번 하단의 div는 width: 50%, 즉 부모의 50%를 너비로 잡아야 하므로 전체 영역의 50%를 너비로 잡는다.
5. 2번에서 다운로드한 CSS에 id=”text”에 대한 스타일 정보를 결합한다.
6. 화면에 HTML 정보를 그리기 위한 모든 정보가 준비됐으므로 위 정보를 바탕으로 렌더링을 수행한다.

## 🖌️ 가상 DOM의 탄생 배경

요즘 대다수의 앱은 렌더링된 이후 정보를 보여주는 데 그치지 않고 사용자의 인터랙션을 통해 다양한 정보를 노출한다. 즉 렌더링이 완료된 이후에도 사용자의 인터렉션으로 웹페이지가 변경되는 상황 또한 고려해야 한다.

예를들어 보자. 특정한 요소의 색상이 변경되는 경우에는 페인팅만 일어나므로 비교적 빠르게 처리할 수 있다.

하지만 또 다른 경우를 보자. 어떤 특정한 요소의 노출 여부가 변경되거나 사이즈가 변경되는 등 요소의 위치와 크기를 재계산하는 시나리오다. 이 경우에는 레이아웃이 일어나고, 이 레이아웃은 필연적으로 리페인팅이 발생하기 때문에 더 많은 비용이 든다. 또한 DOM 변경이 일어나는 요소가 많은 자식 요소를 가지고 있는 경우에는 하위 자식 요소도 덩달아 변경돼야 하기 때문에 더 많은 비용을 브라우저와 사용자가 지불하게 된다.

이러한 렌더링 이후 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 싱글 페이지 애플리케이션(Single Page Application)에서 더욱 많아진다. 페이지가 변경되는 경우 다른 페이지로 가서 처음부터 HTML을 새로 받아서 다시금 렌더링 과정을 시작하는 일반적인 웹페이지와는 다르게 하나의 페이지에서 계속해서 요소의 위치를 재계산하게 된다.

라우팅이 변경되는 경우 사이드바나 헤더 같은 특정 요소를 제외하고 대부분의 요소를 삭제하고, 다시 삽입하고, 위치를 계산하는 등의 작업을 수행해야 하므로 특히 이러한 과정이 두드러진다.

싱글 페이지 애플리케이션의 특징 덕분에 사용자는 페이지의 깜빡임 없이 자연스러운 웹페이지 탐색을 할 수 있지만 그만큼 DOM을 관리하는 과정에서 부담해야 할 비용이 커진다.

이제 이러한 작업을 개발자 입장에서 보자.

하나의 인터랙션으로 인해 페이지 내부의 DOM의 여러 가지 변경되는 시나리오는 요즘의 웹페이지에서 흔히 볼 수 있다. 하지만 이러한 사용자의 인터랙션에 따라 DOM의 모든 변경 사항을 추적하는 것은 너무마 힘든 일이다.

대부분의 개발자들은 인터랙션에 모든 DOM의 변경보다는 결과적으로 만들어지는 DOM 결과물 하나만 알고 싶어 하기 때문에, DOM의 최종 결과물을 간편하게 제공하는 것은 브라우저뿐만 아니라 개발자에게도 매우 유용하다.

이러한 문제점을 해결하기 위해 탄생한 것이 바로 `가상 DOM`이다. 가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM이다.

가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다. (여기서 말하는 리액트는 정확히 이야기하면 package.json에 있는 react가 아닌 react-dom을 의미한다.)

이렇게 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다면 실제로는 여러 번 발생했을 렌더링 과정을 최소화할 수 있고 브라우저와 개발자의 부담을 덜 수 있다.

가상 DOM에 대한 오해가 한가지 있는데 리액트의 이러한 방식이 일반적인 DOM을 관리하는 브라우저보다 빠르진 않다. 무조건 빠른 것이 아니라 리액트의 이 가상 DOM 방식은 대부분의 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다는 것이다.

## 🖌️ 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 `리액트 파이버(React Fiber)`다.

### 리액트 파이버란?

리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체다. 파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

재조정(reconciliation)은 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)이라고 이해하면 된다.

리액트 파이버의 목표는 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 그리고 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다. 이를 위해 파이버는 다음과 같은 일을 할 수 있다.

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

❣️여기서 중요한 것은 모든 과정이 비동기로 일어난다는 점이다.

과거 리액트의 조정 알고리즘은 스택 알고리즘으로 이뤄져 있었다. 이 알고리즘은 하나의 스택에 렌더링에 필요한 작업들이 쌓이면 이 스택이 빌 때까지 동기적으로 작업이 이루어졌다.

자바스크립트의 특징인 싱글 스레드라는 점으로 인해 이 동기 작업은 중단될 수 없고, 다른 작업이 수행되고 시어도 중단할 수 없어 리액트의 비효율성이 커졌다.

→ ex) <input type=”text” /> 내용으로 자동 검색하는 UI

사용자는 빠르게 검색어를 타이핑할 것이고, 그 결과물이 input뿐만 아니라 자동 검색을 위한 다른 UI나 내부 fetch에도 영향을 미친다. fetch 작업이 수행되면 네트워크 요청이 발생할 것이고, 이에 따라 로딩 스피너도 나타날 것이다. 이러한 작업이 모두 스택에 쌓이게 되면 쌓이는 작업이 많아질수록 리액트는 동기식으로 이를 처리하려고 노력하면서 작업에 많은 시간이 소요될 것이고, 최악의 경우 글자 입력에 지연이 생길수도 있다.

이러한 문제들 때문에 리액트 팀은 스택 조정자 대신 파이어라는 개념을 탄생시켰다.

파이버는 일단 하나의 작업 단위로 구성되어 있다. 리액트는 이러한 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.

그리고 이러한 단계는 다음과 같이 두 단계로 나눌 수 있다.

1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업. 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업. commitWork()가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.

→ 이 두 단계에 대해서는 뒤에 `‘렌더링은 어떻게 일어나는가?’`에서 더 자세하 다뤄볼것이다.

✅ 리액트 내부 코드에 작성돼 있는 파이버 객체

```jsx
function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.refCleanup = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.flags = NoFlags;
  this.subtreeFlags = NoFlags;
  this.deletions = null;

  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  this.alternate = null;

  // 이하 프로파일러, __DEV__ 코드는 생략
}
```

- 단순한 자바스크립트 객체로 구성되어 있다.
- 파이버와 리액트 요소가 유사하게 보이지만 한 가지 중요한 차이점은 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용된다는 사실이다.
- 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.

✅ 파이버 구현체에 선언된 주요 속성

- tag : 파이버를 만드는 함수 이름인 createFiberFromElement를 보면 유추할 수 있겠지만 파이버는 하나의 element에 하나가 생성되는 1:1 관계를 가지고 있다. 여기서 1:1로 매칭된 정보를 가지고 있는 것이 바로 tag이다. 1:1로 연결되는 것은 리액트의 컴포넌트일 수도, HTML의 DOM 노드일 수도, 혹은 다른 어떤 것일 수도 있다. 어떤 값들이 가능한지는 리액트 코드에서 다음과 같이 확인할 수 있다.
  👇🏻 리액트에 작성돼 있는 파이버의 태그가 가질 수 있는 값들
  ```jsx
  var FunctionComponent = 0;
  var ClassComponent = 1;
  var IndeterminateComponent = 2;
  var HostRoot = 3;
  var HostPortal = 4;
  var HostComponent = 5;
  var HostText = 6;
  var Fragment = 7;
  var Mode = 8;
  var ContextConsumer = 9;
  var ContextProvider = 10;
  var ForwardRef = 11;
  var Profiler = 12;
  var SuspenseComponent = 13;
  var MemoComponent = 14;
  var SimpleMemoComponent = 15;
  var LazyComponent = 16;
  var IncompleteClassComponent = 17;
  var DehydratedFragment = 18;
  var SuspenseListComponent = 19;
  var ScopeComponent = 21;
  var OffscreanComponent = 22;
  var LegacyHiddenComponent = 23;
  var CacheComponent = 24;
  var TracingMarkerComponent = 25;
  ```
  → HostComponent는 웹의 div와 같은 요소를 의미한다.
- stateNode : 이 속성에서는 파이버 자체에 대한 참조(reference) 정보를 가지고 있으며, 이 참조를 바탕으로 리액트는 파이버와 관련된 상태에 접근한다.
- child, sibling, return : 파이버 간의 관계 개념을 나타내는 속성이다. 리액트 컴포넌트 트리가 형성되는 것과 동일하게 파이버도 트리 형식을 갖게 되는데, 이 트리 형식을 구성하는 데 필요한 정보가 이 속성 내부에 정의된다. 한 가지 리액트 컴포넌트 트리와 다른 점은 children이 없다는 것, 즉 하나의 child만 존재한다는 점이다. 그렇다면 다음과 같이 여러 개의 자식이 있는 구조는 파이버로 어떻게 표현될까?

  ```jsx
  <ul>
    <li>하나</li>
    <li>둘</li>
    <li>셋</li>
  </ul>
  ```

  - 파이버의 자식은 항상 첫 번째 자식의 참조로 구성되므로 <ul /> 파이버의 자식은 첫 번째 <li /> 파이버가 된다. 그리고 나머지 두 개의 <li /> 파이버는 형제, 즉 sibling으로 구성된다. 마지막으로 return은 부모 파이버를 의미하며, 여기에서 모든 <li /> 파이버는 <ul /> 파이버를 return으로 갖게 될 것이다.
  - 말로 설명하면 복잡하니 아래 코드를 보자.

    ```jsx
    const l3 = {
      return: ul,
      index: 2,
    };

    const l2 = {
      sibiling: l3,
      return: ul,
      index: 1,
    };

    const l1 = {
      sibling: l2,
      return: ul,
      index: 0,
    };

    const ul = {
      //...
      child: l1,
    };
    ```

    - index : 여러 형제들(sibling) 사이에서 자신의 위치가 몇 번째인지 숫자로 표현한다.
    - pendingProps : 아직 작업을 미처 처리하지 못한 props
    - memoizedProps : pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps로 저장해 관리한다.
    - updateQueue : 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐, 이 큐는 대략 다음과 같은 구조를 가지고 있다.
      ```jsx
      type UpdateQueue = {
      	first: Update | null
      	last : Update | null
      	hasForceUpdate: boolean
      	callbackList: null | Array<Callback>  //setState로 넘긴 콜백 목록
      }
      ```
    - memoizedState : 함수 컴포넌트의 훅 목록이 저장된다. 여기에는 단순히 useState뿐만 아니라 모든 훅 리스트가 저장된다.
    - alternate : 뒤이어 설명할 리액트 파이버 트리와 이어질 개념. 리액트의 트리는 두 개인데, 이 alternate는 반대편 트리파이버를 가리킨다.

→ 이렇게 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다.

→ 또한 리액트가 파이버를 처리할 때마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다.

→ 즉, 이러한 작업들은 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 가능한 한 빠르게 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리된다.

리액트 팀은 리액트를 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라고 얘기한 적이있는데, 파이버의 객체 값에서도 알 수 있듯이 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다. 변수에 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트이다.

### 리액트 파이버 트리

파이버 트리는 리액트 내부에서 두 개가 존대하는데 하나는 현재 모습을 담은 `파이버 트리`이고, 다른 하나는 작업 중인 상태를 나타내는 `workInProgress 트리`다.

리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. 이러한 기술을 `더블 버퍼링`이라고 한다.

`더블 버퍼링`은 리액트에서 새롭게 나온 개념이 아니고 컴퓨터 그래픽 분야에서 사용하는 용어이다.

그래픽을 통해 화면에 표시되는 것을 그리기 위해서는 내부적으로 처리를 거쳐야 하는데, 이러한 처리를 거치게 되면 사용자에게 미처 다 그리지 못한 모습을 보는 경우가 발생하게 된다. (한 번에 모든 작업을 마무리해 다 그릴 수 없기 때문)

그래서 이러한 상황을 방지하기 위해 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 의미한다.

리액트에서도 미처 다 그리지 못한 모습을 노출시키지 않기 위해(불완전한 트리를 보여주지 않기 위해) 더블 버퍼링 기법을 쓰는데, 이러한 더블 버퍼링을 위해 트리가 두 개 존재하며, 이 더블 버퍼링은 커밋 단계에서 수행된다.

즉, 1. 먼저 현재 UI 렌더링을 위해 존재하는 트리인 current를 기준으로 모든 작업이 시작된다.

1. 여기서 만약 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 workInProgress 트리를 빌드하기 시작한다.
2. 이 workInProgress 트리를 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.
3. 그리고 이 workInProgress 트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 current가 이 workInProgress로 변경된다.

### 파이버의 작업 순서

✅ 일반적인 파이버 노드의 생성 흐름

1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

```jsx
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1 />
      <D2 />
    </C1>
  </B2>
</A1>
```

이 코드가 JSX 코드에서 어떻게 수행되는지 확인해보자.

1. A1의 `beginWork()`가 수행된다.
2. A1은 자식이 있으므로 B1로 이동해 `beginWork()`를 수행한다.
3. B1은 자식이 없으므로 `completeWork()`가 수행됐다. 자식은 없으므로 형제인 B2로 넘어간다.
4. B2의 `beginWork()`가 수행된다. 자식이 있으므로 C1으로 이동한다.
5. C1의 `beginWork()`가 수행된다. 자식이 있으므로 D1으로 이동한다.
6. D1의 `beginWork()`가 수행된다.
7. D1은 자식이 없으므로 `completeWork()`가 수행됐다. 자식은 없으므로 형제인 D2로 넘어간다.
8. D2는 자식이 없으므로 `completeWork()`가 수행됐다.
9. D2는 자식도 더 이상의 형제도 없으므로 위로 이동해 D1, C1, B2 순으로 `completeWork()`를 호출한다.
10. B2는 형제인 B3으로 이동해 `beginWork()`를 수행한다.
11. B3의 `completeWork()`가 수행되면 반환해 상위로 타고 올라간다.
12. A1의 `completeWork()`가 수행된다.
13. 루트 노드가 완성되는 순간, 최종적으로 `commitWork()`가 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영된다.

이제 여기서 setState 등으로 업데이트가 발생하면 리액트는 앞에서 만든 current 트리가 존재하고, setState로 인한 업데이트 요청을 받아 workInProgress 트리를 다시 빌드하기 시작한다. → 빌드 과정은 트리 만드는 과정과 동일하다.

최초 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만 이제는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.

반복적인 재조정 작업 때마다 새롭게 파이버 자바스크립트 객체를 만드는 것은 리소스 낭비라고 볼 수 있다. 따라서 가급적 객체를 새롭게 만들기보다는 기존에 있는 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.

과거 동기식으로 처리했다는 작업이 바로 이 작업이다. 이 트리 업데이트 과정, 재귀적으로 하나의 트리를 순회해 새로운 트리를 만드든 작업은 동기식이고 중단될 수 없었다. 그러나 현재는 우선순위가 높은 다른 업데이트가 오면 현재 업데이트 작업을 일시 중단하거나 새롭게 만들거나, 폐기할 수도 있다.

또한 작업 단위를 나누어 우선순위를 할당하는 것 또한 가능하다. 리액트는 이러한 작업을 파이버 단위로 나눠서 수행한다.

- 애니메이션이나 사용자가 입력하는 작업은 우선순위가 높은 작업으로 분리하거나, 목록을 렌더링하는 등의 작업은 우선순위가 낮은 작업으로 분리해 최적의 순위로 작업을 완료할 수 있게끔 만든다.

## 🖌️ 파이버의 가상 DOM

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다. 이러한 비동기 작업과 달리, 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 또 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상에서, 즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

# 📑 클래스 컴포넌트와 함수 컴포넌트

함수 컴포넌트는 함수 컴포넌트에 훅이 등장한 이후 함수 컴포넌트에서 상태나 생명주기 메서드 비슷한 작업을 흉내 낼 수 있게 되어 보일러플레이트가 복잡한 클래스 컴포넌트보다 함수 컴포넌트를 더 많이 쓰기 시작했다.

- 함수 컴포넌트에서는 생명주기 메서드를 어떻게 써야 할까?
- 기존에 클래스 컴포넌트로 작성돼 있던 코드는 모두 함수 컴포넌트로 변경해야 할까?
- 클래스 컴포넌트는 언젠가 지원 중단(deprecated)되는 것일까?
- 클래스 컴포넌트는 이제 몰라도 되는 걸까?

이와 같은 의문점이 들테니 아래에서 클래스 컴포넌트와 함수 컴포넌트의 차이는 무엇인지, 그리고 각각의 컴포넌트를 작성할 때 고려해야 할 것이 무엇인지 다뤄보자.

## 🖌️ 클래스 컴포넌트

아마 리액트 16.8 미만으로 작성된 코드에는 클래스 컴포넌트가 대다수일 것이다. 따라서 이런 오래된 코드의 유지보수 내지는 오래전에 개발된 라이브러리 등을 사용할 때 도움을 얻기 위해서는 기본적인 클래스 컴포넌트의 구조를 이해할 필요가 있다.

```jsx
import React from "react";

class SampleComponent extends React.Component {
  render() {
    return <h2>Sample Component</h2>;
  }
}
```

기본적으로 클래스 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends해야한다. extends 구문에 넣을 수 있는 클래스는 다음과 같다.

- React.Component
- React.PureComponent

→ 이 둘의 차이점은 `shouldComponentUpdate` 컴포넌트를 다루는 게 있다. 그 부분은 아래에서 알아볼 것이다.

컴포넌트를 만들 때 주로 쓰이는 props, state, 메서드는 다음과 같이 정의한다.

✅ 클래스 컴포넌트 예제

```jsx
import React from 'react'

// props 타입을 선언한다.
interface SampleProps {
	required?: boolean
	text: string
}

// state 타입을 선언한다.
interface SampleState {
	count: number
	isLimited?: boolean
}

// Component에 제네릭으로 props, state를 순서대로 넣어준다.
class SampleComponent extends React.Component<SampleProps, SampleState> {
	// constructor에서 props를 넘겨주고, state의 기본값을 설정한다.
	private constructor(props: SampleProps) {
		super(props)
		this.state = {
			count: 0,
			isLimited: false,
		}
	}

	// render 내부에서 쓰일 함수를 선언한다.
	private handleClick = () => {
		count newValue = this.state.count + 1
		this.setState({ count: newValue, isLimited: newValue >= 10 })
	}

	// render에서 이 컴포넌트가 렌더링할 내용을 정의한다.
	public render() {
		// props와 state 값을 this, 즉 해당 클래스에서 꺼낸다.
		const {
			props: { required, text },
			state: { count, isLimited },
		} = this

		return (
			<h2>
				Sample Component
				<div>{required ? '필수' : '필수아님'}</div>
				<div>문자: {text}</div>
				<div>count: {count}</div>
				<button onClick={this.handleClick} disabled={isLimited}>
					증가
				</button>
			</h2>
		)
```

- constructor() : 컴포넌트 내부에 이 생성자 함수가 있다면 컴포넌트가 초기화되는 시점에 호출된다. 여기서는 컴포넌트의 state를 초기화할 수 있다. 그리고 여기에 선언돼 있는 super()는 컴포넌트를 만들면서 상속받은 상위 컴포넌트, 즉 React.Component의 생성자 함수를 먼저 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.
  🥕 constuctor가 없어도 state를 초기화할 수 있다??!!

  ```jsx
  import { Component } from "react";

  class SampleComponent2 extends Component {
    state = {
      count: 1,
    };

    render() {
      const {
        state: { count },
      } = this;
      return <div>{count}</div>;
    }
  }
  ```

  이 코드처럼 constructor를 쓰지 않고 state를 초기화한 코드를 볼 수 있다.
  이는 ES2022에 추가된 클래스 필드(class fields) 덕분에 가능한 문법이다. 이 문법은 별도의 초기화 과정을 거치지 않고도 클래스 내부에 필드를 선언할 수 있게 도와준다. 이 문법은 비교적 최신인 ES2022에 등장했으므로 ES2022 환경을 지원하는 브라우저에서만 코드를 제공하거나 바벨의 @babel/plugin-proposal-class-properties를 사용해 트랜스파일을 거쳐야 한다.

- props : 함수에 인자를 넣는 것과 비슷하게, 컴포넌트에 특정 속성을 전달하는 용도로 쓰인다. 위 예제에서는 props가 { required?: boolean; text: string; } 형태로 선언돼 있으므로 해당 컴포넌트를 호출하기 위해서는 <SampleComponent text=”안녕하세요” />와 같은 형태로 선언해야 한다.
- state : 클래스 컴포넌트 내부에서 관리하는 값을 의미한다. 이 값은 항상 객체여야만 한다. 이 값에 변화가 있을 때마다 리렌더링이 발생한다.
- 메서드 : 렌더링 함수 내부에서 사용되는 함수이며, 보통 DOM에서 발생하는 이벤트와 함께 사용된다. 이를 만드는 방식은 크게 3가지로 나뉜다.

  - constructor에서 this 바인드를 하는 방법 : 일반적인 함수로 메서드를 만든다면 this가 undefined로 나오는 현상을 겪게 될 것이다. 이러한 현상이 발생하는 이유는 생성자가 아닌 일반 함수로 호출하게 되면 this에 전역 객체(strict 모드에서는 undefined)가 바인딩되기 때문이다. 따라서 생성된 함수에 bind를 활용해 강제로 this를 바인딩해야 한다.

    아래 예제는 일반 함수로 선언한 대신 this 바인딩을 사용했다.

    ```jsx
    import { Component } from 'react'

    // 빈 Props를 선언
    type Props = Record<string, never>

    interface State {
    	count: number
    }

    class SampleComponent extends Component<Props, State> {
    	private constructor(props: Props) {
    		super(props)
    		this.state = {
    			count: 1,
    		}
    		// handleClick의 this를 현재 클래스로 바인딩한다.
    		this.handleClick = this.handleClick.bind(this)
    	}

    	private handleClick() {
    		this.setState((prev) => ({ count: prev.count + 1 }))
    	}

    	public render() {
    		const {
    			state: { count },
    		} = this
    		return (
    			<div>
    				<button onclick={this.handleClick}>증가</button>
    				{count}
    			</div>
    		)
    	}
    }
    ```

  - 화살표 함수를 쓰는 방법 : 위 예제처럼 실행 시점이 아닌 작성 시점에 this가 상위 스코프로 결정되는 화살표 함수를 사용한다면 굳이 바인딩하지 않더라도 사용할 수 있다.
  - 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법 : 다음과 같이 메서드 내부에서 새롭게 함수를 만들어서 전달하는 방법이다.
    ```jsx
    <button onclick={() => this.handleClick()}>증가</button>
    ```
    ❣️ 그러나 이 방법을 사용하게 되면 매번 렌더링이 일어날 때마다 새로운 함수를 생성해서 할당하게 되므로 최적화를 수행하기가 어려워진다. 따라서 이 방법은 지양하는 것이 좋다.

### 클래스 컴포넌트의 생명주기 메서드

클래스 컴포넌트를 사용하면서 가장 자주 언급되는 것이 바로 생명주기(life cycle)이다. 함수 컴포넌트가 대세가 되면서 많이 잊혀졌지만 여전히 클래스 컴포넌트의 많은 코드가 생명주기 메서드에 의존하고 있다.

그러니까 우리도 클래스 컴포넌트의 생명주기에는 무엇이 있고, 또 어떤 용도로 쓰였는지 살펴보자. (`❣️리액트 17로 넘어오면서 unsafe(안전하지 않다고 선언된 메서드)에 대해서는 다루지 않는다`)

우선 생명주기 메서드가 실행되는 시점은 크게 3가지로 나눌 수 있다.

- 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

**render()**

render()도 생명주기 메서드 중 하나로, 리액트 클래스 컴포넌트의 유일한 필수 값으로 항상 쓰인다.

이 함수는 컴포넌트가 UI를 렌더링하기 위해서 쓰인다. 그리고 이 렌더링은 앞서 언급한 시점 중 두 가지인 마운트와 업데이트 과정에서 일어난다.

❣️주의사항

render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다.(no side-effects)

→ 같은 입력값(props 또는 state)이 들어가면 항상 같은 결과물을 반환해야 하며, render() 내부에서 state를 직접 업데이트하는 this.setState를 호출해서는 안된다.

state를 변경하는 일은 클래스 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야 한다.

**componentDidMount()**

클래스 컴포넌트가 마운트되고 준비가 되었다면 그 다음으로 호출되는 생명주기 메서드이다.

이 함수는 컴포넌트가 마운트되고 준비되는 즉시 실행된다.

render()와는 다르게, 이 함수 내부에서는 this.setState()로 state 값을 변경하는 것이 가능하다.

this.setState를 호출했다면 state가 변경되고, 그리고 그 즉시 다시 한번 렌더링을 시도하는데, 이 작업은 브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.

❣️주의사항

componentDisMount()는 성능 문제를 일으킬 수 있어 주의해야 한다.

일반적으로는 state를 다루는 것은 생성자에서 하는 것이 좋다. componentDidMount에서 this.setState를 허용하는 것은 생성자 함수에서는 할 수 없는 것, API 호출 후 업데이트, DOM에 의존적인 작업(이벤트 리스너 추가 등) 등을 하기 위해서다.

componentDidMount에서 할 수 밖에 없는 작업인지 철저히 확인해 보고 사용하자.

**componentDidUpdate()**

componentDidUpdate()는 컴포넌트 업데이트가 일어난 이후 바로 실행된다. 일반적으로 state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다.

여기서도 this.setState를 사용할 수 있다. 하지만 적절한 조건문으로 감싸지 않는다면 this.setState가 계속해서 호출되는 일이 발생할 수 있다(성능에 좋지 않음).

```jsx
componentDisUpdate(prevProps: Props, prevState: State) {
	// 만약 이러한 조건문이 없다면 props가 변경되는 매 순간마다 fetchData가 실행되는 불상사가 발생할 것이다.
	// 이 조건문 덕분에 props의 userName이 이전과 다른 경우에만 호출될 것이다.
	if (this.props.userName !== prevProps.userName) {
		this.fetchData(this.props.userName);
	}
}
```

**componentWillUnmount()**

이 생명주기 메서드는 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.

메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다. 이 메서드내에서는 this.setState를 호출할 수 없다.

```jsx
componentWillUnmount() {
	window.removeEventListener('resize', this.resizeListener)
	clearInterval(this.intervalId)
}
```

이 예제와 같이 이벤트를 지우거나, API 호출을 취소하거나, setInterval, setTimeout으로 생성된 타이머를 지우는 등의 작업을 하는데 유용하다.

shouldComponentUpdate()

state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 된다.

기본적으로 this.setState가 호출되면 컴포넌트는 리렌더링을 일으킨다.

하지만 이 생명주기 메서드를 활용하면 컴포넌트에 영향을 받지 않는 변화에 대해 정의할 수 있다.

일반적으로 state의 변화에 따라 컴포넌트가 리렌더링되기 때문에 이 메서드를 사용하는 것은 특정한 성능 최적화 상황에서만 고려해야 한다.

```jsx
shouldComponentUpdate(nextProps: Props, nextState: State) {
	// true인 경우, 즉 props의 title이 같지 않거나 state의 input이 같지 않은 경우에는
	// 컴포넌트를 업데이트한다. 이외의 경우에는 업데이트하지 않는다.
	return this.props.title !== nextProps.title || this.state.input !== nextState.input
}
```

앞에서 클래스 컴포넌트 유형에는 두 가지, 즉 Component와 PureComponent가 있다고 했는데, 이 둘의 차이점이 이 생명주기를 다루는 데 있다.

다음의 두 컴포넌트를 비교해보자. 두 컴포넌트 모두 버튼을 클릭하면 count를 1씩 올려주지만 정작 해당 값은 사용하지 않는다. 각각 다르게 컴포넌트를 만들었을 경우 렌더링이 어떻게 일어나는지 확인할 수 있다.

✅ React.Component와 React.PureComponent로 컴포넌트를 만드는 예제

```jsx
import React from 'react'

interface State {
	count: number
}

type Props = Record<string, never>

export class ReactComponent extends React.Component<Props, State> {
	private renderCounter = 0

	private constructor(props: Props) {
		super(props)
		this.state = {
			count: 1,
		}
	}

	private handleClick = () => {
		this.setState({ count: 1 })
	}

	public render() {
		console.log('ReactComponent', ++this.renderCounter) // eslint-disable-line no-console
		return (
			<h1>
				ReactComponent: {this.state.count}{' '}
				<button onClick={this.handleClick}>+</button>
			</h1>
		)
	}
}

export class ReactPureComponent extends React.PureComponent<Props, State> {
	private renderConter = 0

	private constructor(props: Props) {
		super(props)
		this.state = {
			count: 1,
		}
	}

	private handleClick = () => {
		this.setState({ count: 1 })
	}

	public render() {
		console.log('ReactPureComponent', ++this.renderCounter) // eslint-disable-line no-console
		return (
			<h1>
				ReactPureComponent: {this.state.count}{' '}
				<button onclick={this.handleClick}>+</button>
			</h1>
		)
	}
}

export default function CompareComponent() {
	return (
		<>
			<h2>React.Component</h2>
			<ReactComponent />
			<h2>React.PureComponent</h2>
			<ReactComponent />
		</>
	)
}
```

- 위 코드는 state로 count를 가지고있고, 버튼을 클릭하면 해당 count 값을 초깃값과 같은 count인 1로 다시 세팅하였다. 그리고 이 과정에서 render()가 몇 번이나 호출됐는지 확인하기 위해 별도의 필드를 추가했다.

1. Component의 경우 버튼을 누르는 대로, 즉 sate가 업데이트되는 대로 렌더링이 일어나지만 PureComponent는 state의 값이 업데이트되지 않아서 렌더링이 일어나지 않는다. PureComponent는 state 값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행한다.
2. 그렇다고 모든 컴포넌트를 PureComponent로 선언하는 것은 좋지 않다.

   그 이유는 PureComponent는 먼저 얕은 비교만 수행하기 때문에 state가 객체와 같이 복잡한 구조의 데이터 변경은 감지하지 못하기 때문에 제대로 작동하지 않는다.

   또한 애플리케이션에서 대다수의 컴포넌트가 PureComponenet로 구성돼 있다면 오히려 성능에 역효과를 미칠 수도 있다. 왜냐하면 만약 컴포넌트가 얕은 비교를 했을 때 일치하지 않는 일이 더 잦다면 이러한 비교는 무의미하기 때문이다.

3. 따라서 PureComponent는 필요한 곳에 적재적소에 활용하는 것이 애플리케이션 성능에 도움이 된다.

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%201.png)

static getDerivedStateFromProps()

가장 최근에 도입된 생명주기 메서드 중 하나로, 현재는 사라진 `componentWillReceiveProps`를 대체할 수 있는 메서드다.

이 메서드는 render()를 호출하기 직전에 호출된다.

또한 static으로 선언돼 있어 this에 접근할 수 없다. 여기서 반환하는 객체는 해당 객체의 내용이 모두 state로 들어가게 되며 null을 반환하면 아무런 일도 일어나지 않는다.

❣️주의사항

모든 render() 실행 시에 호출된다.

```jsx
static getDerivedStateFromProps(nextProps : Props, prevState: State) {
	// 이 메서드는 다음에 올 props를 바탕으로 현재의 state를 변경하고 싶을 때 사용할 수 있다.

	if (props.name !== state.name) {
		// state가 이렇게 변경된다.
		return {
			name: props.name
		}
	}

	// state에 영향을 미치지 않는다.
	return null
}
```

getSnapShotBeforeUpdate()

가장 최근에 도입된 생명주기 메서드 중 하나로, `componentWillUpdate()`를 대체할 수 있는 메서드다.

반환되는 값이 componentDidUpdate로 전달된다.

DOM에 렌더링되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는 데 유용하다.

```jsx
getSnapShotBeforeUpdate(prevProps: Props, prevState: State) {
	// props로 넘겨받은 배열의 길이가 이전보다 길어질 경우 현재 스크롤 높이 값을 반환한다.
	if (prevProps.list.length < this.props.list.length) {
		const list = this.listRef.current;
		return list.scrollHeight - list.scrollTop;
	}
	return null;
}

// 3번째 인수인 snapshot은 클래스 제네릭의 3번째 인수로 넣어줄 수 있다.
componentDidUpdate(provProps: Props, prevState: State, snapshot: Snapshot) {
	// getSnapshotBeforeUpdate로 넘겨받은 값은 snapshot에서 접근이 가능하다.
	// 이 snapshot 값이 있다면 스크롤 위치를 재조정해 기존 아이템이 스크롤해서 밀리지 않도록 도와준다.
	if (snapshot !== null) {
		const list = this.listRef.current;
		list.scrollTop = list.scrollHeight - snapshot;
	}
}

```

✅ 리액트 생명주기 다이어그램

- https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%202.png)

getDerivedStateFromError()

이 메서드와 `componentDidCatch` 메서드는 정상적인 생명 주기에서 실행되는 메서드가 아니라 에러 상황에서 실행되는 메서드이다.

또한 `getSnapshotBeforeUpdate`는 아직 리액트 훅으록 구현돼 있지 않기 때문에 이 세가지 메서드가 필요한 경우가 있다면 반드시 클래스 컴포넌트를 사용해야 한다.

이 메서드는 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드이다. 이 에러 메서드를 사용하면 적절한 에러 처리 로직을 구현할 수 있다.

```jsx
// ErrorBoundary.tsx
import React, { PropsWithChildren } from "react";

type Props = PropsWithChildren<{}>;
type State = { hasError: boolean, errorMessage: string };

export default class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      errorMessage: "",
    };
  }

  static getDerivedStateFromError(error: Error) {
    return {
      hasError: true,
      errorMessage: error.toString(),
    };
  }

  render() {
    // 에러가 발생했을 경우에 렌더링할 JSX
    if (this.state.hasError) {
      return (
        <div>
          <h1>애러가 발생했습니다.</h1>
          <p>{this.state.errorMessage}</p>
        </div>
      );
    }

    // 일반적인 상황의 JSX
    return this.props.children;
  }
}

// App.tsx
function App() {
  return (
    <ErrorBoundary>
      <Child />
    </ErrorBoundary>
  );
}

function Child() {
  const [error, setError] = useState(false);

  const handleClick = () => {
    setError((prev) => !prev);
  };

  if (error) {
    throw new Error("Error has been occurred.");
  }

  return <button onClick={handleClick}>에러 발생</button>;
}
```

getDerivedStateFromError는

- static 메서드로, error를 인스로 받는다. error는 하위 컴포넌트에서 발생한 에러를 말한다.
- 실행 시점 때문에 반드시 state 값을 반환해야 한다.
- 하위 컴포넌트에서 에러가 발생했을 경우에 어떻게 자식 리액트 컴포넌트를 렌더링할지 결정하는 용도로 제공되는 메서드이기 때문에 반드시 미리 정의해 둔 state 값을 반환해야 한다.
- 렌더링 과정에서 호출되는 메서드이기 때문에 부수 효과를 발생시켜서는 안 된다.
  `부수효과란? 에러에 따른 상태 state를 반환하는 것 외의 모든 작업을 의미한다(console.error를 이용한 에러 로깅도 포함)` → 이러한 작업을 하고 싶다면 `componentDidCatch`를 사용

componentDidCatch

componentDidCatch는 자식 컴포넌트에서 에러가 발생했을 때 실행되며, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다.

componentDidCatch는 두 개의 인수를 받는데, 첫 번째는 getDerivedStateFromError와 동일한 error, 두번째는 정확히 어떤 컴포넌트가 에러를 발생시켰는지 정보를 가지고 있는 info이다.

```jsx
import React, { ErrorInfo, PropsWithChildren } from "react";

type Props = PropsWithChildren<{}>;
type State = { hasError: boolean, errorMessage: string };

export default class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      errorMessage: "",
    };
  }

  static getDerivedStateFromError(error: Error) {
    return {
      hasError: true,
      errorMessage: error.toString(),
    };
  }

  // componentDidCatch를 추가했다.
  componentDidCatch(error: Error, info: ErrorInfo) {
    console.log(error);
    console.log(info);
  }

  render() {
    // 에러가 발생했을 경우에 렌더링할 JSX
    if (this.state.hasError) {
      return (
        <div>
          <h1>애러가 발생했습니다.</h1>
          <p>{this.state.errorMessage}</p>
        </div>
      );
    }

    // 일반적인 상황의 JSX
    return this.props.children;
  }
}
```

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%203.png)

- componentDidCatch에서는 getDerivedStateFromError()에서 하지 못했던 부수 효과를 수행할 수 있다. 왜냐하면 render 단계에서 실행되는 getDerivedStateFromError와는 다르게 componentDidCatch는 커밋 단계에 실행되기 때문이다.
- 즉 componentDidCatch는 리액트에서 에러 발생 시 이 메서드에서 제공되는 에러 정보를 바탕으로 로깅하는 등의 용도로 사용할 수 있다.

- 일반적으로 앞의 두 메서드는 ErrorBoundary, 즉 에러 경계 컴포넌트를 만들기 위한 목적으로 많이 사용된다.
- 두 메서드를 사용한 클래스 컴포넌트는 리액트 애플리케이션 전역에서 처리되지 않은 에러를 잡기 위한 용도로 사용되지만 ErrorBoundary로 모든 에러를 잡을 수는 없다.
  → ErrorBoundary는 애플리케이션 루트에서 사용되지만 ErrorBoundary의 경게 외부에 있는 에러는 잡을 수 없다. 이 외부에서 발생한 에러는 또 다른 ErrorBoundary가 찾아갈 것이며, 찾지 못하면 자바스크립트 코드처럼 throw 될 것이다.
- 즉 ErrorBoundary를 여러 개 선언해서 컴포넌트별로 에러 처리를 다르게 적용할 수 있다는 의미도 된다. 이렇게 하면 에러가 발생한 컴포넌트 트리 영역만 별도로 처리해서 애플리케이션 전체에 에러가 전파되어 표시되는 것을 방지할 수 있다.

```jsx
function App() {
  return (
    <ErrorBoundary name="parent">
      {/* Child에서 발생한 에러는 여기에서 잡힌다. */}
      <ErrorBoundary name="child">
        <Child />
      </ErrorBoundary>
    </ErrorBoundary>
  );
}
```

❣️ErrorBoundary에서 주의사항

componentDidCatch는 개발 모드와 프로덕션 모드에서 다르게 작동한다. 개발 모드에서는 에러가 발생하면 window까지 전파된다.

즉, window.eonerror나 window.addEventListner(’error’, callback)과 같은 메서드가 componentDidCatch에서 잡은 오류를 마찬가지로 잡을 수 있다.

하지만 프로덕션 모드에서는 componentDidCatch로 잡히지 않은 에러만 window까지 전파된다.

→ 개발 모두에서 발생한 에러를 개발자들에게 확실히 확인시켜 주기 위한 역할인것 같다.

```jsx
useEffect(() => {
	// 개발 모드에서는 모든 에러에 대해 실행되지만
	// 프로덕션에서는 잡히지 않는 에러에 대해서만 실행된다.
	function handleError() {
		console.log('window on error')
	}
	window.addEventListener('error', handleError)
	return () => {
		window.removeEventListener('error', handleError(
	}
}, [])
```

→ componentDidCatch의 두 번째 인수인 errorInfo의 componentStack은 어느 컴포넌트에서 에러가 발생했는지 알 수 있는 단서를 제공하기 위한 목적으로 만들어졌다.

### 클래스 컴포넌트의 한계

클래스 컴포넌트의 어떠한 문제점 때문에 함수 컴포넌트에 훅을 도입한 새로운 패러다임을 만들었는지 알아보자.

- 데이터의 흐름을 추적하기 어렵다 : 앞에서 다룬 생명주기 메서드를 보면 state의 흐름을 추적하기가 매우 어렵다는 것을 알 수 있다. 서로 다은 여러 메서드에서 state의 업데이트가 일어날 수 있으며, 또 코드 작성 시 메서드의 순서가 강제돼 있는 것이 아니기 때문에 사람이 읽기가 매우 어렵다. 무론 생명주기 메서드는 실행되는 순서가 있지만 클래스에 작성할 때는 메서드의 순서를 맞춰줘야 하는 것은 아니기 때문에 주의를 기울이지 않는다면 생명주기 메서드의 순서와 상관없이 코드가 작성돼 있을 수 있다. 즉, 코드를 읽는 과정에서는 숙련된 개발자라도 state가 어떤 식의 흐름으로 변경돼서 렌더링이 일어나는지 혹은 일어나지 않는지 판단하기 어렵다.
- 애플리케이션 내부 로직의 재사용이 어렵다 : 컴포넌트 간에 중복되는 로직이 있고, 이를 재사용하고 싶을 때 사용할 수 있는 것은 컴포넌트를 또 다른 고차 컴포넌트(Higher Order Component)로 감싸거나, props를 넘겨주는 방식이 있다. 러나 두가지 모두 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트나 props가 많아지는 래퍼 지옥(wrapper hell)에 빠져들 위험성이 커지는 단점이 있다. 애플리케이션의 규모가 커질수록 재사용할 로직도 많아지는데, 이를 클래스 컴포넌트 환경에서 매끄럽게 처리하기란 쉽지 않다. 물론 extends PureComponent와 같이 컴포넌트를 상속해서 중복 코드를 관리할 수 있지만, 이 역시 상속되고 있는 클래스의 흐름을 쫓아야 하기 때문에 복잡도가 증가하고 코드의 흐름을 쫓기가 쉽지 않다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다 : 컴포넌트 내부에 로직이 많아질수록, 또 내부에서 처리하는 데이터 흐름이 복잡해져 생명주기 메서드 사용이 잦아지는 경우 컴포넌트의 크기가 기하급수적으로 커지는 문제가 발생한다.
- 클래스는 함수에 비해 상대적으로 어렵다 : 프로토타입 기반의 언어인 자바스크립트의 특징으로 인해 클래스는 비교적 뒤 늦게 나온 개념이라, 많은 자바스크립트 개발자는 클래스보다는 함수에 더 익숙하다. 그리고 자바스크립트 환경에서는 함수에 비해 클래스의 사용이 비교적 어렵고 일반적이지 않다. 대부분의 언어와 다르게 작동하는 this를 비롯한 자바스크립트의 작동 방식은 클래스 컴포넌트를 처음 접하는 사람, 자바스크립트를 조금 해본 사람도 모두 혼란에 빠지게 할 수 있다.
- 코드 크기를 최적화하기 어렵다 : 클래스 컴포넌트는 최종 결과물인 번들 크기를 줄이는 데도 어려움을 겪는다.

  ```jsx
  import React from 'react'

  interface State {
  	count: number
  }

  type Props = Record<string, never>

  export class ReactPureComponent extends React.PureComponent<Props, State> {
  	private constructor(props: Props) {
  		super(props)
  		this.state = {
  			count: 1,
  		}
  	}

  	private handleClick = () => {
  		console.log('handleClick!')  // eslint-disable-line no-console

  		this.setState({ count: 1 })
  	}

  	private handleChange = () => {
  		console.log('handleChange!')  // eslint-disable-line no-console
  	}

  	public render() {
  		return (
  			<h1>
  				ReactPureComponent: {this.state.count}{' '}
  				<button onClick={this.handleClick}>+</button>
  			</h1>
  		)

  ```

  - 이 예제는 PureComponent로, handleClick과 handleChange가 존재하는데, handleChange는 사용되지 않고 있는 예제이다. 그렇다면 이를 빌드한 결과를 확인해보자.
    ✅ 클래스 컴포넌트와 그 빌드 결과

  ```jsx
  function u(e) {
    var n;
    return (
      (function (e, n) {
        if (!(e instanceof n))
          throw new TypeError("Cannot call a class as a function");
      })(this.u),
      ((n = o.call(this, e)).handleClick = function () {
        console.log("handleClick!"),
          n.setState({
            count: 1,
          });
      }),
      (n.handleChange = function () {
        console.log("handleChanged!");
      }),
      (n.state = {
        count: 1,
      }),
      n
    );
  }
  ```

  - handleChange와 handleClick의 이름이 최소화되지 않았고, 사용하지 않는 메서드인 handleChange도 트리 쉐이킹이 되지 않고, 번들에 그대로 포함되는 것을 볼 수 있다. 즉, 클래스 컴포넌트는 번들링을 최적화하기에 불리한 조건임을 알 수 있다.

- 핫 리로딩을 하는 데 상대적으로 불리하다 : 핫 리로딩(hot reloading)이란 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법을 말한다. 흔히 이 기능은 빌드해서 실행하는게 아닌 개발 단계에서 많이 사용된다. 애플리케이션을 실행한 코드의 수정 내용이 바로 바로 반영되는 것이 핫 리로딩 덕분이다.
  하지만 핫 리로딩의 관점에서도 클래스 컴포넌트가 불리한 점도 있다. 아래 코드를 보자.

  ```jsx
  import { PureComponent, uesState } from "react";

  function FunctionalComponent() {
    const [count, setCount] = useState(0);

    function handleClick() {
      setCount((prev) => prev + 1);
    }

    return (
      <>
        <button onClick={handleClick}>{count} + </button>
      </>
    );
  }

  class ClassComponent extends PureComponent<{}, { count: number }> {
    construtor(props: {}) {
      super(props);
      this.state = {
        count: 0,
      };
    }

    handleClick = () => {
      this.setState((prev) => ({ count: prev.count + 1 }));
    };

    return() {
      return <button onCick={this.handleClick}>{this.state.count} + </button>;
    }
  }

  export default function App() {
    return (
      <>
        <FunctionalComponent />
        <ClassComponent />
      </>
    );
  }
  ```

  - count라는 state와 이 state를 1만큼 올려주는 핸들러로 구성된 완전히 동일한 기능을 하는 컴포넌트를 각각 함수 컴포넌트와 클래스 컴포넌트로 만들었다.
  - 이 코드를 개발자 모드에서 실행한 뒤 각각 return과 render 함수 내부를 수정하면 함수 컴포넌트는 핫 리로딩이 일어난 뒤에도 변경된 상태앖이 유지되지만, 클래스 컴포넌트는 핫 리로딩이 일어나면 바로 다시 기본값인 0으로 돌아간다.
  - 클래스 컴포넌트는 최초 렌더링 시에 instance를 생성하고, 그 내부에서 state 값을 관리하는데, 이 instance 내부에 있는 render를 수정하게 되면 이를 반영할 수 있는 방법은 오직 instance를 새로 만드는 방법 뿐이다. 그리고 새롭게 만들어진 instance에서 값은 당연히 초기화될 수 밖에 없다.
  - 하지만 함수 컴포넌트는 state를 함수가 아닌 클로저에서 저장해 두므로 함수가 다시 발생해도 해당 state를 읽지 않고 다시 보여줄 수 있다.
  - 즉, 클래스 커모넌트는 설계의 특성상 핫 리로딩에서 불리할 수밖에 없다.

## 🖌️ 함수 컴포넌트

```jsx
import { useState } from 'react'

type SampleProps = {
	required?: boolean
	text: string
}

export function SampleComponent({ required, text }: SampleProps) {
	const [count, setcount] = useState<number>(0)
	const [isLimited, setIsLimited] = useState<boolean>(false)

	function handleClick() {
		const newValue = count + 1
		setCount(newValue)
		setIsLimited(newValue >= 10)
	}

	return (
		<h2>
			Sample Component
			<div>{required ? '필수' : '필수 아님'}</div>
			<div>문자: {text}</div>
			<div>count: {count}</div>
			<button onClick={handleClick} disabled={isLimited}>
				증가
			</button>
		</h2>
	)
}
```

- 위 예제와 같이 함수 컴포넌트는 render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없고, state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편해졌다.
- 또한 state 객체도 관리할 수 있고 렌더링하는 코드인 return에서도 굳이 this를 사용하지 않아도 props와 state에 접근할 수 있게 됐다.

## 🖌️ 함수 컴포넌트 vs. 클래스 컴포넌트

- 클래스 컴포넌트와 함수 컴포넌트는 정확히 어떤 차이가 있을까?
- 클래스 컴포넌트는 꼭 함수 컴포넌트로 변경해야 할까?

둘 사이에 어떠한 차이점이 있는지 알아보면서 위의 질문을 해결해보자.

### 생명주기 메서드의 부재

가장 큰 차이점은 클래스 컴포넌트의 생명주기 메서드가 함수 컴포넌트에서 존재하지 않는다는 것이다.

그 이유는 함수 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 자바스크립트 클래스이기 때문이다.

즉, 생명주기 메서드는 React.Component에서 오는 것이기 때문에 클래스 컴포넌트가 아닌 이상 생명주기 메서드를 더는 사용할 수 없다는 뜻이다.

반대로 함수 컴포넌트는 useEffect 훅을 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있다. 하지만 비슷하게 구현될 뿐이지 똑같지는 않다는 점은 알고있어야한다.

이 이야기는 useEffect는 생명주기를 위한 훅이 아니고 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘이라는 이야기이다.

### 함수 컴포넌트와 렌더링된 값

함수 컴포넌트는 렌더링된 값을 고정하고, 클래스 컴포넌트는 그렇지 못하다.

```jsx
import React from 'react'

interface Props {
	user: string
}

// 함수 컴포넌트로 구현한 setTimeout 예제
export function FunctionalComponent(props: Props) {
	const showMessage = () => {
		alert('Hello' + props.user)
	}

	const handleClick = () => {
		setTimeout(showMessage, 3000)
	}

	return <button onClick={handleClick}>Follow</button>
}

// 클래스 컴포넌트로 구현한 setTimeout 예제
export class ClassComponent extends React.Component<Props, {}? {
	private showMessage = () => {
		alert('Hello' + this.props.user)
	}

	private handleClick = () => {
		setTimeout(this.showMessage, 3000)
	}

	public render() {
		return <button onClick={this.handleClick}>Follow</button>
	}
}
```

- FunctionalComponent 와 ClassComponent는 같은 작업을 하고 있다.
- handleClick을 클릭하면 3초 뒤에 props에 있는 user를 alert로 띄워준다. 여기서 만약 3초 사이에 props를 변경하면 어떻게 될까? 이 부분에서 차이가 있으니 그 차이를 알아보자.

👇🏻 그 차이는 다음과 같다.

ClassComponent의 경우에는 3초 뒤에 변경된 props를 기준으로 메시지가 뜨고, FunctionalComponent는 클릭했던 시점의 props 값을 기준으로 메시지가 뜬다.

클래스 컴포넌트는 props의 값을 항상 this로부터 가져온다. 클래스 컴포넌트의 props는 외부에서 변경되지 않는 이상 불변 값이지만 this가 가리키는 객체, 즉 컴포넌트의 인스턴스의 멤버는 변경 가능한(mutable) 값이다. 따라서 render 메서드를 비롯한 리액트의 생명주기 메서드가 변경된 값을 읽을 수 있게 된다.

따라서 이 경우에는 부모 컴포넌트가 props를 변경해 컴포넌트가 다시 렌더링됐다는 것은 this.props의 값이 변경된 것이다. 그래서 showMessage는 새로운 props의 값을 읽을 수 있게 된다.

👇🏻 이를 해결할 수 있는 방법에는 크게 두가지가 있다.

1. this.props를 조금 더 일찍 부르고, 이를 함수의 인수로 넘기는 방법

   ```jsx
   class ClassComponent extends React.Component<Props, State> {
   	private showMessage = (name: string) => {
   		alert('Hello ' + name)
   	}

   	private handleClick = () => {
   		const {
   			props: { user },
   		} = this
   		setTimeout(() => this.showMessage(user), 3000)
   	}

   	public render() {
   		return <button onclick={this.handleClick}>Follow</button>
   	}
   }
   ```

   → 이 방법은 문제는 해결했지만 접근해야 하는 props와 state가 많아질수록 코드도 같이 복잡해진다. 또한 showMessage가 다른 메서드에 의존하게 된다면 더욱 복잡해질 것이다.

1. render()에 필요한 값을 넣는 방법

   render() 함수가 실행되는 순간에 모든 값을 미리 넣어둔다면 필요한 값을 원하는 때에 부르게 될 것이다.

   ```jsx
   class ClassComponent extends React.Component<Props, State> {
     render() {
       const props = this.props;

       const showMessage = () => {
         alert("Hello " + props.user);
       };

       const handleClick = () => {
         setTimeout(showMessage, 3000);
       };

       return <button onClick={handleClick}>Follow</button>;
     }
   }
   ```

   → 이 방법은 알고 있는 클래스 컴포넌트 방식과 거리가 멀다. 렌더링될 때마다 함수가 다시 생성되고 할당되기를 반복하기 때문에 성능에도 도움이 되지 않는다.

그렇다면 함수 컴포넌트를 보자.

```jsx
export function FunctionalComponent(props: Props) {
  const showMessage = () => {
    alert("Hello" + props.user);
  };

  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };

  return <button onClick={handleClick}>Follow</button>;
}
```

→ this에 바인딩된 props를 사용하는 클래스 컴포넌트와 다르게, 함수 컴포넌트는 props를 인수로 받는다. 그리고 this와 다르게, props는 인수로 받기 때문에 컴포넌트는 그 값을 변경할 수 없고, 해당 값을 그대로 사용하게 된다. 이러한 특성은 state도 마찬가지이다.

→ 함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. props와 state가 변경된다면, 다시 한 번 그 값을 기준으로 함수가 호출된다. 반면 클래스 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

# 📑 렌더링은 어떻게 일어나는가?

브라우저의 렌더링이란 쉽게 말해 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미한다.

브라우저에서 사용자에게 보여줄 정보를 리는 과정인 만큼 무엇보다도 중요하며 렌더링이 어떻게 이뤄지느냐에 따라 성능에도 큰 영향을 미친다.

또한 리액트에도 이러한 렌더링 과정이 존재한다.

리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다. 리액트도 브라우저와 마찬가지로 이 렌더링 작업을 위한 자체적인 렌더링 프로세스가 있으며, 이를 이해하는 것이 리액트를 이해하는 첫걸음이 될 수 있다.

리액트의 렌더링은 시간과 리소스를 소비해 수행되는 과정으로, 이 비용은 모두 웹 애플리케이션을 방문하는 사용자에게 청구되며, 시간이 길어지고 복잡해질수록 유저의 사용자 경험을 저해한다. 따라서 리액트 개발자라면 렌더링이 어떻게, 왜, 어떤 순서로 일어나는지 알고 있어야 하며 이러한 렌더링 과정을 최소한으로 줄여야 한다.

## 🖌️ 리액트의 렌더링이란?

렌더링이라는 단어는 브라우저에서도 사용되기 때문에 두 가지를 혼동해서 사용해서는 안 된다.

리액트에서의 렌더링이란?

- 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.
- 만약 컴포넌트가 props와 state와 같은 상태값을 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 된다.

## 🖌️ 리액트의 렌더링이 일어나는 이유

리액트에서 렌더링이 발생하는 시나리오는 다음과 같다.

1. 최초 렌더링 : 사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링 : 리렌더링은 처음 애플리케이션에 진인했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다. 리렌더링이 발생하는 경우는 다음과 같다.

   - 클래스 컴포넌트의 setState가 실행되는 경우 : state의 변화는 컴포넌트 상태의 변화를 의미한다. 클래스 컴포넌트에서는 state의 변화를 setState 호출을 통해 수행하므로 리렌더링이 발생한다.
   - 클래스 컴포넌트의 forceUpdate가 실행되는 경우 : 클래스 컴포넌트에서 렌더링을 수행하는 것은 인스턴스 메서드인 render다. 만약 이 render가 state나 props가 아닌 다른 값에 의존하고 있어 리렌더링을 자동으로 실행할 수 없을 경우 forceUpdate를 실행해 리렌더링을 일으킬 수 있다.
     이때 forceUpdate를 실행하면 개발자가 강제로 렌더링이 필요하다고 선언한 것으로 간주해 shouldComponentUpdate는 무시하고 건너뛴다. 이는 자기 자신뿐만 아니라 하위 모든 컴포넌트에 적용된다.
     그리고 render 내에서 forceUpdate()가 사용되면 무한 루프에 빠지므로 render 내부에서 사용하지 말아야 한다.
   - 함수 컴포넌트의 useState()의 두 번재 배열 요소인 setter가 실행되는 경우 : useState가 반환하는 배열의 두 번째 인수는 클래스 컴포넌트의 setState와 마찬가지로 state를 업데이트하는 함수다. 이 함수가 실행되면 렌더링이 일어난다.
   - 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우 : useReducer도 useState와 마찬가지로 상태와 이 상태를 업데이트하는 함수를 배열로 제공한다. 이 두 번째 배열 요소를 실행하면 컴포넌트의 렌더링이 일어난다.
   - 컴포넌트의 key props가 변경되는 경우 : 리액트에서는 key는 명시적으로 선언돼 있지 않더라도 모든 컴포넌트에서 사용할 수 있는 특수한 props다. 일반적으로 key는 다음과 같이 배열에서 하위 컴포넌트를 선언할 때 사용된다.

     ```jsx
     const arr = [1, 2, 3];

     export default function App() {
       return (
         <ul>
           {/* 키가 없다면 'Warning: Each child in a list should have a unique "key" prop'가 출력된다. */}
           {arr.map((index) => {
             <li key={index}>{index}</li>;
           })}
         </ul>
       );
     }
     ```

     → 리액트에서 배열에 key를 쓰지 않으면 콘솔에 경고가 출력되기 때문에 key를 유일한 값으로 추가하는 것이 일반적이다. 그러면 여기서 왜 key가 필요할까라는 의문이 생길것이다 (나만 생기나?)
     리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식졀하는 값이다. 리액트 파이버 트리 구조에서 형제 컴포넌트를 구별하기 위해 각자 sibling이라는 속성값을 사용했다. 동일한 자식 컴포넌트가 여러 개 있는 구조에서 리렌더링이 발생하면 current 트리와 workInProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는지 구별해야 하는데, 이 두 트리 사이에서 같은 컴포넌트인지 구별하는 값이 바로 key이다.
     이 변경 사항을 구별하는 작업은 리렌더링이 필요한 컴포넌트를 최소화해야 하므로 반드시 필요한 작업이다. key가 존재함다면 두 트리 사이에서 동일한 key를 가지고 있는 컴포넌트는 이를 기준으로 구별할 수 있지만, 이 key가 없다면 단순히 파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다.
     아래 코드를 살펴보자.

     ```jsx
     const Child = memeo(() => {
     	return <li>hello</li>
     })

     function List({ arr }: { arr: number[] }) {
     	const [state, setState] = useState(0)

     	function handleButtonClick() {
     		setState((prev) => prev + 1)
     	}

     	return (
     		<>
     			<button onClick={handleButtonClick}>{state}+</button>

     			<ul>
     				{arr.map((_, index) => {
     					<Child />
     				))}
     			</ul>
     		</>
     	)
     }
     ```

     - Child에 key가 없어서 경고문이 발생했지만 setState의 호출로 부모 컴포넌트인 List의 리렌더링이 발생해도 Child는 memo로 선언돼 있으므로 리렌더링이 발생하지 않는다. 결국 <Child />는 <Child key={index} />와 동일하게 작동한다.
     - 만약 반대로 <Child key={Math.random()} />과 같이 렌더링할 때마다 변하는 임의의 값을 key에 넣는다고 가정해보자. 이때는 리렌더링이 일어날 때맏 sibling 컴포넌트를 명확히 구분할 수 없으므로 Child는 memo로 선언됐더라도 매번 리렌더링이 일어나게 된다. 즉, key의 변화는 리렌더링을 야기한다. 이러한 특징을 이용하면 key를 활용해 강제로 리렌더링을 일으키는 것이 가능해진다.
     - props가 변경되는 경우 : 부모로부터 전달받는 값인 props가 달라지면 이를 사용하는 자식 컴포넌트에서도 변경이 필요하므로 리렌더링이 일어난다.
     - 부모 컴포넌트가 렌더링될 경우 : 한 가지 주의할 점은, 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링이 일어난다는 것이다.

리액트에서 렌더링이 일어나는 경우는 위 시나리오 빼고는 없다. 아래 예제와 같이 useState 등으로 관리되지 않는 단순한 변수는 아무리 변경되어도 리렌더링을 발생시키지 않아 변경된 값을 렌더링된 DOM에서 확인할 수 없다.

```jsx
let index = 0

export default function App() {
	function handleButtonClick() {
		index += 1
	}

	return (
		<>
			<button onClick={handleButtonClick}>+</button>
			{/* 아무리 버튼을 눌러도 이 값은 계속 0에 머물러 있다. */}
			{index}
		</>
	)
```

이러한 이유 때문에 mobx-react나 react-redux와 같은 리액트 패키지를 설치해야 하는 것이다.

MobX와 Redux는 라이브러리 어디에선가 각자의 방법으로 상태를 관리해 주지만 이 상태 관리가 리액트의 렌더링으로 이어지지는 않는다. 각각 mobx-react, react-redux가 라이브러리로부터 변경된 상태를 바탕으로 위에서 언급한 방법 중 하나를 사용해 리렌더링을 발생시킨다.

Recoil처럼 이러한 별도의 리액트 패키지가 없이도 상태 관리가 되는 라이브러리의 경우에는 내부에서 useState 등을 통해 리렌더링을 발생시킨다.

## 🖌️ 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.

만약 여기서 업데이트가 필요하다고 지정되어 있는 컴포넌트를 발견하면 클래스 컴포넌트의 경우에는 클래스 내부의 render() 함수를 실행하게 되고, 함수 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤에, 그 결과물을 저장한다.

렌더링 결과물은 JSX 문법으로 구성돼 있고, 이것이 자바스크립트로 컴파일되면서 React.createElement()를 호출하는 구문으로 변환된다.

여기서 createElement는 브라우저의 UI 구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다.

```jsx
// 1. 자바스크립트 객체
function Hello() {
	return (
		<TestComponent a={35} b="yceffort">
			안녕하세요
		</TestComponent>
	)
}

// 2. JSX 문법이 React.createElement를 호출해서 변환
function Hello() {
	return React.createElement(
		TestComponent,
		{ a: 35, b: 'yceffort' },
		'안녕하세요',
	)
}

// 3. 결과
{type: TestComponent, props: {a: 35, b: "yceffort", children: "안녕하세여"}}
```

- 렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.
- 이렇게 계산하는 과정을 리액트 재조정(Reconciliation)이라고 한다. 이러한 재조정 과정이 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.

이 때 리액트의 렌더링은 렌더 단계와 커밋 단계라는 총 두 단계로 분리되어 실행된다.

## 🖌️ 렌더와 커밋

`렌더 단계(Render Phase)`는 컴포넌트를 렌더링하고 변경 사항을 계한하는 모든 작업을 말한다. 즉, 렌더링 프로세스에서 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 여기서 비교하는 것은 크게 세 가지로 type, props, key이다. 이 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.

`커밋 단계(Commit Phase)`는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다. 그 다음, 생명주기 개념이 있는 클래스 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고, 함수 컴포넌트에서는 useLayoutEffect 훅을 호출한다.

**리액트 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.** 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다.

즉 리액트의 렌더링은 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있다. 렌더링 과정 중 첫 번째 단계인 렌더 단계에서 변경 사항을 감지할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트가 일어나지 않을 수 있다.

- https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
  → 리액트 렌더 단계와 커밋 단계에서 어떤 일이 일어나는지 보여주는 다이어그램. 비록 클래스 컴포넌트만을 기준으로 작성돼 있지만 전체적인 렌더링 단계를 이해하는 데 도움이 될 것이다.

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%204.png)

렌더 단계와 커밋 단계로 이뤄진 리액트의 렌더링은 항상 동기식으로 작동했다. 따라서 렌더링 과정이 길어질수록 애플리케이션의 성능 저하로 이어지고, 결과적으로 그 시간만큼 브라우저의 다른 작업을 지연시킬 가능성이 있다.

렌더링이 순차적인 동기 방식이 아니라 순서가 보장되지 않는 비동기 방식으로 이뤄질 경우 사용자는 하나의 상태에 대해 여러 가지 다른 UI를 보게 될 것이다.

하지만 이러한 비동기 렌더링 시나리오는 몇 가지 상황에서 유효할 수도 있다. B의 컴포넌트 렌더링 작업이 무거워 상대적으로 빠르게 렌더링할 수 있는 C라도 변경해서 보여줄 수 있을 경우 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 이른바 동시성 렌더링이 리액트 18에서 도입됐다.

이 동시성 렌더링은 렌더링 중 렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하거나 재시작하거나, 경우에 따라서는 포기할 수도 있다. 이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도 있으므로 사용자는 더욱 매끄러운 사용자 경험을 누릴 수 있다.

## 🖌️ 일반적인 렌더링 시나리오 살펴보기

지금까지 다뤘던 내용을 바탕으로 예제 리액트 코드를 살펴보면서 리액트의 렌더링이 어떻게 일어나는지 살펴보자.

✅ 리액트 컴포넌트 트리의 렌더링 과정을 살펴보기 위한 예제

```jsx
import { useState } from "react";

export default function A() {
  return (
    <div className="App">
      <h1>Hello React!</h1>
      <B />
    </div>
  );
}

function B() {
  const [counter, setcounter] = useState(0);

  function handleButtonClick() {
    setCounter((previous) => previous + 1);
  }

  return (
    <>
      <label>
        <C number={counter} />
      </label>
      <button onClick={handleButtonClick}>+</button>
    </>
  );
}

function C({ number }) {
  return (
    <div>
      {number} <D />
    </div>
  );
}

function D() {
  return <>리액트 재밌다!</>;
}
```

사용자가 B 컴포넌트의 버튼을 눌러 counter 변수를 업데이트하면 리액트에서는 다음과 같은 순서로 렌더링이 일어난다.

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%205.png)

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%206.png)

1. B 컴포넌트의 setState가 호출된다.
2. B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단에서부터 렌더링 경로를 검사한다.
4. A 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시돼 있지 않으므로 별다른 작업을 하지 않는다.
5. 그다음 하위 컴포넌트인 B 컴포넌트는 업데이트가 필요하다고 체크돼 있으므로 B를 리렌더링한다.
6. 5번 과정에서 B는 C를 반환했다.
7. C는 props인 number가 업데이트됐다. 그러므로 업데이트가 필요한 컴포넌트로 체크돼 있고 업데이트한다.
8. 7번 과정에서 C는 D를 반환했다.
9. D도 마찬가지로 업데이트가 필요한 컴포넌트로 체크되지 않았다. 그러나 C가 렌더링됐으므로 그 자식인 D도 렌더링됐다.

**즉, 컴포넌트를 렌더링하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다. 그리고 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링된다.**

**상위 컴포넌트, 특히 루트에서 무언가 렌더링을 발생시키는 작업이 일어난다는 것은 하위 모든 컴포넌트의 리렌더링을 트리거한다는 뜻이다.** 설계에 따라 다르겠지만 설령 이 작업이 하위 컴포넌트에 변경 사항을 야기하지 않더라도 리액트는 이와 상관없이 어쨌든 리렌더링 작업을 요청하고 비교 작업을 수행하므로 그만큼의 시간과 노력이 소요된다.

⁉️ 만약 D 컴포넌트에 memo를 추가하면 어떻게 될까?

```jsx
const D = memo(() => {
  return <>리액트 재밌다!</>;
});
```

![Untitled](%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%92%E1%85%A2%E1%86%A8%E1%84%89%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%AD%E1%84%89%E1%85%A9%20%E1%84%80%E1%85%B5%E1%87%81%E1%84%80%E1%85%A6%20%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A7%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5%20910d7af881c64831b33821dfab19ea74/Untitled%207.png)

→ 동일하게 B 컴포넌트에서 상태값이 변경됐음에도 memo로 래핑돼 있어 렌더링이 일어나지 않았음을 알 수 있다.

→ 리액트의 렌더링 단계에 기초해 정확하게 이야기한다면 렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된 것이다.

# 📑 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

그렇다면 이러한 메모이제이션 기법은 언제 사용하는 것이 좋을까?

- 렌더링이 자주 일어나는 컴포넌트?
- 렌더링이 자주 일어나는 컴포넌트를 어떻게 알 수 있을까?
- 코드를 꼼꼼히 읽어서 렌더링이 일어날 것 같은 영역에 모조리 추가할까? 아니면 의존성 배열이 생략된 useEffect를 모든 컴포넌트에 추가해서 실제로 렌더링이 돌아가는지 확인해 봐야 할까?
- 무거운 연산의 기준은 무엇일까?
- 실제로 코드를 작성할 때 함수의 실행 속도나 컴포넌트 렌더링 속도를 매번 계산하는 것이 좋은 걸까? 계산한다면 그 기준은 무엇일까?
- 이렇게 최적화에 대해 매번 고민할 바엔 그냥 모든 컴포넌트를 메모이제이션해 버리는 게 낫지 않을까?
- 함수 결과도 다 메모이제이션할까?
- 렌더링 비용과 메모이제이션 비용 중 어떤 게 더 비싼 걸까?

이와 같이 여러가지 의문점이 들 수 있는데 메모이제이션에 대한 두 주장을 살펴보고, 현명하고 효율적으로 리액트에서 메모이제이션하는 법에 대해 알아보자.

## 🖌️ 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불 할 때는 항상 신중해야 한다고 주장하는 입장이다.

```jsx
function sum(a, b) {
  return a + b;
}
```

이 코드의 결과를 메모이제이션해 두는게 좋을까 아니면 매번 새로운 계산을 하는게 좋을까?

이 에제는 극단적인 예제이긴 하지만 대부분 가벼운 작업 자체는 메모이제이션해서 자바스크립트 메모리 어딘가에 두었다가 그것을 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 있다.

메모이제이션도 비용이 드는데, 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 하는 비용이 있다.

상황에 따라 달라 이 비용이 리렌더링 비용보다 저렴하다고 장담할 수 없기 때문에 항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야 한다.

만약 이러한 비교와 렌더링이 문제가 됐다면 리액트에서는 진작에 모든 컴포넌트를 PureComponent로 만들었거나 memo로 감싸두는 작업을 했을 것이다. 그렇지 않고 이를 개발자에게 선택권을 주었다는 것은 메모이제이션이 모든 문제를 해결할 수 있는 방안은 아니라는 사실을 야기한다.

메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법이라고 보는 것이 옳다. 이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유하게 된다. 렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용이다. 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하는 상황을 마주하게 되는 것이다.

미리 개발자가 렌더링이 많이 될 것 같은 부분을 예측해 메모이제이션하는, 섣부른 최적화는 옳지 못한 행동이다.

일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.

## 🖌️ 주장 2: 렌더링 과정의 비용은 비싸다, 무조건 메모이제이션해야한다.

만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 있다.

그럼 선택권은 두 가지가 있다.

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용하는 방법
- memo를 일단 그냥 다 적용하는 방법

첫 번째 경우는 가장 이상적인 상황이다. 그러나 리액트 애플리케이션의 규모가 커지고, 개발자는 많아지고, 컴포넌트의 복잡성이 증가하는 상황에서도 전자의 기조를 유지할 수 있을까?

개발자라면 생각보다 최적화나 성능 향상에 쏟을 시간이 많지 않다는 사실은 모두 공감할 것이다. 따라서 일단 memo로 감싼 뒤에 생각해 보면 어떨까? 라는 주장이다.

이 주장이 괜찮은지 생각해보려면 잘못된 컴포넌트에 이뤄진 최적화, 즉 렌더링 비용이 저렴하거나 사실 별로 렌더링이 안 되는 컴포넌트에 memo를 썼을 때 역으로 지불해야 하는 비용을 생각해 보자.

잘못된 memo로 지불해야 하는 비용은 바로 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다.

메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다.

그런데 이 작업을 어디서 들어본 적 있지 않은가? 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다. 그것이 기본적인 리액트의 재조정 알고리즘이기 때문이다.

즉, 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다. 따라서 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐인 것이다. 물론 이 비용 또한 무시할 수는 없다. props가 크고 복잡해진다면 이 비용 또한 커질 수 있다.

반면 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같다.

- 렌더링을 함으로써 발생하는 비욥
- 컴포넌트 내부의 복잡한 로직의 재실행
- 리고 위 두 가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

→ memo를 하지 않았을 때 드는 잠재적인 위험 비용이 더 크다는 것을 알 수 있다.

memo이외에도 useMemo와 useCallback도 있다.

useMemo와 useCallback을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다.

그럼 이 경우도 마찬가지로 무조건 메모이제이션하는 방법을 먼저 고민해 볼 필요가 있다.

리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다. 이때 달라진 참조에 대한 값을 어디서든 쓰지 않는다면 큼 문제가 될 수 있지만 이 값이 useEffect와 같은 의존성 배열에 쓰이면 변경된 참조로 인해 다른 쪽에도 영향을 미칠 것이다.

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return { double, triple };
}

export default function App() {
  const [counter, setCounter] = useState(0);
  const value = useMath(10);

  useEffect(() => {
    console.log(value.double, value.triple);
  }, [value]); // 값이 실제로 변한 건 없는데 계속해서 console.log가 출력된다.

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

→ useMath 훅은 인수로 넘겨주는 값이 변하지 않는 이상 같은 값을 가지고 있어야 하는데, 실제로 handleClick으로 렌더링을 강제로 일으켜 보면 console.log가 출력되는 것을 볼 수 있다.

그 이유는 함수 컴포넌트인 App이 호출되면서 useMath가 계속해서 호출되고, 객체 내부의 값 같지만 참조가 변경되기 때문이다.

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0);
  const [triple, setTriple] = useState(0);

  useEffect(() => {
    setDouble(number * 2);
    setTriple(number * 3);
  }, [number]);

  return useMemo(() => ({ double, triple }), [double, triple]);
}
```

→ useMath의 반환값을 useMemo로 감싼다면 값이 변경되지 않는 한 같은 결과물을 가질 수 있고, 그 덕분에 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다. 즉, 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

❣️ 결론은 메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다. 따라서 비록 섣부른 초기화라 할지라도 이를 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

❣️ 또한 아직 리액트를 배우고 있거나 혹은 리액트를 깊이 이해하고 싶고,이를 위해 시간을 투자할 여유가 있다면 1번의 의견대로 섣부른 메모이제이션을 지양하는 자세를 견지하면서 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장한다.

❣️ 그리고 만약 현업에서 리액트를 사용하고 있거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이라면 일단 의심스러운 고셍는 먼저 다 적용해 볼 것을 권장한다.
