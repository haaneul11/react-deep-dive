# 리액트 훅 깊게 살펴보기

함수 컴포넌트가 상태를 사용하거나 클래스 컴포넌트의 생명주기 메서드를 대처하는 등의 다양한 작업을 하기 위해 훅(hook)이라는 것이 추가됐다.

훅을 활용하면 클래스 컴포넌트가 아니더라도 리액트의 다양한 기능을 활용할 수 있다.

# 📑 리액트의 모든 훅 파헤치기

리액트 함수 컴포넌트에서 가장 중요한 개념은 바로 훅이다.

훅은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만들었고, 무엇보다 클래스 컴포넌트보다 간결하게 작성할 수 있어 훅이 등장하였다.

## 🖌️ useState

useState는 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

```jsx
import { useState } from "react";

const [state, setState] = useSate(initialState);
```

useState의 인수로는 사용할 state의 초깃값을 넘겨준다. 아무런 값을 넘겨주지 않으면 초기값은 undefined다.

useState 훅의 반환 값은 배열이며, 배열의 첫 번째 원소로 state값 자체를 사용할 수 있고, 두 번째 원소인 setState 함수를 사용해 해당 state의 값을 변경할 수 있다.

```jsx
function Component() {
  const [, triggerRender] = useState();

  let state = "hello";

  function handleButtonClick() {
    state = "hi";
    triggerRender();
  }

  return (
    <>
      <h1>{state}</h1>
      <button onClick={handleButtonClick}>hi</button>
    </>
  );
}
```

이 코드는 useState 반환값의 두 번째 원소를 실행해 리액트에서 렌더링이 일어난다. 하지만 버튼 클릭 시 state의 변경된 값이 렌더링되고 있지 않다.

그 이유는 리액트의 렌더링은 함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문이다. 즉, 매번 렌더링이 발생될 때마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수에서 state는 매번 hello로 초기화되므로 아무리 state를 변경해도 다시 hello로 초기화되는 것이다.

함수 컴포넌트는 매번 함수를 실행해 렌더링이 일어나고, 함수 내부의 값은 함수가 실행될 때마다 다시 초기화된다.

⁉️ 그렇다면 useState 훅의 결괏값은 어떻게 함수가 실행돼도 그 값을 유지하고 있을까?

✅ useState 내부의 모습을 구현한 모습

```jsx
const MeReact = (function () {
  const global = {};
  let index = 0;

  function useState(initialState) {
    if (!global.state) {
      // 애플리케이션 전체의 states 배열을 초기화한다.
      // 최초 접근이라면 빈 배열로 초기화된다.
      global.states = [];
    }

    // state 정보를 조회해서 현재 상태값이 있는지 확인하고,
    // 없다면 초깃값으로 설정한다.
    const currentState = global.states[index] || initialState;
    // states의 값을 위에서 조회한 현재 값으로 업데이트한다.
    global.states[index] = currentState;

    // 즉시 실행 함수로 setter를 만든다.
    const setState = (function () {
      // 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에 접근할 수 있도록 한다.
      let currentIndex = index;
      return function (value) {
        global.state[currentIndex] = value;
        // 컴포넌트를 렌더링한다. 실제로 컴포넌트를 렌더링하는 코드는 생략했다.
      };
    })();
    // useState를 쓸 때마다 index를 하나씩 추가한다. 이 index는 setState에서 사용된다.
    // 즉, 하나의 state마다 index가 할당돼 있어 그 index가 배열의 값(global.states)을 가리키고 필요할 때마다 그 값을 가져오게 된다.
    index = index + 1;

    return [currentState, setState];
  }

  // 실제 useState를 사용하는 컴포넌트
  function Component() {
    const [value, setValue] = useState(0);
    // ...
  }
})();
```

- 작동 자체만 구현한 코드로, 실제 구현체와는 차이가 있다. 실제 리액트 코드에서는 useReducer를 이용해 구현돼 있다. useReducer와 useState는 크게 다르지 않다.
- 여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법은 클로저 때문이다. 매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해서 리액트는 클로저를 활용하고 있다.
- 위 예제에서는 MyReact라고 불리는 클로저 내부에 useState와 관련된 정보를 저장해 두고, 이를 필요할 때마다 꺼내놓는 형식으로 구성돼 있다.
- 클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고, 함수 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쓸 수 있다.

### 게으른 초기화

일반적으로는 useState에 기본값을 선언하기 위해 인수로 원시값을 넣는 경우가 대부분인데 여기에 특정한 값을 넘기는 함수를 인수로 넣어줄 때도 있다.

이를 useState에 변수 대신 함수를 넘김으로써 `게으른 초기화(lazy initialization)`라고 한다.

```jsx
// 일반적인 useState 사용 (값을 바로 넣기)
const [count, setCount] = useState(
  Number.parseInt(window.localStorage.getItem(cacheKey))
);

// 게으른 초기화 (함수를 실행해 값을 반환하여 넣기)
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

리액트 공식문서에서는 게으른 초기화는 useState의 초깂값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 되어있다.

게으른 초기화 함수는 state가 처음 만들어질 때만 사용된다. 만약 이후에 리렌더링이 발생되면 이 함수의 실행은 무시된다.

```jsx
import { useState } from "react";

export default function App() {
  const [state, setState] = useState(() => {
    console.log("복잡한 연산"); // App 컴포넌트가 처음 구동될 때만 실행되고, 이후 리렌더링 시에는 실행되지 않는다.
    return 0;
  });

  function handleClick() {
    setState((prev) => prev + 1);
  }

  return (
    <div>
      <h1>{state}</h1>
      <button onClick={handleClick}>+</button>
    </div>
  );
}
```

❣️ 리액트에서는 렌더링이 실행될 때마다 함수 컴포넌트의 함수가 다시 실행된다는 점을 명심하자.

이때 함수 컴포넌트의 useState의 값도 재실행된다. 클로저를 통해 값을 가져오기 때문에 초깃값은 최초에만 사용된다.

또한 함수를 넣는 경우에도 최초 렌더링 이후에 실행되지 않는다.

❣️ 게으른 최적화는 리액트에서 무거운 연산이 요구될 때 사용하는 것이 좋다. 즉, localStorage나 sessionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때와 같이 무거운 연산을 포함해 실행 비용이 많이 드는 경우에 게으른 초기화를 사용하는 것이 좋다.

## 🖌️ useEffect

useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. 그리고 이 부수 효과가 ‘언제’ 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

### useEffect란?

```jsx
function Component() {
  useEffect(() => {
    // ...
  }, [props, state]);
  //...
}
```

첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달한다.

이때 의존성 배열은 어느 정도 길이를 가진 배열일 수도, 아무런 값이 없는 빈 배열일 수도 있고, 배열 자체를 넣지 않고 생략할 수도 있다.

의존성 배열이 변경될 때마다 useEffect의 첫 번째 인수인 콜백을 실행한다는 것은 알려져있는데 useEffect는 어떻게 의존성 배열이 변경된 것을 알고 실행될까??

함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행하는데 다음 예제를 살펴보자.

```jsx
function Component() {
  const [counter, setCounter] = useState(0);

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- 함수 컴포넌트는 렌더링 시마다 고유의 state와 props 값을 갖고 있다.
- useEffect는 자바스크립트의 proxy나 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라 볼 수 있다.
- 따라서 useEffect는 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수라고 볼 수 있다.

### 클린업 함수의 목적

클린업 함수라 불리는 useEffect 내에서 반환되는 함수는 무엇이고 어떤 일을 할까?

→ 일반적으로 클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.

```jsx
import { useState, useEffect } from "react";

export default function App() {
  const [counter, setCounter] = useState(0);

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  useEffect(() => {
    function addMouseEvent() {
      console.log(counter);
    }

    window.addEventListener("click", addMouseEvent);

    // 클린업 함수
    return () => {
      console.log("클린업 함수 실행!", counter);
      window.removeEventListener("click", addMouseEvent);
    };
  }, [counter]);

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

위 코드의 실행 결과 아래와 같은 결과를 확인할 수 있다.

```jsx
클린업 함수 실행! 0
1

클린업 함수 실행! 1
2

클린업 함수 실행! 2
3

클린업 함수 실행! 3
4

// ...
```

클린업 함수는

- 이전 counter 값, 즉 이전 state를 참조해 실행된다.
- 새로운 값과 함께 렌더링된 뒤에 실행되기 때문에 위와 같은 메시지가 나타난다.
- 새로운 값을 기반으로 렌더링 뒤에 실행되지만 이 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.

아래 코드를 살펴보자.

```jsx
// 최초 실행
useEffect(() => {
  function addMouseEvent() {
    console.log(1);
  }

  window.addEventListenr("click", addMouseEvent);

  // 클린업 함수는 다음 렌더링이 끝난 뒤에 실행된다.
  return () => {
    console.log("클린업 함수 실행!", 1);
    window.removeEventListener("click", addMouseEvent);
  };
}, [counter]);

//이후 실행
useEffect(() => {
  function addMouseEvent() {
    console.log(2);
  }

  window.addEventListener("click", addMouseEvent);

  // 클린업 함수
  return () => {
    console.log("클린업 함수 실행!", 2);
    window.removeEventListener("click", addMouseEvent);
  };
}, [counter]);
```

이 예제는 렌더링이 수행될 때마다 counter가 어떤 값으로 선언되어 있는지 분명하게 보여주는 코드이다.

함수 컴포넌트의 useEffect는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다.

따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것이다. 그러면 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지할 수 있다.

- 클린업 함수는 생명주기 메서드의 언마운트 개념과는 차이가 있다.
- `언마운트`는 특정 컴포넌트가 DOM에서 사라진다는 것을 의미하는 클래스 컴포넌트의 용어다.
- `클린업 함수`는 언마운트라기보다는 함수 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 이전 상태를 청소해 주는 개념이다.

### 의존성 배열

의존성 배열은 보통 빈 배열을 두거나, 아예 아무런 값도 넘기지 않거나, 혹은 사용자가 직접 원하는 값을 넣어줄 수 있다.

- 빈 배열일 경우 : 리액트가 이 useEffect는 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않는다.
- 아무런 값도 넘겨주지 않을 경우 : 이때는 의존성 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행된다.
  → 보통 컴포넌트가 렌더링됐는지 확인하기 위한 방법으로 사용
  ```jsx
  useEffect(() => {
    console.log("컴포넌트 렌더링됨");
  });
  ```
  - 위 코드처럼 구현해 두면 컴포넌트가 렌더링될 때마다 useEffect가 실행될 것이다. 만약 컴포넌트가 렌더링되는지 확인하고 싶다면 위와 같이 useEffect를 선언해 두면 된다.

⁉️ 의존성 배열이 없는 useEffect가 매 렌더링마다 실행된다면 그냥 useEffect 없이 써도 되는거 아닌가? 라는 의문이 생길 수 있다.

```jsx
// 1.
function Component() {
  console.log("렌더링됨");
}

// 2.
function Component() {
  useEffect(() => {
    console.log("렌더링됨");
  });
}
```

이 두가지는 명백히 리액트에서 차이점을 지니고 있다.

1. 이후에 소개할 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다.
2. useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 이후에 실행된다. 반면 1번과 같이 함수 내부에서의 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다. 따라서 2번과는 달리 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수 컴포넌트의 반환을 지연시키는 행위이다. 즉, 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다.

❣️ useEffect의 effect는 컴포넌트의 사이드 이팩트, 즉 부수 효과를 의미한다는 것을 기억하자. useEffect는 컴포넌트가 렌더링된 후에 어떠한 부수 효과를 일으키고 싶을 때 사용하는 훅이다.

### useEffect의 구현

useState와 마찬가지로 리액트 코드를 직접 한번 구현해보자.

```jsx
const MyReact = (function ()
	const global = {}
	let index = 0

	function useEffect(callback, dependencies) {
		const hooks = global.hooks

		// 이전 훅 정보가 있는지 확인한다.
		let previousDependencies = hooks[index]

		// 변경됐는지 확인
		// 이전 값이 있다면 이전 값을 얕은 비교로 비교해 변경이 일어났는지 확인한다.
		// 이전 값이 없다면 최초 실행이므로 변경이 일어난 것으로 간주해 실행을 유도한다.
		let isDependenciesChanged = previousDependencies
			? dependencies.some(
					(value, idx) => !Object.is(value, previousDependencies[idx]),
				)
			: true

		// 변경이 일어났다면 첫 번째 인수인 콜백 함수를 실행한다.
		if (isDependenciesChanged) {
			callback()

			// 다음 훅이 일어날 때를 대비하기 위해 index를 추가한다.
			index++

			// 현재 의존성을 훅에 다시 저장한다.
			hooks[index] = dependencies
		}

		return { useEffect }
})()
```

- 의존성 배열의 이전 값과 현재 값의 얕은 비교를 유심히 보자.
- 리액트는 값을 비교할 때 Object.is를 기반으로 하는 얕은 비교를 수행한다. 이는 의존성 배열과 현재 의존성 배열의 값에 하나라도 변경 사항이 있다면 callback으로 선언한 부수 효과를 실행한다. 이것이 useEffect의 본질이다.

### useEffect를 사용할 때 주의할 점

useEffect를 잘못 사용하면 예기치 못한 버그가 발생할 수 있으며, 심한 경우 무한 루프에 빠질수도 있어 사용할 때 주의해야한다.

eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라

이 ESLint룰은 useEffect 인수 내부에서 사용하는 값 중 의존성 배열에 포함돼 있지 않은 값이 있을 때 경고를 발생시킨다.

```jsx
useEffect(() => {
  console.log(props);
}, []); // eslint-disable-line react-hooks/exhaustive-deps
```

정말로 필요할 때에는 사용할 수도 있지만 대부분의 경우에는 의도치 못한 버그를 만들 가능성이 큰 코드이기 때문에 가급적이면 사용해선 안 된다.

useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅이다. 그러나 의존성 배열을 넘기지 않은 채 콜백 함수 내부에서 특정 값을 사용한다는 것은, 이 부수 효과가 실제로 관찰해서 실행돼야 하는 값과는 별개로 작동한다는 것을 의미한다.

즉, 컴포넌트의 state, props와 같은 어떤 값의 변경과 useEffect의 부수 효과가 별개로 작동하게 된다는 것이다. useEffect에서 사용한 콜백 함수의 실행과 내부에서 사용한 값의 실제 변경 사이에 연결 고리가 끊어져 있는 것이다.

❣️ 의존성으로 [ ]가 필요하다면 최초에 함수 컴포넌트가 마운트됐을 시점에만 콜백 함수 실행이 필요한지를 다시 한번 되물어봐야 한다. 만약 정말 필요하면 useEffect 내 부수 효과가 실행될 위치가 잘못됐을 가능성이 크다.

```jsx
function Component({ log }: { log: string }) {
  useEffect(() => {
    logging(log);
  }, []); // eslint-disable-line react-hooks/exhaustive-deps
}
```

- 이 코드는 log가 최초로 props로 넘어와서 컴포넌트가 최초로 렌더링된 시점에만 실행된다. 코드를 작성한 의도는 아마도 해당 컴포넌트가 최초로 렌더링됐을 때만 logging을 실행하고 싶어서일 것이다.
- 하지만 이 코드는 버그의 위험성을 안고 있는 코드이다. log가 아무리 변하더라도 useEffect의 부수 효과는 실행되지 않고, useEffect의 흐름과 컴포넌트의 props.log의 흐름이 맞지 않게 된다.
- 따라서 앞에서 logging이라는 작업은 log를 props로 전달하는 부모 컴포넌트에서 실행되는 것이 옳을지도 모른다. 부모 컴포넌트에서 Component가 렌더링되는 시점을 결ㅈ어하고 이에 맞게 log 값을 넘겨준다면 useEffect의 해당 주석을 제거해도 위 예제 코드와 동일한 결과를 만들 수 있고 Component의 부수 효과 흐름을 거스르지 않을 수 있다.

❣️ useEffect에 빈 배열을 넘기기 전에는 정말 useEffect의 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 혹은 여기서 호출하는 게 최선인지 한 번 더 검토해 봐야 한다.

❣️ 빈 배열이 아닐 때도 특정 값을 사용하지만 해당 값의 변경 시점을 파피할 목적이라면 메모이제이션을 적절히 활용해 해당 값의 변화를 막거나 실행 위치를 다시 한번 고민해 보는 것이 좋다.

useEffect의 첫 번째 인수에 함수명을 부여하라

useEffect를 사용하는 많은 코드에서 useEffect의 첫 번째 인수로 익명 함수를 넘겨준다.

```jsx
useEffect(() => {
	logging(user.id)
}, [user.id]
```

useEffect의 수가 적거나 복잡성이 낮으면 익명 함수를 사용해도 문제가 없지만 코드가 복잡하고 많아질수록 무슨 일을 하는 useEffect 코드인지 파악하기 어려워진다.

→ 그래서 `기명 함수`로 바꾸는 것이 좋다. 그 이유는 해당 useEffect의 목적을 파악하기 쉬워지기 때문이다.

```jsx
useEffect(
	function logActiveUser() {
		logging(user.id)
	},
	[user.id],
}
```

거대한 useEffect를 만들지 마라

- useEffect는 의존성 배열을 바탕으로 렌더링 시 의존성이 변경될 때마다 부수 효과를 실행한다. 이 부수 효과의 크기가 커질수록 애플리케이션 성능에 악영향을 미친다.
- useEffect가 컴포넌트의 렌더링 이후에 실행되기 때문에 렌더링 작업에는 영향을 적게 미칠 수 있지만 여전히 자바스크립트 실행 성능에 영향을 미친다. 따라서 가능한 한 useEffect는 간결하고 가볍게 유지하는 것이 좋다.
- 만약 부득이하게 큰 useEffect를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리하는 것이 좋다.
- 의존성 배열이 너무 거대하고 관리하기 어려운 수준까지 이르면 정확이 이 useEffect가 언제 발생하는지 알 수 없게 된다. 만약 의존성 배열에 불가피하게 여러 변수가 들어가야 하는 상황이라면 최대한 useCallback과 useMemo 등으로 사전에 정제한 내용들만 useEffect에 담아두는 것이 좋다. 그러면 언제 useEffect가 실행되는지 좀 더 명확하게 알 수 있다.

불필요한 외부 함수를 만들지 마라

useEffect의 크기가 작은 것과 같은 맥락에서 useEffect가 실행하는 콜백 또한 불필요하게 존재해서는 안된다.

```jsx
function Component({ id }: { id: string }) {
  const [info, setInfo] = (useState < number) | (null > null);
  const controllerRef = (useRef < AbortController) | (null > null);
  const fetchInformation = useCallback(async (fetchId: string) => {
    controllerRef.current?.abort();
    controllerRef.current = new AbortController();

    const result = await fetchInfo(fetchId, { signal: controllerRef.signal });
    setInfo(await result.json());
  }, []);

  useEffect(() => {
    fetchInformation(id);
    return () => controllerRef.current?.abort();
  }, [id, fetchInformation]);
  return <div>{/* 렌더링 */}</div>;
}
```

- 이 컴포넌트는 props를 받아서 그 정보를 바탕으로 API 호출을 하는 useEffect를 가지고 있다. 그러나 useEffect 밖에서 함수를 선언하다 보니 불필요한 코드가 많아지고 가독성이 떨어졌다.

아래 코드는 useEffect 외부에 있던 관련 함수를 내부로 가져온 코드이다.

```jsx
function Component({ id }: { id: string }) {
  const [info, setInfo] = (useState < number) | (null > null);

  useEffect(() => {
    const controller = new AbortController();

    (async () => {
      const result = await fetchInfo(id, { signal: controller.signal });
      setInfo(await result.json());
    })();

    return () => controller.abort();
  }, [id]);
  return <div>{/* 렌더링 */}</div>;
}
```

- 불필요한 의존성 배열도 줄일 수 있고, 무한루프에 빠지기 위해 넣었던 코드인 useCallback을 삭제하였다.
- useEffect 내에서 사용할 부수 효과라면 내부에서 만들어서 정의해서 사용하는 편이 훨씬 도움이 된다.

🥕 useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없는 이유

useEffect 내부에서 state를 결과에 따라 업데이트하는 로직이 있다고 가정해 보자. 만약 useEffect의 인수로 비동기 함수가 사용 가능하다면 비동기 함수의 응답 속도에 따라 결과가 이상하게 나타날 수 있다.

극단적인 예제로 state 기반의 응답이 10초가 걸렸고, 이후 바뀐 state 기반의 응답이 1초 뒤에 왔다면 이전 state 기반으로 결과가 나와버리는 불상사가 생길 수 있다. 이러한 문제를 useEffect의 `경쟁 상태(race condition)`라고 한다.

```jsx
useEffect(async () => {
  // useEffect에 async 함수를 넘겨주면 다음과 같은 에러가 발생한다.
  // Effect callbacks are synchronous to prevent race conditions. Put the async function inside:
  const response = await fetch("http://some.data.com");
  const result = await response.json();
  setData(result);
}, []);
```

useEffect에서 비동기로 함수를 호출할 경우 경쟁 상태가 발생할 수 있기 때문에 콜백 인수로 비동기 함수를 바로 넣는 것은 지양한다.

하지만 useEffect의 인수로 비동기 함수를 지정할 수 없는 것이지, 비동기 함수 실행 자체가 문제가 되는 것은 아니다. useEffect 내부에서 비동기 함수를 선언해 실행하거나, 즉시 실행 비동기 함수를 만들어서 사용하는 것은 가능하다.

```jsx
useEffect(() => {
  let shouldIgnore = false;

  async function fetchData() {
    const response = await fetch("http://some.data.com");
    const result = await response.json();
    if (!shouldIgnore) {
      setData(result);
    }
  }

  fetchData();

  return () => {
    // shouldIgnore를 이용해 useState의 두 번째 인수를 실행해 막는 것뿐만 아니라 AbortController를 활용해 직전 요청 자체를 취소하는 것도 좋은 방법이 될 수 있다.
    shouldIgnore = true;
  };
}, []);
```

단 비동기 함수가 내부에 존재하게 되면 useEffect 내부에서 비동기 함수가 생성되고 실행되는 것을 반복하므로 클린업 함수에서 이전 비동기 함수에 대한 처리를 추가하는 것이 좋다. fetch의 경우 abortController 등으로 이전 요청을 취소하는 것이 좋다.

즉, 비동기 useEffect는 state의 경쟁 상태를 야기할 수 있고 cleanup 함수의 실행 순서도 보장할 수 없기 때문에 개발자의 편의를 위해 useEffect에서 비동기 함수를 인자로 받지 않는다고 볼 수 있다.

## 🖌️ useMemo

useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다.

리액트에서 최적화를 떠올릴 때 가장 먼저 언급되는 훅이 바로 useMemo다.

```jsx
import { useMemo } from "react";

const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b]);
```

- 첫 번째 인수로는 어떠한 값을 반환하는 생성 함수들, 두 번째 인수로는 해당 함수가 의존하는 값의 배열을 전달한다.
- useMemo는 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해 둔 해당 값을 반환하고, 의존성 배열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반환하고 그 값을 다시 기억해둔다.
- 이러한 메모이제이션은 단순히 값뿐만 아니라 컴포넌트도 가능하다.

✅ useMemo를 사용한 컴포넌트 메모이제이션

```jsx
function ExpensiveComponent({ value }) {
  useEffect(() => {
    console.log("rendering!");
  });
  return <span>{value + 1000}</span>;
}

function App() {
  const [value, setValue] = useState(10);
  const [, triggerRendering] = useState(false);

  // 컴포넌트의 props를 기준으로 컴포넌트 자체를 메모이제이션했다.
  const MemoizedComponent = useMemo(
    () => <ExpensiveComponent value={value} />,
    [value]
  );

  function handleChange(e) {
    setValue(Number(e.target.value));
  }

  function handleClick() {
    triggerRendering((prev) => !prev);
  }

  return (
    <>
      <input value={value} onChange={handleChange} />
      <button onClick={handleClick}>렌더링 발생!</button>
      {MemoizedComponent}
    </>
  );
}
```

- useMemo로 컴포넌트도 감쌀 수 있지만 `React.memo`를 쓰는 것이 더 현명하다.
- triggerRendering으로 컴포넌트 렌더링을 강제로 발생시켰지만 MemoizedComponent는 리렌더링되지 않는다. MemoizedComponent는 의존성으로 선언된 value가 변경되지 않는 한 다시 계산되는 일은 없을 것이다.
- useMemo 등 메모이제이션을 활용하면 무거운 연산을 다시 수행하는 것을 막을 수 있다는 장점이 있다.

useMemo는 어떠한 값을 계산할 때 해당 값을 연산하는 데 비용이 많이 든다면 사용해보면 좋다. 비용측정 관련해서는 `2장에 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션` 을 참고하자.

## 🖌️ useCallback

useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. 즉, useCallback은 특정 함수를 새로 만들지 않고 다시 재사용한다는 의미다.

✅ memo를 사용함에도 전체 자식 컴포넌트가 리렌더링되는 예제

```jsx
const ChildComponent = memo({ name, value, onChange }) => {
	// 렌더링이 수행되는지 확인하기 위해 넣었다.
	useEffect(() => {
		console.log('rendering!', name)
	})

	return (
		<>
			<h1>
				{name} {value ? '켜짐' : '꺼짐'}
			</h1>
			<button onClick={onChange}>toggle</button>
		</>
	)
})

function App() {
	const [state1, setStatus1] = useState(false)
	const [state2, setStatus2] = useState(false)

	const toggle = () => {
		setStatus1(!status1)
	}

	const toogle2 = () => {
		setStatus2(!status2)
	}

	return (
		<>
			<ChildComponent name="1" value={status1} onChange={toogle1} />
			<ChildComponent name="2" value={status2} onChange={toogle2} />
		</>
	)
}
```

- memo를 사용해서 컴포넌트를 메모이제이션했지만 App의 자식 컴포넌트 전체가 렌더링되고 있다.
- 위 예제는 ChildComponent에 memo를 사용해 name, value, onChange의 값을 모두 기억하고, 이 값이 변경되지 않았을 때는 렌더링되지 않도록 작성된 코드다.
- 하나의 value 변경이 다른 컴포넌트에 영향을 미쳐서는 안 되고, 클릭할 때마다 하나의 컴포넌트만 렌더링되어야 하는데 어느 한 버튼을 클릭하면 클릭한 컴포넌트 외에도 클릭하지 않은 컴포넌트도 렌더링되는 것을 알 수 있다.
- 그 이유는 state 값이 바뀌면서 App 컴포넌트가 리렌더링되고, 그때마다 매번 onChange로 넘기는 함수가 재생성되고 있기 때문이다.

크롬 메모리 프로필에서 확인하면 다음과 같다.

- toggle을 클릭한 후 확인한 자바스크립트 메모리 스냅샷, toggle만 클릭했을 뿐인데 toggle과 toggle2 모두 다른 포인터를 가리키고 있다.
  → 함수가 매번 재생성되고 있다.
- 값의 메모이제이션을 위해 useMemo를 사용했다면, 함수의 메모이제이션을 위해 사용하는 것이 useCallback이다.
- useCallback의 첫 번째 인수로 함수를, 두 번째 인수로 의존성 배열을 집어 넣으면 useMemo와 마찬가지로 의존성 배열이 변경되지 않는 한 함수를 재생성하지 않는다.

✅ useCallback을 추가한 코드

```jsx
const ChildComponent = memo({ name, value, onChange }) => {
	// 렌더링이 수행되는지 확인하기 위해 넣었다.
	useEffect(() => {
		console.log('rendering!', name)
	})

	return (
		<>
			<h1>
				{name} {value ? '켜짐' : '꺼짐'}
			</h1>
			<button onClick={onChange}>toggle</button>
		</>
	)
})

function App() {
	const [state1, setStatus1] = useState(false)
	const [state2, setStatus2] = useState(false)

	const toggle = useCallback(
		function toggle1() {
			setStatus1(!status1)
		},
		[status1],
	)

	const toggle2 = useCallback(
		function toggle2() {
			setStatus2(!status2)
		},
		[status2],
	)

	return (
		<>
			<ChildComponent name="1" value={status1} onChange={toogle1} />
			<ChildComponent name="2" value={status2} onChange={toogle2} />
		</>
	)
}
```

- useCallback을 추가하면 해당 의존성이 변경됐을 때만 함수가 재생성되는 것을 볼 수 있다. 이처럼 함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 때 useCallback을 사용해 볼 수 있다.

❣️ useCallback에 기명 함수를 넘겨준이유

→ 크롬 메모리 탭에서 디버깅을 용이하게 하기 위해서이다. 익명 함수는 이름이 없어 해당 함수를 추적하기 어렵다.

→ 기명 함수로 선언한 함수를 크롬 개발자 도구에서 디버깅하는 방법은 `7장 크롬 개발자 도구를 활용한 애플리케이션 분석`에서 살펴보자.

❣️ 기본적으로 useCallback은 useMemo를 사용해서 구현할 수 있다.

useMemo와 useCallback의 유일한 차이는 메모이제이션을 하는 대상이 변수냐 함수냐일 뿐이다. 자바스크립트에서는 함수 또한 값으로 표현될 수 있으므로 이러한 코드는 매우 자연스럽다.

```jsx
import { useState, useCallback, useMemo } from "react";

export default function App() {
  const [counter, setCounter] = useState(0);

  /**
   * 아래 두 함수의 작동은 동일하다.
   */
  const handleClick1 = useCallback(() => {
    setCounter((prev) => prev + 1);
  }, []);

  const handleClick2 = useMemo(() => {
    return () => setCounter((prev) => prev + 1);
  }, []);

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick1}>+</button>
      <button onClick={handleClick2}>+</button>
    </>
  );
}
```

- useMemo는 값 자체를 메모이제이션하는 용도이기 때문에 반환문으로 함수 선언문을 반환해야 한다. 따라서 코드를 작성하거나 리뷰하는 입장에서 혼란이 올 수 있기 때문에 함수를 메모이제이션하는 용도라면 좀 더 간단한 useCallback을 사용하는것이 좋다.
- 하지만 useCallback이나 useMemo 모두 동일한 역할을 한다.

## 🖌️ useRef

useRef는 useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다.

✅ useRef와 useState의 차이점

- useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다.

```jsx
function RefComponent() {
  const count = useRef(0);

  function handleClick() {
    count.current += 1;
  }

  // 버튼을 아무리 눌러도 변경된 count 값이 렌더링되지 않는다.
  return <button onClick={handleClick}>{count.current}</button>;
}
```

✅ useRef는 왜 필요한가?

- 렌더링에 영향을 미치지 않는 고정된 값을 관리하기 위해 사용
- 만약 useRef를 사용하지 않고 그냥 함수 외부에서 값을 선언해서 관리할 경우
  - 컴포넌트가 실행되어 렌더링되지 않았음에도 value라는 값이 기본적으로 존재하게 된다 → 메모리에 불필요한 값을 갖게 된다.
  - 컴포넌트가 여러 번 생성된다면 각 컴포넌트에서 가리키는 값이 모두 value로 동일하다.
- 이러한 문제점은 useRef를 사용하여 컴포넌트가 렌더링될 때만 생성되며, 컴포넌트 인스턴스가 여러 개라도 각각 별개의 값을 바라보도록 한다.

useRef의 가장 일반적인 사용 예는 DOM에 접근하고 싶을 때이다.

✅ useRef를 사용한 DOM 접근 예제

```jsx
function RefComponent() {
  const inputRef = useRef();

  // 이때는 미처 렌더링이 실행되기 전(반환되기 전)이므로 undefined를 반환한다.
  console.log(inputRef.current); // undefined

  useEffect(() => {
    console.log(inputRef.current); // <input type="text"></input>
  }, [inputRef]);

  return <input ref={inputRef} type="text" />;
}
```

- useRef는 최초에 넘겨받은 기본값을 가지고 있다.
- useRef의 최초 기본값은 return 문에 정의해 둔 DOM이 아니고 useRef()로 넘겨받은 인수이다.
- useRef가 선언된 당시에는 아직 컴포넌트가 렌더링되기 전이라 return으로 컴포넌트의 DOM이 반환되기 전이므로 undefined다.

useRef를 사용할 수 있는 유용한 경우는 렌더링을 발생시키지 않고 원하는 상태값을 저장할 수 있다는 특징을 활용해 useState의 이전 값을 저장하는 usePrevious() 같은 훅을 구현할 때이다.

```jsx
function usePrevioue(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  }, [value]); // value가 변경되면 그 값을 ref에 넣어둔다.
  return ref.current;
}

function SomeComponent() {
  const [counter, setCounter] = useState(0);
  const previousCounter = usePrevious(counter);

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  // 0 (undefined)
  // 1, 0
  // 2, 1
  // 3, 2
  return (
    <button onClick={handleClick}>
      {counter} {previousCounter}
    </button>
  );
}
```

→ 원하는 시점의 값을 렌더링에 영향을 미치지 않고 보관해 두고 싶다면 useRef를 사용하는 것이 좋다.

✅ Preact에서의 useRef 구현

```jsx
export function useRef(initialValue) {
  currentHook = 5;
  return useMemo(() => ({ current: initialValue }), []);
}
```

- 값이 변경되도 렌더링되면 안된다. → { current: value }와 같은 객체 형태
- 렌더링에 영향을 미치면 안된다. → useMemo에 의도적으로 빈 배열을 선언, 각 렌더링마다 동일한 객체를 가리킴
- 자바스크립트의 객체의 값을 변경해도 객체를 가리키는 주소가 변경되지 않는다는 점을 생각하자.

## 🖌️ useContext

우선 Context에 대해서 알아보자.

### Context란?

리액트 애플리케이션은 기본적으로 부모 컴포넌트와 자식 컴포넌트로 이뤄진 트리 구조를 갖고 있기 때문에 부모가 가지고 있는 데이터를 자식에서도 사용하고 싶다면 props로 데이터를 넘겨주는 것이 일반적이다.

하지만 전달해야 하는 데이터가 있는 컴포넌트와 전달받아야 하는 컴포넌트의 거리가 멀어질수록 코드는 복잡해진다.

A > B > C > D 컴포넌트로 되어있는데 A에서 제공하는 데이터를 D에서 사용하려면 props를 하위 컴포넌트로 필요한 위치까지 계속 넘겨줘야 하는데 이를 `prop 내려주기(props drilling)`라고 한다.

이는 양쪽다 매우 불편하며 이를 극복하기 위해 `콘텍스트(Context)`가 나타났다.

콘텍스트는 명시적인 props 전달 없이도 선언한 하위 컴포넌트 모두에서 자유롭게 원하는 값을 사용할 수 있다.

### Context를 함수 컴포넌트에서 사용할 수 있게 해주는 useContext 훅

```jsx
const Context = (createContext < { hello: string }) | (undefined > undefined);

function ParentComponent() {
  return (
    <>
      <Context.Provider value={{ hello: "react" }}>
        <Context.Provider value={{ hello: "javascript" }}>
          <ChildComponent />
        </Context.Provider>
      </Context.Provider>
    </>
  );
}

function ChildComponent() {
  const value = useContext(Context);

  // react가 아닌 javascript가 반환된다.
  return <>{value ? value.hello : ""}</>;
}
```

- useContext는 상위 컴포넌트에서 만들어진 Context를 함수 컴포넌트에서 사용할 수 있도록 만들어진 훅이다.
- useContext를 사용하면 상위 컴포넌트 어디낙에서 선언된 <Context.Provider />에서 제공한 값을 사용할 수 있게 된다.
- 만약 여러 개의 Provider가 있다면 가장 가까운 Provider의 값을 가져오게 된다.
- 위 예제에서는 가까운 콘텍스트의 값인 javascript가 반환된다.

❣️ useContext로 원하는 값을 얻으려고 했지만 정작 컴포넌트가 실행될 때 이 콘텍스트가 존재하지 않아 예상치 못하게 에러가 발생하는 경우도 있다.

→ 따라서 useContext 내부에서 해당 콘텍스트가 존재하는 환경인지, 콘텍스트가 한 번이라도 초기화되어 값을 내려주고 있는지 확인해봐야 한다.

```jsx
const MyContext = (createContext < { hello: string }) | (undefined > undefined);

function ContextProvider({
  children,
  text,
}: PropsWithChildren<{ text: string }>) {
  return (
    <MyContext.Provider value={{ hello: text }}>{children}</MyContext.Provider>
  );
}

function useMyContext() {
  const context = useContext(MyContext);
  if (context === undefined) {
    throw new Error(
      "useMyContext는 ContextProvider 내부에서만 사용할 수 있습니다."
    );
  }
  return context;
}

function ChildComponent() {
  // 타입이 명확히 설정돼 있어서 굳이 undefined 체크를 하지 않아도 된다.
  // 이 컴포넌트가 Provider 하위에 없다면 에러가 발생할 것이다.
  const { hello } = useMyContext();

  return <>{hello}</>;
}

function ParentComponent() {
  return (
    <>
      <ContextProvider text="react">
        <ChildComponent />
      </ContextProvider>
    </>
  );
}
```

→ 이와 같이 다수의 Provider와 useContext를 사용할 때, 특히 타입스크립트를 사용하고 있다면 별도 함수로 감싸서 사용하는 것이 좋다. 그러면 타입 추론에도 유용하고, 상위에 Provider가 없는 경우에도 사전에 쉽게 에러를 찾을 수 있다.

### useContext를 사용할 때 주의할 점

useContext를 함수 컴포넌트 내부에서 사용할 때는 항상 컴포넌트 재활용이 어려워진다는 점을 염두에 둬야 한다.

useContext가 선언돼 있으면 Provider에 의존성을 가지고 있는 셈이 되므로 아무데서나 재활용하기에는 어려운 컴포넌트가 된다.

해당 함수 컴포넌트가 Provider 하위에 있지 않은 상태로 useContext를 사용한다면 예기치 못한 작동 방식이 만들어진다. 즉, useContext가 있는 컴포넌트는 그 순간부터 눈으로는 직접 보이지도 않을 수 있는 Provider와의 의존성을 갖게 된다.

이를 방지하혀면 useContext를 사용하는 컴포넌트를 최대한 작게 하거나 훅은 재사용되지 않을 만한 컴포넌트에서 사용해야 한다.

콘텍스트가 많아질수록 루트 컴포넌트는 더 많은 콘텍스트로 둘러싸일 것이고 해당 props를 다수의 컴포넌트에서 사용할 수 있게끔 해야 하므로 불필요하게 리소스가 낭비된다. 따라서 콘텍스트가 미치는 범위는 필요한 환경에서 최대한 좁게 만들어야 한다.

콘텍스트와 useContext를 상태 관리를 위한 리액트의 API로 오해할 수 있지만 콘텍스트는 상태를 주입해 주는 API이다. 상태 관리 라이브러리가 되기 위해서는 최소한 다음 두 가지 조건을 만족해야 한다.

1. 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 한다.
2. 필요에 따라 이러한 상태 변화를 최적화할 수 있어야 한다.

→ 콘텍스트는 둘 중 어느 것도 하지 못하기 때문에 단순히 props 값을 하위로 전달해 줄 뿐, useContext를 사용한다고 해서 렌더링이 최적화되지 않는다.

```jsx
const MyContext = (createContext < { hello: string }) | (undefined > undefined);

function ContextProvider({
  children,
  text,
}: PropsWithChildren<{ text: string }>) {
  return (
    <MyContext.Provider value={{ hello: text }}>{children}</MyContext.Provider>
  );
}

function useMyContext() {
  const context = useContext(MyContext);
  if (context === undefined) {
    throw new Error(
      "useMyContext는 ContextProvider 내부에서만 사용할 수 있습니다."
    );
  }
  return context;
}

function GrandChildComponent() {
  const { hello } = useMyContext();

  useEffect(() => {
    console.log("렌더링 GrandChildComponent");
  });

  return <h3>{hello}</h3>;
}

function ChildComponent() {
  useEffect(() => {
    console.log("렌더링 ChildComponent");
  });

  return <GrandChildComponent />;
}

function ParentComponent() {
  const [text, setText] = useState("");

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setText(e.target.value);
  }

  useEffect(() => {
    console.log("렌더링 ParentComponent");
  });

  return (
    <>
      <ContextProvider text="react">
        <input value={text} onChange={handleChange} />
        <ChildComponent />
      </ContextProvider>
    </>
  );
}
```

위 예제 코드의 실행결과는 다음과 같다.

```jsx
렌더링 GrandChildComponent
렌더링 ChildComponent
렌더링 ParentComponent
```

- 컴포넌트 트리 전체가 리렌더링 되고 있는 결과를 확인할 수 있다.
- 그 이유는 부모 컴포넌트가 렌더링되면 하위 컴포넌트는 모두 리렌더링되기 때문이다. ❣️ useContext는 상태를 관리하는 하는 것이 아닌 단순히 상태를 주입하는 것이다.

아래 예제에서 최적화 하려면 ChildComponent가 렌더링되지 않게 막으려면 React.memo를 써야 한다. memo는 props 변화가 없으면 리렌더링되지 않고 계속해서 같은 결과물을 반환한다.

```jsx
const ChildComponent = memo(() => {
  uesEffect(() => {
    console.log("렌더링 ChildComponent");
  });

  return <GrandChildComponent />;
});
```

❣️useContext로 상태 주입을 최적화했다면 반드시 Provider의 값이 변경될 때 어떤 식으로 렌더링되는지 눈여겨봐야 한다. useContext로는 주입된 상태를 사용할 수 있을 뿐, 그 자체로는 렌더링 최적화에 아무런 도움이 안된다.

## 🖌️ useReducer

useReducer는 useState의 심화 버전이다.

useState와 비슷한 형태를 띠지만 좀 더 복잡한 상태값을 미리 정의해 놓은 시나리오에 따라 관리할 수 있다.

- 반환값은 useState와 동일하게 길이가 2인 배열이다.
  - state : 현재 useReducer가 가지고 있는 값을 의미한다. useState와 마찬가지로 배열을 반환하는데, 동일하게 첫 번째 요소가 이 값이다.
  - dispatcher : state를 업데이트하는 함수. useReducer가 반환하는 배열의 두 번째 요소다. setState는 단순히 값을 넘겨주지만 여기서는 action을 넘겨준다는 점이 다르다. 이 action은 state를 변경할 수 있는 액션을 의미한다.
- useState의 인수와 달리 2개에서 3개의 인수를 필요로 한다.
  - reducer : useReducer의 기본 action을 정의하는 함수다. 이 reducer는 useReducer의 첫 번째 인수로 넘겨주어야 한다.
  - initialState : 두 번째 인수로, useReducer의 초깂값을 의미한다.
  - init : useState의 인수로 함수를 넘겨줄 때처럼 초깃값을 지연해서 생성시키고 싶을 때 사용하는 함수다. 이 함수는 필수값이 아니며, 만약 여기에 인수로 넘겨주는 함수가 존재한다면 useState와 동일하게 게으른 초기화가 일어나며 initialState를 인수로 init 함수가 실행된다.

```jsx
// useReducer가 사용할 state를 정의
type State = {
  count: number,
};

// state의 변화를 발생시킬 action의 타입과 넘겨줄 값(payload)을 정의
// 꼭 type과 payload는 네이밍을 지킬 필요도 없으며, 굳이 객체일 필요도 없다.
// 다만 이러한 네이밍이 가장 널리 쓰인다.
type Action = { type: "up" | "down" | "reset", payload?: State };

// 무거운 연산이 포함된 게으른 초기화 함수
function init(count: State): State {
  // count: State를 받아서 초깃값을 어떻게 정의할지 연산하면 된다.
  return count;
}

// 초깃값
const initialState: State = { count: 0 };

// 앞서 선언한 state와 action을 기반으로 state가 어떻게 변경될지 정의
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "up":
      return { count: state.count + 1 };
    case "down":
      return { count: state.count - 1 > 0 ? state.count - 1 : 0 };
    case "reset":
      return init(action.payload || { count: 0 });
    default:
      throw new Error(`Unexpected action type ${action.type}`);
  }
}

export default function App() {
  const [state, dispatcher] = useReducer(reducer, initialState, init);

  function handleUpButtonClick() {
    dispatcher({ type: "up" });
  }

  function handleDownButtonClick() {
    dispatcher({ type: "down" });
  }

  function handleResetButtonClick() {
    dispatcher({ type: "reset", payload: { count: 1 } });
  }

  return (
    <div className="App">
      <h1>{state.count}</h1>
      <button onClick={handleUpButtonClick}>+</button>
      <button onClick={handleDownButtonClick}>-</button>
      <button onClick={handleResetButtonClick}>reset</button>
    </div>
  );
}
```

useReducer는 복잡한 형태의 state를 사전에 정의된 dispatcher로만 수정할 수 있게 만들어 주고 state 값에 대한 접근은 컴포넌트에서만 가능하게 하고, 이를 업데이트하는 방법에 대한 상세 정의는 컴포넌트 밖에다 둔 다음, state의 업데이트를 미리 정의해 둔 dispatcher로만 제한하는 것이다.

state 값을 변경하는 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게끔 하는 것이 useReducer의 목적이다.

값이 간단하거나 적으면 useState로 충분하지만 그렇지않으면 성격이 비슷한 state끼리 묶어 useReducer로 관리하는 것이 더 효율적이다.

→ useReducer를 사용해 state를 관리하면 state를 사용하는 로직과 이를 관리하는 비즈니스 로직을 분리할 수 있어 state를 관리하기가 쉬워진다.

세 번째 인수인 게으른 초기화 함수는 사용하지 않아도 무관하다. 이 함수가 없으면 두 번째 인수로 넘겨받은 기본값을 사용하게 된다.

만약 게으른 초기화 함수를 넣어주면 useState에 함수를 넣은 것과 같은 동일한 이점을 누릴 수 있고, 추가로 state에 대한 초기화가 필요할 때 reducer에서 이를 재사용할 수 있다는 장점이 있다.

⁉️ useState와 useReducer는 어떤 차이가 있을까?

→ Preact의 useState 코드를 살펴보면 useReducer로 구현돼 있는 것을 알 수 있다.

✅ Preact가 구현한 useState

```jsx
/**
 * @param {import('./index').StateUpdater<any>} [initialState]
 */
export function useState(initialState) {
  currentHook = 1;
  return useReducer(invokeOrReturn, initalState);
}
```

✅ useReducer로 useState 구현 예제

```jsx
function reducer(prevState, newState) {
  return typeof newState === "function" ? newState(prevState) : newState;
}

function init(initialArg: Initializer) {
  return typeof initialArg === "function" ? initialArg() : initialArg;
}

function useState(initialArg) {
  return useReducer(reducer, initialArg, init);
}
```

- `reducer()` : 값을 업데이트하는 함수이거나 값 그 자체
- `init()` : 초깃값이기 때문에 별다른 처리를 할 필요가 없다. 세 번째 값은 이 두 번째 값을 기반으로 한 게으른 초기화를 하는 함수다. → 함수이면 실행해 값을 반환해야 한다.
- reducer()와 initialArg() 함수를 사용하여 useReducer에서 사용하면 `useState()`의 작동을 흉내 낼 수 있다.

반대로 useReducer를 useState로 구현할 수도 있다.

```jsx
const useReducer = (reducer, initialArg, init) => {
  const [state, setState] = useState(
    // 초기화 함수가 있으면 초기값과 초기화 함수를 실행하고, 그렇지 않으면 초깃값을 넣는다.
    init ? () => init(initialArg) : initialArg
  );

  // 값을 업데이트하는 dispatch를 넣어준다.
  const dispatch = useCallback(
    (action) => setState((prev) => reducer(prev, action)),
    [reducer]
  );

  // 이 값을 메모이제이션한다.
  return useMemo(() => [state, dispatch], [state, dispatch]);
};
```

🥕 즉, useReducer나 useState 둘 다 세부 작동과 쓰임에만 차이가 있을 뿐, 결국 클로저를 활용해 값을 가둬서 state를 관리한다. 따라서 필요에 따라 `useReducer`나 `useState`를 선택하여 사용하면 된다.

## 🖌️ useImperativeHandle

`useImperativeHandle`는 실제 개발 과정에서는 자주 쓰이지 않지만 유용하게 활용될 수 있다.

useImperativeHandle을 이해하기 위해서는 먼저 React.forwardRef에 대해 알아야 한다.

### forwardRef 살펴보기

ref는 useRef에서 반환한 객체로, 리액트 컴포넌트의 props인 ref에 넣어 HTMLElement에 접근하는 용도로 흔히 사용된다.

key와 마찬가지로 ref도 리액트에서 컴포넌트의 props로 사용할 수 있는 예약어로서 별도로 선언돼 있지 않아도 사용할 수 있다.

⁉️ 만약 ref를 상위 컴포넌트에서 하위 컴포넌트로 전달하고 싶으면 (즉, 상위 컴포넌트에서는 접근하고 싶은 ref가 있지만 이를 직접 porps로 넣어 사용할 수 없을때) 어떻게 해야 할까?

```jsx
function ChildComponent({ parentRef }) {
  useEffect(() => {
    // {current: undefined}
    // {current: HTMLInputElement}
    console.log(parentRef);
  }, [parentRef]);

  return <div>안녕!</div>;
}

function ParentComponent() {
  const inputRef = useRef();

  return (
    <>
      <input ref={inputRef} />
      <ChildComponent parentRef={inputRef} />
    </>
  );
}
```

→ 클래스 컴포넌트나 함수 컴포넌트에서 동일하게 작동한다.

`forwardRef`는 위 코드와 동일한 작업을 하는 리액트 API이다.

단순히 props로 구현할 수 있는 데 forwardRef가 탄생한 이유는 ref를 전달하는 데 있어서 일관성을 제공하기 위해서이다.

`forwardRef`를 사용하면 어떤 props명으로 전달할지 모르고, 이에 대한 완전한 네이밍의 자유가 주어진 props보다는 forwardRef를 사용하면 좀 더 확실하게 ref를 전달할것이며, 사용하는 쪽에서도 안정적으로 받아서 사용할 수 있다.

✅ forwardRef를 사용하는 예

```jsx
const ChildComponent = forwardRef((props, ref) => {
  useEffect(() => {
    // {current: undefined}
    // {current: HTMLInputElement}
  }, [ref]);

  return <div>안녕!</div>;
});

function ParentComponent() {
  const inputRef = useRef();

  return (
    <>
      <input ref={inputRef} />
      <ChildComponent ref={inputRef} />
    </>
  );
}
```

- ref를 받고자 하는 컴포넌트를 forwardRef로 감싸고, 두 번째 인수로 ref를 전달받는다.
- 리고 부모 컴포넌트에서는 동일하게 props.ref를 통해 ref로 넘겨주면 된다.
- 이와같이 foreardRef를 사용하는 코드로 수정하면 ref를 props로 전달할 수 있고, 전달받은 컴포넌트에서도 ref라는 이름을 그대로 사용할 수 있다.

### useImperativeHandle이란?

`useImperativeHandle`은 부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅이다.

✅ useImperativeHandle의 활용법

```jsx
const Input = forwardRef((props, ref) => {
  // useImperativeHandle을 사용하면 ref의 동작을 추가로 정의할 수 있다.
  useImperativeHandle(
    ref,
    () => ({
      alert: () => alert(props.value),
    }),
    // useEffect의 deps와 같아.
    [props.value]
  );
  return <input ref={ref} {...props} />;
});

function App() {
  // input에 사용할 ref
  const inputRef = useRef();
  // input의 value
  const [text, setText] = useState("");

  function handleClick() {
    // inputRef에 추가한 alert라는 동작을 사용할 수 있다.
    inputRef.current.alert();
  }

  function handleChange(e) {
    setText(e.target.value);
  }

  return (
    <>
      <Input ref={inputRef} value={text} onChange={handleChange} />
      <button onClick={handleClick}>Focus</button>
    </>
  );
}
```

- useImperativeHandle을 사용하면 부모 컴포넌트에서 노출되는 값을 원하는 대로 바꿀 수 있다.(`ref의 값에 원하는 값이나 액션을 정의할 수 있다.`)
  - 원래 ref는 {current: <HTMLElement>}와 같은 형태로 HTMLElement만 주입할 수 있었는데 ref에 useImperativeHandle 훅을 사용해 추가적인 동작을 정의했다.
  - 따라서 부모는 단순히 HTMLElement뿐만 아니라 자식 컴포넌트에서 새롭게 설정한 객체의 키와 값에 대해서도 접근할 수 있게 되었다.

## 🖌️ useLayoutEffect

useLayoutEffect는 `함수의 시그니처가 useEffect와 동일`하다. → 두 훅의 형태나 사용 예제가 동일하다는 것을 의미한다.

✅ useEffect와 useLayoutEffect의 사용법 비교

```jsx
function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("useEffect", count);
  }, [count]);

  useLayoutEffect(() => {
    console.log("useLayoutEffect", count);
  }, [count]);

  function handleClilck() {
    setCount((prev) => prev + 1);
  }

  return (
    <>
      <h1>{count}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}
```

- useEffect와 useLayoutEffect를 사용한 예제 코드는 모두 동일한 모습으로 작동한다.

❣️모든 DOM의 변경 후에 useLayoutEffect의 콜백 함수 실행이 동기적으로 발생한다.

→ 여기서의 DOM 변경이란 렌더링이지, 브라우저에 실제로 해당 변경 사항이 반영되는 시점을 의미하는 것이 아니다. 즉, 실행 순서는 다음과 같다.

1. 리액트가 DOM을 업데이트
2. useLayoutEffect를 실행
3. 브라우저에 변경 사항을 반영
4. useEffect를 실행

⇒ useEffect가 먼저 선언돼 있지만 항상 useLayoutEffect가 useEffect보다 먼저 실행된다. 그 이유는 useLayoutEffect가 브라우저에 변경 사항이 반영되기 전에 실행되는 반면 useEffect는 브라우저에 변경 사항이 반영된 이후에 실행되기 때문이다.

⇒ 또한 동기적으로 발생한다는 것은 리액트는 useLayoutEffect의 실행이 종료될 때까지 기다린 다음에 화면을 그린다는 것을 의미한다. 즉, 리액트 컴포넌트는 useLayoutEffect가 완료될 때까지 기다리기 때문에 컴포넌트가 잠시 동안 일시 중지되는 것과 같은 일이 발생하게 된다.

⇒ 따라서 이러한 작동 방식으로 인해 웹 애플리케이션 성능에 문제가 발생할 수 있다.

⁉️ 언제 useLayoutEffect를 사용하는 것이 좋을까?

useLayoutEffect의 특징상 DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때와 같이 반드시 필요할 때만 사용하는 것이 좋다.

특정 요소에 따라 DOM 요소를 기반으로 한 애니메이션, 스크롤 위치를 제어하는 등 화면에 반영되기 전에 하고 싶은 작업에 useLayoutEffect를 사용한다면 useEffect를 사용했을 때보다 훨씬 더 자연스러운 사용자 경험을 제공할 수 있다.

## 🖌️ useDebugValue

`useDebugValue`는 일반적으로 프로덕션 웹서비스에서 사용하는 훅이 아니다. 이 훅은 리액트 애플리케이션을 개발하는 과정에서 사용되는데, 디버깅하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있다.

✅ useDebugValue를 사용하는 코드

```jsx
// 현재 시간을 반환하는 사용자 정의 훅
function useDate() {
	const date = new Date()
	// useDebugValue로 디버깅 정보를 기록
	useDebugValue(date, (date) => `현재 시간: ${date.toISOString()}`)
	return date
}

export default function App() {
	const date = useDate()
	const [counter, setCounter] = useState(0)  // 렌더링을 발생시키기 위한 변수

	function handleClick() {
		setCounter((prev) => prev +1)
	}

	return (
		<div>
			<h1>
				{counter} {date.toISOString()}
			</h1>
			<button onClick={handleClick}>+</button>
		</div>
	)
```

![Untitled](https://github.com/user-attachments/assets/dc3f3e6d-e2a6-4809-9296-4fc19cc83c2a)

실행 결과, 리액트 개발자 도구로 확인하면 이와 같다.

useDebugValue는 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅이다. 두 번째 인수로 포매팅 함수를 전달하면 이에 대한 값이 변경됐을 때만 호출되어 포매팅된 값을 노출한다. (즉, 첫 번째 인수의 값이 같으면 포매팅 함수는 호출되지 않는다.)

useDebugValue를 사용할 때는 오직 다른 훅 내부에서만 실행할 수 있다. 만약 컴포넌트 레벨에서 실행한다면 작동하지 않을 것이다.

따라서 공통 훅을 제공하는 라이브러리나 대규모 웹 애플리케이션에서 디버깅 관련 정보를 제공하고 싶을 때 유용하게 사용할 수 있다.

## 🖌️ 훅의 규칙

리액트에서 제공하는 훅은 사용하는 데 몇 가지 규칙이 존재하는데 이러한 규칙을 rules-of-hooks라고 하며 이와 관련된 ESLint 규칙인 react-hooks/rules-of-hooks도 존재한다.

이 훅을 사용하는 규칙은 다음과 같다.

1. 최상위에서만 훅을 호출해야 한다. 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다. 이 규칙을 따라야만 컴포넌트가 렌더링될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.
2. 훅을 호출할 수 있는 것은 리액트 함수 컴포넌트, 혹은 사용자 정의 훅의 두 가지 경우뿐이다. 일반 자바스크립트 함수에서는 훅을 사용할 수 없다.

useState의 구현에서 보여줬던 것처럼 훅에 대한 정보 저장은 리액트 어딘가에 있는 index와 같은 키를 기반으로 구현돼 있다(실제로는 객체 기반 링크드 리스트에 더 가깝다).

즉, useState나 useEffect는 모두 순서에 아주 큰 영향을 받는다.

다음 예제 코드로 확인해보자.

```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [required, setRequired] = useState(false);

  useEffect(() => {
    //do something...
  }, [coust, required]);
}
```

위 컴포넌트는 파이버에서 다음과 같이 저장된다.

```jsx
{
	memoizedState: 0, // setCount 훅
	baseState: 0,
	queue: { /* ... */},
	baseUpdate: null,
	next: { // setRequired 훅
		memoizedState: false,
		baseState: false,
		queue: { /* ... */},
		baseUpdate: null,
		next: { // useEffect 훅
			memoizedState: {
				tag: 192,
				create: () => {},
				destroy: undefined,
				deps: [0, false],
				next: { /* ... */},
			},
			baseState: false,
			queue: { /* ... */},
			baseUpdate: null,
		}
	}
}
```

- 리액트 훅은 파이버 객체의 링크드 리스트의 호출 순서에 따라 저장된다. 그 이유는 각 훅이 파이버 객체 내에서 순서에 의존해 state나 effect의 결과에 대한 값을 저장하고 있기 때문이다.
  → 이렇게 고정된 순서에 의존해 훅과 관려된 정보를 저장함으로써 이전 값에 대한 비교와 실행이 가능해진다.

만약 이러한 순서를 보장받을 수 없는 상황이라면 어떻게 될까?

→ 링크드 리스트가 깨져버려 조건이나 다른 이슈로 인해 훅의 순서가 깨지거나 보장되지 않을 경우 리액트 코드는 에러를 발생시킨다. 아래 코드로 확인해보자.

```jsx
// 최초 렌더링
useState("Mary"); // 1. 'Mary' 할당
useEffect(persistForm); // 2. 1에 있던 state를 기반으로 effect 실행
useState("Poppins"); // 3. 'Poppins' 할당
useEffect(updateTitle); // 4. 3에 있는 35를 기반으로 effect 실행

// 두 번째 렌더링
useState("Mary"); // 1. state를 읽음(useState의 인수는 첫 번째 렌더링에서 초깃값으로 사용됐으므로 여기에서 인수값은 무시되고, 이전에 저장돼 두었던 Mary 값이 사용된다.)
// useEffect(persistForm)  // 조건문으로 인해 실행이 안 됨
useState("Poppins"); // 2. 원래는 3이었음. 이제 2가 되면서 useState의 값을 읽어오지 못하고 비교도 할 수 없음
useEffect(updateTitle); //3. 원래는 4였음. updateTitle을 하기 위한 함수를 대체하는 데 실패
```

따라서 절대 조건문, 반복문 등에 의해 리액트에서 예측 불가능한 순서로 실행하게 해서는 안 된다. 항상 훅은 실행 순서를 보장받을 수 있는 컴포넌트 최상단에 선언돼 있어야 한다. 조건문이 필요하다면 반드시 훅 내부에서 수행해야 한다.

# 📑 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

자바스크립트에서 재사용 로직을 작성하는 방식 외에도 리액트에서는 재사용할 수 있는 로직을 관리할 수 있는 두 가지 방법이 있다.

1. 사용자 정의 훅
2. 고차 컴포넌트

각각 무엇이며 어떻게 쓰는지, 공통된 코드를 하나로 만들고자 할 때 어떤 것을 선택해야 하는지 살펴보자.

## 🖌️ 사용자 정의 훅

서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용되는 것이 바로 사용자 정의 훅이다.

또한 고차 컴포넌트는 굳이 리액트가 아니더라도 사용할 수 있는 기법이지만 사용자 정의 훅은 리액트에서만 사용할 수 있는 방식이다.

사용자 정의 훅의 규칙 중 하나는 이름이 반드시 use로 시작하는 함수를 만들어야 한다.

리액트 훅의 이름은 use로 시작한다는 규칙이 있으며, 사용자 정의 훅도 이러한 규칙을 준수함으로써 개발 시 해당 함수가 리액트 훅이라는 것을 바로 인식할 수 있다는 장점도 있다.

다음은 HTTP 요청을 하는 fetch를 기반으로 한 사용자 정의 훅을 만든 예제다. 이 예제를 기초로 사용자 정의 훅이란 무엇인지 살펴보자.

✅ fetch를 수행하는 useFetch 예제와 실제 사용 예제

```jsx
import { useEffect, useState } from 'react'

// HTTP 요청을 하는 사용자 정의 훅
function useFetch<T>(
	url: string,
	{ method, body }: { method: string; body?: XMLHtmlRequestBodyInit },
) {
	// 응답 결과
	const [result, setResult] = useState<T | undefined>()
	// 요청 중 여부
	const [isLoading, setIsLoading] = useState<boolean>(false)
	// 2xx, 3xx로 정상 응답인지 여부
	const [ok, setOk] = useState<boolean | undefined>()

	//HTTP status
	const [status, setStatue] = useState<number> | undefined>()

	useEffect(() => {
		const abortController = new AbortController()

		;(async () => {

			const response = await fetch(url, {
				method,
				body,
				signal: abortController.signal,
			})

			setOk(response.ok)
			setStatus(response.status)

			if (response.ok) {
				const apiResult = await response.json()
				setResult(apiResult)
			}

			setIsLoading(false)
		})()

		return () => {
			abortController.abort()
		}
	}, [url, method, body])

	return { ok, result, isLoading, statue }
}

interface Todo {
	userId: number,
	id: number,
	title: string,
	completed: boolean
}

export default function App() {
	// 사용자 지정 훅 사용
	const { isLoading, result, statue, ok } = useFetch<Array<Todo>>(
		'https://jsonplaceholder.typicode.com/todos',
		{
			methid: 'GET',
		}
	)

	useEffect(() => {
		if (!isLoading) {
			console.log('fetchResult >>', status)
		}
	}, [status, isLoading])

	return (
		<div>
			{ok
				? (result || []).map(({ userId, title }, index) => (
					<div key={index}>
						<p>{userId}</p>
						<p>{title}</p>
					</div>
				))
			: null}
		</div>
	)

}

```

- fetch를 이용해 API를 호출하는 로직을 사용자 정의 훅으로 분리한 예제이다. 만약 훅으로 분리하지 않았다면 fetch로 API 호출을 해야 하는 모든 컴포넌트 내에서 공통적으로 관리되지 않는 최소 4개의 state를 선언해서 각각 구현했어야 할 것이다.
- 이렇게 복잡하고 반복되는 로직은 사용자 정의 훅으로 간단하게 만들 수 있다. 훅에서 필요한 useState와 useEffect 로직을 사용자 정의 훅인 useFetch 내부에 두면 사용하는 쪽에서는 useFetch 훅만 사용해도 손쉽게 중복되는 로직을 관리할 수 있다.

이와 같이 use라는 이름을 지켜야 하는 이유는 사용자 정의 훅은 내부에 useState와 useEffect 등을 가지고 자신만의 원하는 훅을 만드는 기법으로, 내부에서 useState와 같은 리액트 훅을 사용하고 있기 때문에 당옇니 앞서 언급한 리액트 훅의 규칙을 따라야 한다.

또한 이 리액트 훅의 규칙을 따르고 react-hooks/rules-of-hooks의 도움을 받기 위해서는 use로 시작하는 이름을 가져야 한다. 그렇지 않으면 아래와 같이 에러가 발생한다.

```jsx
// 이름을 useFetch에서 fetch로 바꿨다.
function fetch<T>(
	url: string,
	{ method, body }: { method: string; body?: XMLHttpRequestBodyInit},
) {
	//React Hook "useState" is called in function "fetch" that is neither
	// a React function component nor a custom React Hook function. React component
	// names must start with an upperacase letter. (react-hooks/rules-of-hooks)
	const [result, setResult] = useState<T | undefined>()
	// ...
}
```

- fetch로 작성한 함수 내부에서 useState를 사용했더니 에러가 발생했다. react-hooks/rules-of-hooks가 지적하는 바는 훅은 함수 컴포넌트 내부 또는 사용자 정의 훅 내부에서만 사용할 수 있다.
- 해결방법은 `fetch의 앞부분을 대문자로 바꿔 함수 컴포넌트라고 알리는 방법`, 혹은 `use를 앞에 붙여 사용자 정의 훅이라고 알리는 방법`이 있다.
  ⇒ 이 두가지 방법 모두 정적 분석을 수행하는 ESLint와 react-hooks/rules-of-hooks가 경고할 수 있는 최선의 방법이다.
  ⇒ 실제로 함수 컴포넌트로, 훅은 사용자 정의 훅으로 사용하는 것은 개발자의 몫이다.

🥕 이러한 사용자 정의 훅은 리액트 커뮤니티에서 다양하게 찾아볼 수 있는데, 유명한 저장소로 use-Hooks, react-use, ahooks 등이 있다. 필요한 기능이 있다면 이 훅에서 도움을 구할 수 있고, 각 훅을 살펴보면서 어떤 식으로 구현돼 있는지 살펴보는 것도 리액트를 공부하는 데 많은 도움이 될 것이다.

## 🖌️ 고차 컴포넌트

고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 자체의 로직을 재사용하기 위한 방법이다.

사용자 정의 훅은 리액트 훅을 기반으로 하므로 리액트에서만 사용할 수 있는 기술이지만 고차 컴포넌트는 고차 함수(Higher Order Function)의 일종으로, 자바스크립트의 일급 객체, 함수의 특징을 이용하므로 굳이 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있다.

리액트에서는 이러한 고차 컴포넌트 기법으로 다양한 최적화나 중복 로직 관리를 할 수 있다. 리액트에서 가장 유명한 고차 컴포넌트는 리액트에서 제공하는 API 중 하나인 React.memo이다.

### React.memo란?

React.memo를 이해하려면 렌더링에 대해 이해하고 있어야 한다.

리액트 컴포넌트가 렌더링하는 조건에는 여러 가지가 있지만 그중 하나는 바로 부모 컴포넌트가 새롭게 렌더링될 때이다 이는 자식 컴포넌트의 props 변경 여부와 관계없이 발생한다.

아래 코드를 보고 확인해보자.

```jsx
const ChildComponent = ({ value }: { value: string }) => {
  useEffect(() => {
    console.log("렌더링!");
  });

  return <>안녕하세요! {value}</>;
};

function ParentComponent() {
  const [state, setState] = useState(1);

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setState(Number(e.target.value));
  }

  return (
    <>
      <input type="number" value={state} onChange={handleChange} />
      <ChildComponent value="hello" />
    </>
  );
}
```

- ChildComponent는 props인 value=”hello”가 변경되지 않았는데도 handleChange로 인해 setState를 실행해 state를 변경하므로 리렌더링이 발생한다.

이와같이 props의 변화가 없음에도 컴포넌트의 렌더링을 방지하기 위해 만들어진 리액트의 고차 컴포넌트가 React.memo이다.

React.memo는 렌더링하기 전에 props를 비교해 이전과 props가 같아면 렌더링 자체를 생략하고 이전에 기억해 둔(memoization) 컴포넌트를 반환한다.

아래 예제는 `memo`를 감싼 예제이다.

```jsx
const ChildComponent = memo(({ value }: { value: string }) => {
  useEffect(() => {
    console.log("렌더링!");
  });

  return <>안녕하세요! {value}</>;
});

function ParentComponent() {
  const [state, setState] = useState(1);

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setState(Number(e.target.value));
  }

  return (
    <>
      <input type="number" value={state} onChange={handleChange} />
      <ChildComponent value="hello" />
    </>
  );
}
```

- 이 코드는 ParentComponent에서 아무리 state가 변경돼도 ChildComponent는 다시 렌더링되지 않는다. 그 이유는 props가 변경되지 않았고, 변경되지 않았다는 것을 memo가 확인하고 이전에 기억한 컴포넌트를 대로 반환한 것이다.
- 즉 불필요한 렌더링 작업을 생략할 수 있게 되었다. 이 방식은 앞에서 클래스 컴포넌트에서 소개했던 PureComponent와 매우 유사하다.

### 고차 함수 만들어보기

리액트의 함수 컴포넌트도 결국 함수이기 때문에 함수를 기반으로 고차 함수를 만드는 것을 먼저 이해해야 한다.

고차 함수의 사전적 정의는 “함수를 인수로 받거나 결과로 반환하는 함수”라고 정의되어 있다.

가장 대표적인 고차 함수로는 리액트에서 배열을 렌더링할 때 자주 사용하는 Array.prototype.map을 예로 들 수 있다.

다음 예제를 통해 고차 함수가 무엇인지 알아보자.

```jsx
const list = [1, 2, 3]
const doubledList = list.map((item) item * 2)
```

→ map을 비롯해 forEach나 reduce 등도 함수를 인수로 받기 때문에 고차 함수이다.

```jsx
// 즉시 실행 함수로 setter를 만든다.
const setState = (function () {
  // 현재 index를 클로저로 가둬놔서 이후에도 계속해서 동일한 index에 접근할 수 있도록 한다.
  let currentIndex = index;
  return function (value) {
    global.states[currentIndex] = value;
    // 컴포넌트를 렌더링한다. 실제로 컴포넌트를 렌더링하는 코드는 생략했다.
  };
})();
```

- 이 예제는 setState 함수를 구현한 예제이다. 이 setState는 useState에서 반환된 두 번째 배열의 값으로 실행할 수 있는 함수를 반환한다.
- 이 함수도 `‘함수를 결과로 반환하는’` 이라는 조건을 만족하므로 고차 함수라고 할 수 있다.

이번에는 직접 고차 함수를 만들어 보자.

```jsx
function add(a) {
  return function (b) {
    return a + b;
  };
}

const result = add(1); // 여기서 result는 앞서 반환한 함수를 가리킨다.
const result2 = result(2); // 비로소 a와 b를 더한 3이 반환된다.
```

- add(1)라는 함수를 호출하는 시점에 1이라는 정보가 a에 포함되고, 이러한 정보가 담긴 함수를 result로 반환된다. → useState의 원리와 비슷하다.
- useState의 실행은 함수 호출과 동시에 끝났지만 state의 값은 별도로 선언한 환경, 즉 클로저에 기억된다. 여기에서도 마찬가지로 a=1이라는 정보가 담긴 클로저가 result에 포함됐고, result(2)를 호출하면서 이 클로저에 담긴 a=1인 정보를 활용해 1 + 2의 결과를 반환할 수 있게 됐다.
- 이처럼 고차 함수를 활용하면 함수를 인수로 받거나 새로운 함수를 반환해 완전히 새로운 결과를 만들어 낼 수 있다.
  → 리액트의 함수 컴포넌트도 함수이므로 고차 함수를 사용하면 다양한 작업을 할 수 있다.

### 고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기

사용자 인증 정보에 따라서 인증된 사용자에게는 개인화된 컴포넌트를, 그렇지 않은 사용자에게는 별도의 정의된 공통 컴포넌트를 보여주는 시나리오를 코드로 구현해보자.

```jsx
interface LoginProps {
	loginRequired?: boolean
}

function withLoginComponent<T>(Component: ComponentType<T>) {
	return function (props: T & LoginProps) {
		const { loginRequired, ...restProps } = props

		if (loginRequired) {
			return <>로그인이 필요합니다.</>
		}

		return <Component {...(restProps as T)} />
	}
}

// 원래 구현하고자 하는 컴포넌트를 만들고, withLoginComponent로 감싸기만 하면 끝난다.
// 로그인 여부, 로그인이 안 되면 다른 컴포넌트를 렌더링하는 책임은 모두 고차 컴포넌트인 withLoginComponent에 맡길 수 있어 매우 편리하다.
const Component = withLoginComponent((props: { value: string }) => {
	return <h3>{props.value}</h3>
})

export default function App() {
	// 로그인 관련 정보를 가져온다.
	const isLogin = true
	return <Component value="text" loginRequired={isLogin} />
	// return <Component value="text" />;
}
```

- `Component`는 일반적인 함수 컴포넌트와 같은 평범한 컴포넌트지만, 이 함수 자체를 `withLoginComponent`라 불리는 고차 컴포넌트로 감싸뒀다. withLoginComponent는 함수(함수 컴포넌트)를 인수로 받으며, 컴포넌트를 반환하는 고차 컴포넌트다. 이 컴포넌트는 props에 loginRequired가 있다면 넘겨받은 함수를 반환하는 것이 아니라 “로그인이 필요합니다”라는 전혀 다른 결과를 반환하게 되어 있다.
- loginRequired가 없거나 false라면 원래의 함수 컴포넌트가 반환해야 할 결과를 그대로 반환한다.

고차 컴포넌트는 컴포넌트 전체를 감쌀 수 있다는 점에서 사용자 정의 훅보다 더욱 큰 영향력을 컴포넌트에 미칠 수 있다. 단순히 값을 반환하거나 부수 효과를 실행하는 사용자 정의 훅과는 다르게, 고차 컴포넌트는 컴포넌트의 결과물에 영향을 미칠 수 있는 다른 공통된 작업을 처리할 수 있다.

❣️ 주의사항

- 사용자 정의 훅이 use로 시작하는 이름을 사용햇다면 리액트의 고차 컴포넌트도 마찬가지로 `with`로 시작하는 이름을 사용해야 한다.
- 고차 컴포넌트를 사용할 때 부수 효과를 최소화해야 한다.
  - 고차 컴포넌트는 반드시 컴포넌트를 인수로 받게 되는데, 반드시 컴포넌트의 props를 임의로 수정, 추가, 삭제하는 일은 없어야 한다.
  - ex) loginRequired라는 props를 추가했을 뿐, 기존에 인수로 받는 컴포넌트의 props는 건드리지 않았다.
  - 만약 컴포넌트에 무언가 추가적인 정보를 제공해 줄 목적이라면 별도 props로 내려주는 것이 좋다.
- 여러 개의 고차 컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커진다.
  ```jsx
  const Component = withHigherOrderComponent1(
    withHigherOrderComponent2(
      withHigherOrderComponent3(
        withHigherOrderComponent4(
          withHigherOrderComponent5(() => {
            return <>안녕하세요.</>;
          })
        )
      )
    )
  );
  ```
  - 고차 컴포넌트가 검포넌트를 또 다른 컴포넌트로 감싸는 구조로 되어 있다 보니, 여러 개의 고차 컴포넌트가 반복적으로 컴포넌트를 감쌀 경우 복잡성이 매우 커진다.
  - 따라서 고차 컴포넌트는 최소한으로 사용하는 것이 좋다.

## 🖌️ 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

사용자 정의 훅과 고차 컴포넌트 모두 리액트 코드에서 어떠한 로직을 공통화해 별도로 관리할 수 있다는 특징이 있다.

애플리케이션 전반에 필요한 중복된 로직을 별도로 분리해 컴포넌트의 크기를 줄이고 가독성을 향상시키는 데 도움을 줄 수 있다.

그럼 어떤 경우 각각 `사용자 정의 훅` 또는 `고차 컴포넌트`를 써야할까?

### 사용자 정의 훅이 필요한 경우

단순히 useEffect, useState와 같이 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋다.

사용자 정의 훅은 그 자체로는 렌더링에 영향을 미치지 못하기 때문에 사용이 제한적이므로 반환하는 값을 바탕으로 무엇을 할지는 개발자에게 달려있다.

컴포넌트 내부에 미치는 영향을 최소화해 개발자가 훅을 원하는 방향으로만 사용할 수 있다는 장점이 있다.

아래 예제로 확인해보자.

```jsx
// 사용자 정의 훅을 사용하는 경우
function HookComponent() {
	const { loggedIn } = useLogin()

	useEffect(() => {
		if (!loggendIn) {
			// ...
		}
	}, [loggedIn])
)

// 고차 컴포넌트를 사용하는 경우
const HOCComponent = withLoginComponent(() => {
	// ...
})
```

- 로그인 정보를 가지고 있는 훅인 useLogin은 단순히 loggedIn에 대한 값만 제공할 뿐, 이에 대한 처리는 컴포넌트를 사용하는 쪽에서 원하는 대로 사용 가능하다. → 부수 효과가 비교적 제한적
- 반면 withLoginComponent는 고차 컴포넌트가 어떤 일을 하는지, 어떤 결과물을 반환할지는 고차 컴포넌트를 직접 보거나 실행하기 전까지는 알 수 없다. → 대부분 고차 컴포넌트는 렌더링에 영향을 미치는 로직이 존재하므로 사용자 정의 훅에 비해 예측하기가 어렵다.
- 따라서 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나 특정안 훅의 작동을 취하게 하고 싶다면 사용자 정의 훅을 사용하는 것이 좋다.

### 고차 컴포넌트를 사용해야 하는 경우

만약 로그인되지 않은 어떤 사용자가 컴포넌트에 접근하려 할 때 애플리케이션 관점에서 컴포넌트를 감추고 로그인을 요구하는 공통 컴포넌트를 노출하는 것이 좋을 수 있다.

혹은 에러 바운더리와 비슷하게 어떤 특정 에러가 발생했을 때 현재 컴포넌트 대신 에러가 발생했음을 알릴 수 있는 컴포넌트를 노출하는 경우도 있을 것이다.

```jsx
function HookComponent() {
  const { loggedIn } = useLogin();

  if (!loggedIn) {
    return <LoginComponent />;
  }

  return <>안녕하세요.</>;
}

const HOCComponent = withLoginComponent(() => {
  // loggedIn state의 값을 신경 쓰지 않고 그냥 컴포넌트에 필요한 로직만 추가해서 간단해졌다.
  // loggedIn state에 따른 제어는 고차 컴포넌트에서 해줄 것이다
  return <>안녕하세요</>;
});
```

- 만약 이 작업을 사용자 정의 훅에서 표현하고자 하려해도 loggedIn이 false인 경우에 렌더링해야 하는 컴포넌트는 동일하지만 사용자 정의 훅만으로는 이를 표현하기 어렵다.
- 사용자 정의 훅은 해당 컴포넌트가 반환하는 렌더링 결과물에까지 영향을 미치기는 어렵기 때문이다.
- 그리고 이러한 중복 처리가 해당 사용자 정의 훅을 사용하는 애플리케이션 전반에 걸쳐 나타나게 될 것이므로 사용자 정의 훅보다는 고차 컴포넌트를 사용해 처리하는 것이 좋다.
- 함수 컴포넌트의 반환값, 즉 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용해야 한다. 고차 컴포넌트는 공통화된 렌더링 로직을 처리하기에 좋은 방법이다. (하지만 고차 컴포넌트가 많아지면 복잡해지므로 신중하게 사용하자)
