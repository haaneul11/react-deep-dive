# 좋은 리액트 코드 작성을 위한 환경 구축하기

# 📑 ESLint를 활용한 정적 코드 분석

모든 개발자들이 버그가 없는 제품을 만들기 위해 최선을 다하지만 늘 그렇듯 버그는 예기치 못한 곳에서 매번 발생한다.

이러한 버그와 예기치 못한 작동을 방지하기 위한 여러 가지 방법이 있으며, 그중 가장 빠르게 시도해 볼 수 있는 방법은 바로 정적 코드 분석이다.

**정적 코드 분석**이란? 코드의 실행과는 별개로 코드 그 자체만으로 코드 스멜(잠재적으로 버그를 야기할 수 있는 코드)을 찾아내어 문제의 소지가 있는 코드를 사전에 수정하는 것을 의미한다.

→ 자바스크립트 생태계에서 가장 많이 사용되는 정적 코드 분석 도구는 바로 `ESLint`다.

## 🖌️ ESLint 살펴보기

### ESLint는 어떻게 코드를 분석할까?

ESLint는 자바스크립트 코드를 정적 분석해 잠재적인 문제를 발견하고 나아가 수정까지 도와주는 도구다.

ESLint가 코드를 어떻게 읽어서 분석하는지 다음과 같다.

1. 자바스크립트 코드를 문자열로 읽는다. ⭐
2. 자바스크립트 코드를 분석할 수 있는 파서(parser)로 코드를 구조화한다. ⭐
3. 2번에서 구조화한 트리를 AST(Abstract Suntax Tree)라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조한다.
4. 규칙과 대조했을 때 이를 위반한 코드를 알리거나(report) 수정한다(fix).

1번 과정에서 읽은 코드를 구조화하는 과정이 2번이다.

자바스크립트를 분석하는 파서에는 여러 가지가 있는데, ESLint는 기본값으로 espree를 사용한다. 그럼 espree는 자바스크립트 파일을 어떻게 구조화하는 것인지 다음 예제 코드를 espree로 분석해보자.

```jsx
function hello(str) {}
```

이 코드를 espree로 분석하면 다음과 같이 JSON 형태로 구조화된 결과를 얻을 수 있다.

```jsx
{
	"type": "program",
	"start": 0,
	"end": 22,
	"range": [0, 22],
	"body": [
		{
			"type": "FunctionDeclaration",
			"start": 0,
			"end": 22,
			"range": [0, 22],
			"id": {
				"type": "Identifier",
				"start": 9,
				"end": 14,
				"range": [9, 14],
				"name": "hello"
			},
			"expression": false,
			"generator": false,
			"async": false,
			"params": [
				{
					"type": "Identifier",
					"start": 15,
					"end": 18,
					"range": [15, 18],
					"name": "str"
				}
			],
			"body": {
				"type": "BlockStatement",
				"start": 20,
				"end": 22,
				"range": [20, 22],
				"body": []
			}
		}
	],
	"sourceType": "module"
}
```

→ espress나 다른 파서로 자바스크립트/타입스크립트 코드를 분석해 보고 싶다면 AST explorer를 방문해보면된다. 이 코드는 AST explorer에서 파서를 espree로 설정하고 분석한 결과이다.

espree 같은 코드 분석 도구는 단순히 변수인지, 함수인지, 함수명은 무엇인지 등만 파악하는 것이 아니라 코드의 정확한 위치와 같은 아주 세세한 정보도 분석해 알려준다.

- 이런 자세한 정보가 있어야만 ESLint나 Prettier 같은 도구가 코드의 줄바꿈, 들여 쓰기 등을 파악할 수 있게 된다.
- espree가 코드를 어떻게 분석하는지, 또 어떻게 결과를 만드는지, 또 나올 수 있는 값들이 무엇인지 등이 궁금하다면 espress의 문서를 살펴보면 된다.

타입스크립트의 경우도 마찬가지로 `@typescript-eslint/typescript-estree`라고 하는 espree 기반 피서가 있으며, 이를 통해 타입스크립트 코드를 분석해 구조화한다.

이 파서도 마찬가지로 AST explorer에서 사용해 볼 수 있다.

![Untitled](https://github.com/user-attachments/assets/677550c3-4ca7-4087-94ce-1c17ded8dd48)

→ `@typescript-eslint/typescript-estree`를 사용해 타입스크립트 코드를 분석한 모습이다. espree로 분석한 자바스크립트 코드와 매우 비슷하며, 여기에 추가로 타입스크립트의 타입 정보가 추가돼 있다.

ESLint가 expree로 코드를 분석한 결과를 바탕으로, 어떤 코드가 잘못된 코드이며 어떻게 수정해야 할지도 정해야 한다.

이를 `ESLint 규칙(rules)`이라고 하며, 특정한 규칙의 모음을 `plugins`라고 한다.

예를 들어 debugger는 코드 개발 과정에서만 사용해야 하는 구문인데, debugger의 사용을 금지하고 싶다면 프로덕션 애플리케이션에서는 절대 존재해서는 안 되는 구문이다.

→ 이를 바탕으로 ESLint를 이용해 사용을 금지하는 규칙을 만들어보자.

✅ debugger만 있는 코드를 espree로 분석한 결과

```jsx
{
	"type": "Program",
	"body": [
		{
			"type": "DebuggerStatement",
			"range": [0, 8]
		}
	],
	"sourceType": "module",
	"range": [0, 8]
}
```

body의 type이 DebuggerStatement를 반환하는 것을 확인할 수 있다. 그리고 이 debugger 사용을 제한하는 규칙인 `no-debugger`를 확인해보자.

```jsx
module.export = {
  meta: {
    type: "problem",
    docs: {
      description: "Disallow the use of `debugger`",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-debugger",
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Unexprected 'debugger' statement.",
    },
  },
  create(context) {
    return {
      DebuggerStatement(node) {
        context.report({
          node,
          messageId: "unexpected",
        });
      },
    };
  },
};
```

- meta는 이름에서 알 수 있듯 해당 규칙과 관련된 메타 정보를 나타낸다. 규칙을 어겼을 때 반환하는 경고 문구인 messages, 문서화에 필요한 정보인 docs, eslint —fix로 수정했을 때 수정 가능한지 여부를 나타내는 fixable 등을 확인할 수 있다.
- create는 실제로 코드에서 문제점을 확인하는 곳이다. create에 있는 함수는 espree로 만들어진 AST 트리를 실제로 순회해, 여기서 선언한 특정 조건을 만족하는 코드를 찾고, 이러한 작업을 코드 전체에서 반복한다.
- 즉, 여기서는 DebuggerStatement를 만나면 해당 노드를 리포트해 debugger를 사용했다는 것을 알려준다.
  ```powershell
  /Users/haneul/private/sample/pages/index.tsx
  	16:1  error Unexpected 'debugger' statement              no-debugger
  ```

ESLint는 기본적으로 몇 가지 규칙을 제공하는데, 이와 관련된 규칙은 공식 홈페이지에서 찾아볼 수 있다.

## 🖌️ eslint-plugin과 eslint-config

`eslint-plugin`과 `eslint-config`는 모두 ESLint와 관련된 패키지지만 각각의 역할이 다르다.

### eslint-plugin

eslint-plugin이라는 접두사로 시작하는 플러그인은 위에서 언급했던 규칙을 모아놓은 패키지이다.

- `eslint-plugin-import` : 자바스크립트에서 다른 모듈을 불러오는 import와 관련된 다양한 규칙을 제공
- `eslint-plugin-react` : 리액트 관려 규칙을 제공
  - 코드를 작성하다가 JSX 배열에 키를 선언하지 않으면 경고 메시지 보여주는 플러그인
  - 이 eslint-plugin-react가 제공하는 규칙 중 하나인 react/jsx-key가 경고를 보여준 것

→ 만약 이러한 규칙이 없다면 뒤늦게 브라우저의 콘솔에서 경고해 주는 내용을 확인해야만 수정이 가능하다.

### eslint-config

eslint-plugin이 리액트, import와 같이 특정 프레임워크나 도메인과 관련된 규칙을 묶어서 제공하는 패키지라면 `eslint-config`는 이러한 eslint-plugin을 한곳에 묶어서 완벽하게 한 세트로 제공하는 패키지라 할 수 있다.

여러 프로젝트에 걸쳐 동일하게 사용할 수 있는 ESLint 관련 설정을 제공하는 패키지가 바로 eslint-config이다.

내 입맛에 맞는, 내가 원하는 규칙들을 한데 모아서 설치하고 적용하는 것도 좋지만 ESLint를 설정하는 것 또한 만만치 않기 때문에 대부분의 경우 이미 존재하는 eslint-config를 설치해서 빠르게 적용하는 경우가 일반적이다.

자바스크립트 또는 타입스크립트 기반 리액트 개발자가 지금 당장 설치해서 사용할 수 있는 유명한 `eslint-config`를 아래에서 확인해보자.

⭐ eslint-plugin과 eslint-config의 네이밍과 규칙 한가지

- eslint-plugin, eslint-config라는 접두사를 준수, 반드시 한 단어로 구성
  - ex) eslint-plugin-naver ⭕️ / eslint-plugin-naver-financials ❌
- 특정 스코프가 앞에 붙는 것은 가능
  - ex) @titicaca/eslint-config-triple ⭕️ @titicaca/eslint-config-triple-rules ❌

**eslint-config-airbnb**

`eslint-config-airbnb`는 지금까지도 리액트 기반 프로젝트에서 eslint-config를 선택한다고 가정했을 때 가장 먼저 손에 꼽는 eslint-config다.

이름에서 알 수 있듯 에어비앤비(Airbnb)에서 만듦

다른 유명한 config인 eslint-config-google이나 eslint-config-naver 대비 압도적인 다운로드 수를 자랑한다.

- 제공하는 규칙
  - 자바스크립트 : https://github.com/airbnb/javascript#types
  - 리액트 : https://github.com/airbnb/javascript/tree/master/react
- 설치 가이드 : https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb#eslint-config-airbnb-1

**@titicaca/triple-config-kit**

`@titicaca/triple-config-kit` 는 한국 커뮤니티에서 운영되는 eslint-config 중 유지보수가 활발한 편에 속하며, 많이 쓰이는 eslint-config 중 하나다.

`@titicaca/triple-config-kit` 는 eslint-config와는 다른 몇 가지 특징이 있는데 아래에서 확인해보자.

- eslint-config-airbnb를 기반으로 약간의 룰을 수정해 배포되고 있는 것과 다르게 해당 패키지는 자체적으로 정의한 규칙을 기반으로 운영되고 있다.
  - eslint-config-airbnb를 기반으로 하지 않았어도 대부분의 유용하고 자바스크립트 개발자 사이에서 널리 알려진 규칙은 모두 제공하기 때문에 사용하는 데 큰 지장이 없다.
- 외부로 제공하는 규칙에 대한 테스트 코드가 존재한다.
- CI/CD 환경, 카나리 배포 등 일반적인 npm 라이브러리 구축 및 관리를 위한 시스템이 잘 구축되어 있다.
- 별도의 frontend 규칙도 제공하고 있어 Node.js 환경 또는 리액트 환경에 맞는 규칙을 적용할 수 있다.

`@titicaca/triple-config-kit` 는 EsLint뿐만 아니라 Prettier와 Stylelint를 각각 별도의 룰인 `@titicaca/prettier-config-triple`, `@titicaca/stylelint-config-triple`로 모노레포를 만들어 관리하고 있어 Prettier나 Stylelint도 필요에 따라 설치해서 사용할 수 있다.

→ 한국어권 커뮤니티에서 유지보수되고 있는 eslint-config를 사용하고 싶거나 혹은 자체적인 eslint-config 구축에 관심이 있다면 많은 도움이 될 것이다.

**eslint-config-next**

`eslint-config-next`는 리액트 기반 Next.js 프레임워크를 사용하고 있는 프로젝트에서 사용할 수 있는 eslint-config다.

Next.js 11 버전부터 만들어져 제공되고 있으며, Next.js 기반으로 코딩하는 데 유용한 각종 기능을 제공한다.

eslint-config-next는 단순히 자바스크립트 코드를 정적으로 분석할 뿐만 아니라 페이지나 컴포넌트에서 반환하는 JSX 구문 및 \_app, \_document에서 작성돼 있는 HTML 코드 또한 정적 분석 대상으로 분류해 제공한다.

→ 단순히 자바스크립트 코드에 대한 향상뿐만 아니라 전체적인 Next.js 기반 웹 서비스의 성능 향상에 도움이 될 수 있다.

→ 핵심 웹 지표(core web vitals)라고 하는 웹 서비스 성능에 영향을 미칠 수 있는 요소들을 분석해 제공하는 기능도 포함되어 있다.

즉, Next.js로 작성된 코드라면 반드시 설치하는 것이 좋다.

- 제공하는 규칙 : https://nextjs.org/docs/pages/building-your-application/configuring/eslint#eslint-plugin
- 설치 가이드 : https://nextjs.org/docs/pages/building-your-application/configuring/eslint

## 🖌️ 나만의 ESLint 규칙 만들기

### 이미 존재하는 규칙을 커스터마이징해서 적용하기: import React를 제거하기 위한 ESLint 규칙 만들기

리액트 17버전부터는 새로운 JSX 런타임 덕분에 import React 구문이 필요 없어졌다. 따라서 import React를 삭제하게 되면 아주 약간이나마 번들러의 크기를 줄일 수 있게 된다.

✅ import React가 있는 코드

```jsx
// Component
// 다음과 같은 컴포넌트가 100개 있다고 가정
import React from "react";

export function Component1() {
  return <div>hello world!</div>;
}

// App
import React from "react";
import Component1 from "./Components/1";
import Component2 from "./Components/2";
// ...
import Component100 from "./Components/100";

function App() {
  return (
    <div className="App">
      <Component1 />
      <Component2 />
      {/* ... */}
      <Component100 />
    </div>
  );
}

export default App;
```

✅ import React가 없는 코드

```jsx
// Component
// 다음과 같은 컴포넌트가 100개 있다고 가정
export function Component1() {
  return <div>hello world!</div>;
}

// App
import React from "react";
import Component1 from "./Components/1";
import Component2 from "./Components/2";
// ...
import Component100 from "./Components/100";

function App() {
  return (
    <div className="App">
      <Component1 />
      <Component2 />
      {/* ... */}
      <Component100 />
    </div>
  );
}

export default App;
```

이 두개 코드의 차이점은 다음과 같이 보여진다.

1. import React가 포함된 코드

   ![Untitled 1](https://github.com/user-attachments/assets/8c3b435e-770b-4e04-8386-1deec480c6b8)

   `/* harmony import */ var* react__WEBPACK_IMPORTED_MODULE_0__ = **__webpack_require__(/! react */ “./node_modules/react/index.js”);` 가 존재.

   이렇게 웹팩에서 선언한 `*react__WEBPACK_IMPORTED_MODULE_0__`\* 변수는 선언만 됐을 뿐 어디에서도 쓰이지 않는다.

   하지만 아래 코드에서는 해당 변수가 존재하지 않고 그덕에 파일의 크기가 줄어들었다.

   → 따라서 리액트 17버전을 사용하고 있다면 import React 구문을 모두 확인 후 제거하는 것이 좋다.

1. import React가 포함되지 않은 코드

   ![Untitled 2](https://github.com/user-attachments/assets/449a0a6f-46f7-4282-a746-2ee5823428ae)

1. 두 코드의 파일 크기 비교

   ![Untitled 3](https://github.com/user-attachments/assets/60f5c10f-6e79-4219-af4d-0ef06bf08a81)

create-react-app에서 npm run start로 실행한 뒤 제공되는 bundle.js로 확인을 해본 코드인데

두 코드가 import React 외에 모두 동일한 코드라는 가정하에 npm run build로 빌드된 자바스크립트 파일을 비교하면 정확히 똑같이 크기가 되는 것을 확인할 수 있다.

→ 이는 웹팩에서 제공하는 트리쉐이(`*번들러가 코드 어디에서도 사용하지 않는 코드(dead code, 죽은 코드)를 삭제해서 최종 번들 크기를 줄이는 과정`)킹 기능이 사용하지 않는 코드를 모두 삭제하기 때문이다.

→ 완전히 동일해도 import React를 제거를 해야 웹팩이 트리쉐이킹을 하는 데 걸리는 시간을 그만큼 줄일 수 있기 때문이다. 트리쉐이킹에 소요되는 시간이 없어진다면 자연스럽게 빌드 속도 또한 빨라질 것이다.

`no-restricted-imports 규칙` : 어떠한 모듈을 import하는 것을 금지하기 위해 만들어진 규칙

→ 이 규칙은 추가적으로 인수를 제공하면 import할 수 있는 모듈을 제한할 수 있는데, 이를 활용하면 import React를 금지할 수 있다.

✅ .eslintrc.js 파일

```jsx
module.exports = {
  rules: {
    "no-restricted-imports": [
      "error",
      {
        // paths에 금지시킬 모듈을 추가한다.
        paths: [
          {
            // 모듈명
            name: "react",
            // 모듈의 이름
            importNames: ["default"],
            // 경고 메시지
            message:
              "import React from 'react'는 react 17부터 더 이상 필요하지 않습니다. 필요한 것만 react로부터 import해서 사용해 주세요.",
          },
        ],
      },
    ],
  },
};
```

→ 금지시킬 모듈은 react인데, 그 중에서도 default export만 금지시킬 것이라는 모듈이다.

그래야 `import React`만 올바르게 필터링할 수 있다.

→ 이 exports를 제대로 하지 않는다면 모든 “import {} from ‘react’”에 에러가 있다는 잘못된 ESLint 리포트가 만들어진다. 이를 위해 paths의 name과 importNames에 각각 react와 default를 넣고, 이 룰이 왜 생겼는지 경고할 메시지도 추가하였다.

👇 아래 사진은 커스텀 규칙을 적용해 import React를 금지시킨 결과이다.

![Untitled 4](https://github.com/user-attachments/assets/2f8a7ec5-cdec-444f-b78c-fa663b41ef18)

→ ESLint를 실행하면 코드에서 에러가 발생하고, ESLint 설정이 추가돼 있는 코드 에디터에서도 해당 규착이 적용되어 에러가 발생하는 것을 확인할 수 있다.

→ 그러면 원리를 활용하면 트리쉐이킹이 되지 않는 lodash 같은 라이브러리를 import하는 것도 방지할 수 있다.

```jsx
module.exports = {
  rules: {
    "no-restricted-imports": [
      "error",
      {
        name: "lodash",
        message:
          "lodash는 CommonJS로 작서왜 있어 트리쉐이킹이 되지 않아 번들 사이즈를 크게 합니다. lo-dash/* 형식으로 import 해주세요.",
      },
    ],
  },
};
```

다음은 위 코드를 적용했을 때 볼 수 있는 ESLint 경고 문구이다.

![Untitled 5](https://github.com/user-attachments/assets/7c657495-4c96-4329-a894-58b7ba5d09b8)

→ lodash/something은 문제없이 작동하는 것을 볼 수 있다.

이런 식으로 no-restricted-imports를 커스터마이징하면 import하는 모듈을 제한할 수 있다.

이 밖에도 다양하게 커스터마이징할 수 있는 룰이 있으니 필요에 따라 사용해 보면 좋을 것이다.

### 완전히 새로운 규칙 만들기: new Date를 금지시키는 규칙

new Date()는 사용하지 못하고, 서버의 시간을 반환하는 함수인 ServerDate()를 만들어 이 함수만 사용해야 하고, 이러한 규칙을 쉽게 준수할 수 있도록 ESLint 규칙을 만들어보자.

한 가지 조건은 new Date(1664608053676)나 new Date(’2022-01-01’)은 허용하도록 한다.

그 이유는 현재 시간을 가져오는 것이 아니라 자바스크립트의 Date 객체를 활용해 특정 시간을 가져오는 것이 목적이기 때문이다.

❣️ 이 규칙을 만들기 전에 해야 할 일은 자바스크립트 코드 내부에서 new Date()의 존재를 파악하는 것이다.

new Date()라는 코드를 작성한 다, espree에서 AST를 어떻게 만드는지 살펴보자.

✅ new Date()를 espree로 분석해 만든 AST

```jsx
{
	"type": "Program",
	"start": 0,
	"end": 10,
	"range": [0, 10],
	"body": [
		{
			"type": "ExpressionStatement",
			"start": 0,
			"end": 10,
			"range": [0, 10],
			"expression": {
				"type": "NewExpression",
				"start": 0,
				"end": 10,
				"range": [0, 10],
				"callee": {
					"type": "Identifier",
					"start": 4,
					"end": 8,
					"range": [4, 8],
					"name": "Date"
				},
				"arguments": []
			}
		}
	],
	"sourceType": "module"
}
```

- `ExpressionStatement`는 해당 코드의 표현식 전체를 나타낸다.
- `ExpressionStatement.expression`은 ExpressionStatement에 어떤 표현이 들어가 있는지 확인하다. 이것이 ESLint에서 확인하는 하나의 노드 단위다.
- `ExpressionStatement.expression.type`은 해당 표현이 어떤 타입인지 나타내는데, 여기에서는 생성자(new)를 사용한 NewExpression임을 알 수 있다.
- `ExpressionStatement.expression.callee`는 생성자를 사용한 표현식에서 생성자의 이름을 나타낸다. 여기서는 Date임을 알 수 있다.
- `ExppressionStatement.expression.arguments`는 생성자를 표현한 표현식에서 생성자에 전달하는 인수를 나타낸다. 여기서는 인수가 없다.

AST로 확인할 결과, 금지해야 할 new Date() type은 newExpression이며, callee.name이 Date이고, ExpressionStatement.expression.arguments가 빈 배열인 경우이다.

아래 예제에서 ESLint의 create 함수를 통해 규칙을 만들어보자.

```jsx
/**
	* @type {import('eslint').Rule.RuleModule}
 */
module.exports = {
	meta: {
		type: 'syggestion',
		docs: {
			description: 'disallow use of the new Date()',
			recommendded: false,
		}
	},
	fixable: 'code',
	schema: [],
	messages: {
		message: 'new Date()는 클라이언트에서 실행 시 해당 기기의 시간에 의존적이라 정확하지 않습니다. 현재 시간이 필요하다면 ServerDate()를 사용해 주세요.'
	},
},
	create: function (context) {
		return {
			NewExpression: function (node) {
				if (node.callee.name === 'Date' && node.arguments.length === 0) {
					context.report({
						node: node,
						messageId: 'message',
						fix: function (fixer) {
							return fixer.replaceText(node, 'ServerDate()')
						},
					})
				}
			},
		}
	},
}
```

- meta 필드는 해당 규칙과 관련된 정보를 나타내는 필드이다.
  - 규칙과 관련된 정보를 제공하는 필드로, 실제 규칙이 작동하는 코드와는 크게 관련이 없다.(공식 홈페이지의 meta 필드 참고)

⭐ 여기서는 create 필드에 만들 함수가 중요하다.

- 이 함수는 객체를 반환해야 하는데, 이 객체에서는 코드 스멜을 감지할 선택자나 이벤트명 등을 선언할 수 있다.
- 여기서는 NewExpression이라고 하는 타입의 선택자를 키로 선언해서 new 생성자를 사용할 때 ESLint가 실행되게 한다.
- 그리고 해당 NewExpression을 찾았을 때, 해당 node를 기준으로 찾고자 하는 생성자인지 검증하는 코드를 넣는다.
  → 여기서는 callee.name이 Date이고, 인수는 없는 경우를 찾는다.
- 이를 찾았다면 context.report를 통해 해당 코드 스멜을 리포트하고, 문제가 되는 node와 찾았을 때 노출하고 싶은 message를 가라킨다.
  → 이 메시지 정보는 meta.messages에서 가져올 수 있는데, meta.messages의 객체에 키 값을 선언해두면 해당 키 값을 가진 meta.messages의 값을 가져오게 된다.
- 마지막으로, fix를 키로 하는 함수를 활용해 자동으로 수정하는 코드를 넣어줄 수 있다.
  → 여기서는 ServerDate()라고 하는 함수로 대체할 것이므로 해당 코드로 대체하는 코드까지 넣어주낟.

이제 규칙을 만들었으니 해당 규칙을 만들어서 배포하 볼 것이다.

규칙은 하나씩 만들어 배포하는 것은 불가능하며, 반드시 eslint-plugin 형태로 규칙을 묶음으로 배포하는 것만 가능하다.

따라서 빈 패키지를 만든 다음, yo 와 generate-eslint를 활용해 eslint-plugin을 구성할 환경을 빠르게 구성해보자.

![Untitled 6](https://github.com/user-attachments/assets/c0785e56-8ef2-4087-851f-e6777a849723)

이와 같이 환경을 설정하면 다음과 같은 구조로 디렉터리와 파일이 생성된다.

![Untitled 7](https://github.com/user-attachments/assets/aa672b5c-a852-449f-9d76-6b07ff0eaf8d)

먼저 rules/no-new-date.js 파일을 열고 앞에서 작성한 규칙을 붙여넣자.

그리고 docs에는 해당 규칙을 위한 설명. test에는 테스트 코드를 작성한다.

```jsx
/**
 * @fileoverview haneul
 * @author haneul
 */
"use strict";

// -----------------------------------------------------------
// Requirements
// -----------------------------------------------------------

const rule = require("../../../lib/rules/no-new-date"),
  RuleTester = require("eslint").RuleTester;

// -----------------------------------------------------------
// Tests
// -----------------------------------------------------------

const ruleTester = new RuleTester();
ruleTester.run("no-new-date", rule, {
  valid: [
    {
      code: "new Date(2021, 1, 1)",
    },
    {
      code: 'new Date("2022-01-01")',
    },
  ],

  invalid: [
    {
      code: "new Date()",
      error: [{ message: rule.meta.messages.message }],
      output: "ServerDate()",
    },
  ],
});
```

그리고 마지막으로 npm pulish로 배포한 다음, 원하는 프로젝트에서 설치해서 사용하면 된다.

## 🖌️ 주의할 점

### prettier와의 충돌

Prettier는 코드의 포매팅을 도와주는 도구이다. ESLint와 마찬가지로 코드를 정적 분석해서 문제를 해결한다는 점은 동일하지만, 두 패키지가 지향하는 목표는 다르다.

ESLint는 코드의 잠재적인 문제가 될 수 있는 부분을 분석해 준다면, Prettier는 포매팅과 관련된 작업, 즉 줄바꿈, 들여쓰기, 작은 따옴표와 큰따옴표 등을 담당한다.

자바스크립트에서만 작동하는 ESLint와는 다르게, Prettier는 자바스크립트뿐만 아니라 HTML, CSS, 마크다운, JSON 등 다양한 언어에도 적용 가능하다.

→ Prettier와 ESLint가 서로 충돌을 일으킬 수 있다는 것이다.

즉, ESLint에서도 Prettier에서 처리하는 작업(들여쓰기, 줄바꿈, 따옴표, 최대 글자 수 등)을 처리할 수 있기 때문에 두 가지 모두를 자바스크립트 코드에서 실행한다면 서로 충돌하는 규칙으로 인해 에러가 발생하고, 최악의 경우 ESLint, Prettier 모두 만족하지 못하는 코드가 만들어질 수도 있다.

이 문제를 해결하는 방법은 2가지가 있다.

1. 서로 규칙이 충돌되지 않게끔 규칙을 잘 선언하는 것이다. Prettier에서 제공하는 규칙을 어기지 않도록, ESLint에서는 해당 규칙을 끄는 방법이다. 이 경우 코드에 ESLint를 적용하는 작업과 코드의 포매팅을 하는 작업이 서로 다른 패키지에서 발생하게 된다.
2. 자바스크립트나 타입스크립트는 ESLint에, 그 외의 파일(마크다운, YAML, JSON 등)은 모두 Prettier에 맡기는 것이다. 그 대신 자바스크립트에서 추가적으로 필요한 Prettier 관련 규칙은 모두 eslint-plugin-prettier를 사용한다. eslint-plugin-prettier는 Prettier에서 제공하는 모든 규칙을 ESLint에서 사용할 수 있는 규칙으로 만들어둔 플러그인이다. 이렇게 Prettier와 ESLint가 서로 관여하는 파일을 물리적으로 분리한다면 코드 충돌의 위험은 없애고 Prettier가 제공하는 모든 규칙을 사용할 수 있다.

### 규칙에 대한 예외 처리, 그리고 react-hooks/no-exhaustive-deps

만약 일부 코드에서 특정 규칙을 임시로 제외시키고 싶다면 eslint-disable- 주석을 사용하면 된다. 특정 줄만 제외하거나, 파일 전체를 제외하거나, 특정 범위에 걸쳐 제외하는 것이 가능하다.

```jsx
// 특정 줄만 제외
console.log("hello world"); // eslint-disable-line no-console

// 다음 줄 제외
// eslint-disable-next-line no-console
console.log("hello world");
// 특정 여러 줄 제외

/* eslint-disable no-console */
console.log("JavaScript debug log");
console.log("eslint is disabled now");
/* eslint-enable no-console */

// 파일 전체에서 제외
/* eslint-disable no-console */
console.log("hello world");
```

가장 많이 사용하는 곳 중 하나가 `// eslint-disable-line no-exhaustive-deps` 일 것이다.

이 규칙은 useEffect나 useMemo와 같이 의존 배열이 필요한 훅에 의존성 배열을 제대로 선언했는지 확인하는 역할을 한다. 겉보기에는 굉장히 별거 아닌 규칙처럼 보이지만 이 규칙을 위해 작성된 코드는 자그마치 1,800여 줄에 걸쳐 있다.

일반적으로 리액트 개발자들은 개발 시 이 의존성 배열이 너무 길어지거나, 혹은 빈 배열을 넣어서 컴포넌트가 마운트되는 시점에 한 번만 강제로 실행되게 하고 싶을 때, 혹은 임의로 판단해 없어도 괜찮다고 생각될 때 등에 사용한다.

하지만 이것은 대부분의 경우에 위험한 발상이며, 잠재적인 버그를 야기할 수 있다.

각각의 경우에 무엇이 잘못됐는지 살펴보자.

- 괜찮다고 임의로 판단한 경우 : 가장 위험한 경우이다. 실제로 면밀히 검토해서 괜찮은 경우라면 해당 변수는 컴포넌트의 상태와 별개로 동작한다는 것을 의미한다. 이 경우에는 해당 변수를 어디서 어떻게 선언할지 다시 고민해 봐야 한다. 정말로 괜찮다 하더라도 이러한 작업이 반복되면 정말로 괜찮지 않은 코드에서도 동일하게 사용해 버그를 야기할 위험성이 있다.
- 의존성 배열이 너무 긴 경우 : 의존성 배열이 너무 길다는 것은 useEffect 내부 함수가 너무 길다는 말과 동일하다. useEffect가 너무 길다면 useEffect를 쪼개서 의존성 배열의 가독성과 안정성을 확보해야 한다.
- 마운트 시점에 한 번만 실행하고 싶은 경우 : 가장 흔히 볼 수 있는 경우로, 의도적으로 []로 모든 의존성을 제거해 컴포넌트가 마운트되는 시점에만 실행하고 싶은 경우다. 먼저 이러한 접근 방법은 과거 클래스 컴포넌트에서 사용되던 생명주기 형태의 접근 방법으로, 함수 컴포넌트의 패러다임과는 맞지 않을 가능성이 있다. 또한 [] 배열이 있다는 것은 컴포넌트의 상태값과 별개의 부수 효과가 되어 컴포넌트의 상태와 불일치가 일어날 수 있게 된다. 마지막으로, 상태와 관계없이 한 번만 실행돼야 하는 것이 있다면 해당 컴포넌트에 존재할 이유가 없다. 이 경우 적절한 위치로 옮기는 것이 옳다.

물론 정말 넣을 것이 없어서 []를 넣는 경우는 당연히 제외된다. 여기서 말하는 경우는 상태에 의존하는 있음에도 고의로 빈 배열을 넣는 경우를 말한다.

이 외에도 타입스트립트의 any를 강제로 사용하기 위한 `typescript-eslint/no-explicit-any` 등 개발자가 의도적으로 무시하는 다양한 경우도 있다.

그러나 모든 규칙은 존재하는 이유가 있으며, 이 규칙을 따르지 않았을 때 반드시 크건 작건 문제가 생길 수 있다.

그리고 정말 필요 없는 규칙이라면 “off”를 사용해 끄는 것이 옳다. eslint-disable을 많이 사용하고 있다면 그렇게 무시하는 것이 옳은지, 아니면 해당 규칙을 제거하는 것이 옳은지 꼭 점검해 봐야 한다.

### ESLint 버전 충돌

create-react-app으로 생성된 앱에 원하는 `eslint-config-triple`을 설치하는 상황을 가정해 보자. 최신 버전의 react-scripts인 5.0.1에서 `eslint-config-triple` 최신 버전을 함께 설치하고 ESLint를 수행하면 다음과 같은 에러가 발생한다.

![Untitled 8](https://github.com/user-attachments/assets/5c02ccbc-9fdd-485d-9f28-059a366e67c0)

분명 eslint-plugin-promise는 eslint-config-triple에서 제공하고 있기 때문에 정상적으로 설치되어 있다.

![Untitled 9](https://github.com/user-attachments/assets/8ab6e8a6-b554-4886-a8e7-0fd701f1e475)

그러나 이를 못찾는 이유는 바로 두 개의 다른 ESLint 버전이 설치되어 있기 때문이다.

![Untitled 10](https://github.com/user-attachments/assets/24281715-6ba1-4eac-a7ae-d3352382ac15)

create-react-app을 실행하면 설치되는 react-scripts의 5.0.1 버전에는 ESLint 8에 의존성을, eslint-config-triple은 ESLint 7에 의존성을 가지고 있다. ESLint가 실행되는 순간, 높은 버전인 8이 실행됐고, 8에는 eslint-plugin-promise가 없기 때문에 에러가 발생한다.

이 때문에 ESLint 공식 문서에서는 ESLint를 peerDependencies로 설정해 두라고 권장하고 있다.

이러한 문제를 미연에 방지하려면 설치하고자 하는 eslint-config, eslint-plugin이 지원하는 ESLint 버전을 확인하고, 또 설치하고자 하는 프로젝트에서 ESLint 버전을 어떻게 지원하고 있는지 살펴봐야 한다.

두 ESLint 버전을 모두 충족시킬 수 있는 환경을 만들어두고 설치하는 것이 좋다. 만약 이러한 사전 준비를 제대로 하지 않는다면 ESLint를 사용할 때마다 버전이 맞지 않는다는 오류 메시지를 마주하게 될 것이다.

최근 eslint-config-triple의 4.x 버전이 릴리스되면서 이러한 문제가 어느 정도 해결된 것으로 보인다.

ESLint 공식 문서에서도 ESLint의 의존성은 peerDependencies로 명시하도록 권장하고 있지만 몇몇 이를 준수하지 못한 패키지를 설치할 때는 주의해야 한다.

✅ 정리

- 나아가 앞서 no-new-date 예제처럼 사용자 지정 룰을 생성해 프로젝트 전반에 걸쳐 준수하고자 하는 규칙도 ESLint의 도움을 얻어 손쉽게 일관성을 유지할 수 있다.
- ESLint를 사용하고 있다면 프로젝트에 설치되어 있는 eslint-config는 무엇인지, 왜 이것을 문제가 있는 코드로 간주하는지 살펴보면 좋다.

# 📑 리액트 팀이 권장하는 리액트 테스트 라이브러리

테스트란 개발자가 만든 프로그램이 코딩을 한 의도대로 작동하는지 확인하는 일련의 작업을 의미한다.

테스트를 통해 개발자들은 처음에 설계한 대로 프로그램이 작동하는지 확인할 수 있고, 버그를 사전에 방지할 수도 있으며, 이후에 잘못된 작동으로 인해 발생하는 비용을 줄일 수도 있다.

백엔드와 프론트엔드는 테스트하는 방법이 다르다.

프론트엔드로 보면 일반적인 사용자와 동일하거나 유사한 환경에서 수행된다. 사용자가 프로그램에서 수행할 주요 비즈니스 로직이나 모든 경우의 수를 고려해야 하며, 이 과정에서 사용자는 굳이 프론트엔드 코드를 알 필요는 없다.

즉, 블랙박스 형태로 테스트가 이뤄지며, 코드가 어떻게 됐든 상관없이 의도한 대로 작동하는지를 확인하는 데 좀 더 초점이 맞춰져 있다. 그리고 시나리오가 어느 정도 정해져 있는 백엔드와는 다르게, 프론트엔드는 사용자에게 완전히 노출된 영역이므로 어떻게 작동할지 최대한 예측해서 확인해야 한다. 사용자는 개발자의 의도대로만 사용하지 않기 때문이다.

프론트엔드 개발은 HTML, CSS와 같이 디자인 요소뿐만 아니라 사용자의 인터랙션, 의도치 않은 작동 등 브라우저에서 발생할 수 있는 다양한 시나리오를 고려해야 하기 때문에 일반적으로 테스팅하기가 매우 번거롭고 손이 많이 가는 작업이다.

그리고 이러한 특징 때문에 제공되는 테스팅 라이브러리도 상당히 다양한 편이다.

단순히 함수나 컴포넌트 수준에서 유닛 테스트를 할 수도 있고, 사용자가 하는 작동을 모두 흉내 내서 테스트할 수도 있다.

그래서 리액트로 개발된 애플리케이션을 테스팅하는 방법, 특히 가장 널리 사용되는 `React Testing Library` 위주로 알아볼 것이다.

## 🖌️ React Testing Library란?

`React Testing Library`(이하 리액트 테스팅 라이브러리)란 DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리로, 리액트를 기반으로 한 테스트를 수행하기 위해 만들어졌다.

리액트 테스팅 라이브러리를 이해하기 전에 `DOM Testing Library`에 대해 먼저 알아보자.

`DOM Testing Library`는 `jsdom`을 기반으로 하고 있다.

jsdom이란 순수하게 자바스크립트로 작성된 라이브러리로, HTML이 없는 자바스크립트만 존재하는 환경, 예를 들어 Node.js 같은 환경에서 HTML과 DOM을 사용할 수 있도록 해주는 라이브러리이다.

jsdom을 사용하면 자바스크립트 환경에서도 HTML을 사용할수 있으므로 이를 기반으로 DOM Testing Library에서 제공하는 API를 사용해 테스트를 수행할 수 있다.

✅ jsdom을 사용해 DOM 조작

```jsx
const jsdom = require("jsdom");

const { JSDOM } = jsdom;
const dom = new JSDOM(`<!DOCTYPE html><p>Hello wrold</p>`);

console.log(dom.window.document.querySelector("p").textContent); // "Hello world"
```

→ 이와같이 jsdom을 사용하면 마치 HTML이 있는 것처럼 DOM을 불러오고 조작할 수 있다.

jsdom을 사용해 자바스크립트 환경에서 HTML을 사용할 수 있는 DOM Testing Library를 기반으로, 동일한 우너리로 리액트 기반 환경에서 리액트 컴포넌트를 테스팅할 수 있는 라이브러리가 바로 리액트 테스팅 라이브러리이다.

리액트 테스팅 라이브러리를 활용하면 실제로 리액트 컴포넌트를 렌더링하지 않고도, 즉 브라우저를 직접 실행해 눈으로 확인하지 않아도 리액트 컴포넌트가 원하는 대로 렌더링되고 있는지 확인할 수 있다.

이러한 테스트 방식은 굳이 테스트 환경을 구축하는 데 복잡한 과정을 거치지 않아 간편하고, 테스트에 소요되는 시간 역시 효과적으로 단축시킬 수 있다.

그리고 컴포넌트뿐만 아니라 Provider, 훅 등 리액트를 구성하는 다양한 요소들을 테스트할 수 있다.

## 🖌️ 자바스크립트 테스트의 기초

우선 자바스크립트로 테스트 코드 작성하는 방법에 대해 알아보자.

```jsx
function sum(a, b) {
  return a + b;
}
```

이 함수에 대한 테스트 코드를 작성한다면 어떻게 작성해야 할까?

테스트 코드란 내가 작성한 코드가 내가 코드를 작성했던 당시의 의도와 목적에 맞는지 확인하는 코드를 의미한다.

그런 의미에서 sum 함수에 대해서는 다음과 같은 테스트 코드를 작성해 볼 수 있을 것이다.

```jsx
// 테스트 1
// 함수를 실행했을 때의 실제 겨롸
let actual = sum(1, 2);
// 함수를 실행했을 때 기대하는 결과
let expected = 3;

if (expected !== actual) {
  throw new Error(`${expected} is not equal to ${actual}`);
}

// 테스트 2
actual = sum(2, 2);
expected = 4;

if (expected !== actual) {
  throw new Error(`${expected} is not equal to ${actual}`);
}
```

테스트 코드를 작성하는 방식, 테스트 코드에서 사용하는 인수 등 코드의 세세한 부분에는 조금씩 차이점이 있지만 기본거인 테스트 코드를 작성하는 방법은 다음과 같다.

1. 테스트할 함수나 모듈을 선정한다.
2. 함수나 모듈이 반환하길 기대하는 값을 적는다.
3. 함수나 모듈의 실제 반환 값을 적는다.
4. 3번의 기대에 따라 2번의 결과가 일치하는지 확인한다.
5. 기대하는 결과를 반환한다면 테스트는 성공이며, 만약 기대와 다른 결과를 반환하면 에러를 던진다.

이를 위해 가장 먼저 필요한 것은 “작성한 코드가 예상대로 작동하다면 성공했다는 메시지가 출력되고, 실패하면 에러를 던진다”라는 작동을 대신해 주는 라이브러리이다.

Node.js는 assert라는 모듈을 기본적으로 제공하며, 이 모듈을 사용하면 위와 같이 작동하도록 만들 수 있따.

assert라는 이름에서도 알 수 있듯이 테스트 코드가 예상대로 작동한다고 ‘주장’하는 코드를 작성하면 이 코드의 성공 여부에 따라 테스트 통과 또는 실패를 반환한다.

Node.js의 assert는 다음과 같이 사용할 수 있다.

✅ Node.js에서 기본적으로 제공하는 assert를 사용한 코드

```jsx
const assert = require("assert");

function sum(a, b) {
  return a + b;
}

assert.equal(sum(1, 2), 3);
assert.equal(sum(2, 2), 4);
assert.equal(sum(1, 2), 4); // AssertionError [ERR_ASSERTION] [ERR_ASSERTION]: 3 == 4
```

참고로 일반적으로 테스트 코드와 실제 코드는 분리해 작성한다. 따라서 sum 함수는 다른 파일에 명시적으로 분리하는 것이 일반적이지만 여기서는 간단한 예제를 보여주기 위해 함께 작성했다.

위 예제에서는 반환값에 대한 비교와 비교 실패에 따른 에러를 던지는 작업을 assert를 사용하여 간결하게 표현하였다.

또한 마지막 줄과 같이 테스트 코드가 실패하는 경우 assert.equsl 내부에서 AssertionError라는 레어도 던져 테스트 코드가 실패했음을 명시적으로 알린다.

이처럼 테스트 결과를 확인할 수 있도록 도와주는 라이브러리르 `어설션(assertion)` 라이브러리라고 한다.

(`어설션 라이브러리에는 Node.js가 제공하는 assert 외에도 should.js, expect.js, chai 등 다양하다.`)

테스트 코드가 정상적으로 작동하고, 테스트도 모두 통과하겠지만 무엇을 테스트했는지, 무슨 테스트를 어떻게 수행했는지 등 테스트에 관한 실제 정보를 알 수는 없다. 즉 좋은 테스트 코드는 다양한 테스트 코드가 작성되고 통과하는 것뿐만 아니라 어떤 테스트가 무엇을 테스트하는지 분명하고 뚜렷하게 보여주는 것도 중요하다.

이러한 테스트의 기승전결을 완성해 주는 것이 바로 테스팅 프레임워크다.

테스팅 프레임워크들은 어설션을 기반으로 테스트를 수행하며, 여기에 추가로 테스트 코드 작성자에게 도움이 될 만한 정보를 알려주는 역할도 함께 수행한다.

자바스크립트에서 유명한 테스팅 프레임워크로는 Jest, Mocha, Karma, Jasmine 등이 있다.

그리고 리액트 진영에서는 리액트와 마찬가지로 메타에서 작성한 오픈소스 라이브러리인 `Jest`가 널리 쓰이고 있다. Jest의 경우 자체적으로 제작한 expect 패키지를 사용해 어설션을 수행한다.

원래 Jest는 깃허브 주소에서도 알 수 있듯 메타에서 개발에서 운영하고 있으나, 최근에 들어서는 메타의 어떠한 직원도 Jest를 유지보수하고 있지 않았던 것으로 보인다.

그럼 이제 앞의 테스트 코드를 Jest로 작성해보자. 여기서는 테스트 코드와 실제 코드를 별도로 분리해보자.

✅ math.js

```jsx
function sum(a, b) {
  return a + b;
}

module.exports = {
  sum,
};
```

✅ math.test.js

```jsx
const { sum } = require("./math");

test("두 인수가 덧셈이 되어야 한다.", () => {
  expect(sum(1, 2)).toBe(3);
});

test("두 인수가 덧셈이 되어야 한다.", () => {
  expect(sum(2, 2)).toBe(3); // 에러
});
```

테스트 코드를 실행하면 다음과 같은 결과를 얻을 수 있다.

```jsx
$ npm run test
```

![Untitled 11](https://github.com/user-attachments/assets/193b0de6-dc96-4216-90eb-c2b3ff692aff)

Node.js의 assert만 사용했을 때는 단순히 실패에 대해서만 단편적인 정보로 알 수 있었지만 Jest를 비롯한 테스트 프레임워크를 사용하면 무엇을 테스트했는지, 소요된 시간은 어느 정도인지, 무엇이 성공하고 실패했는지, 전체 결과는 어떤지에 대한 자세한 정보를 확인할 수 있다.

이렇게 어설션 라이브러리를 내장한 테스트 프레임워크를 사용하면 테스트 코드를 작성하는 것뿐만 아니라 테스트에 대한 결과와 관련 정보를 분명하고 뚜렷하게 확인할 수 있다.

- test, expect 등의 메서드를 import나 require 같은 모듈을 불러오기 위해 사용하는 구문 없이 바로 사용
- node가 아닌 jest(npm run test)로 실행 → 만약 jest가 아닌 node로 바로 실행했다면 에러가 발생했을 것이다. 그 이유는 test와 expect 모두 Node.js 환경의 global, 즉 전역 스코프에 존재하지 않는 메서드이기 때문이다. 이러한 메서드가 실행될 수 있는건 Jest CLI에 있다.
- Jest를 비롯한 테스팅 프레임워크에는 글로벌(global)이라 해서 실행 시에 전역 스코프에 기본적으로 넣어주는 값들이 있다. 그리고 Jest는 이 값을 실제 테스트 직전에 미리 전역 스코프에 넣어준다. 이렇게 하면 일일이 테스트에 관련한 정보를 임포트하지 않고도 사용할 수 있게 되는 것이다.
  → 이는 간결하고 빠른 테스트 코드 작성에 도움을 준다. (전역 스코프에 삽입되는 값은 Jest 공신 문서에서 확인할 수 있다.)
  만약 글로벌을 활용한 Jest의 작동 방식이 조금 어색하다면 일반적으로 다른 자바스크립트 파일을 작성했을 때와 마찬가지로 명시적으로 import 구문을 작성할 수 있다.
  ```jsx
  import { expect, jest, tes } from "@jset/globals";
  ```
  → 이렇게 하면 node로 실행해 테스트하는 것도 가능하다. 하지만 테스트 코드 작성을 번거롭게 하므로 선호되지는 않는다.

## 🖌️ 리액트 컴포넌트 테스트 코드 작성하기

리액트에서 컴포넌트 테스트는 다음과 같은 순서로 진행된다.

1. 컴포넌트를 렌더링한다.
2. 필요하다면 컴포넌트에서 특정 액션을 수행한다.
3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과를 비교한다.

### 프로젝트 생성

`create-react-app`으로 프로젝트를 생성한다. → create-react-app에는 이미 react-testing-library가 포함되어 있어 별도로 설치할 필요가 없다.

```powershell
npx create-react-app react-test --template typescript
```

이렇게 생성된 프로젝트를 살펴보면 `App.test.tsx` 파일이 생성돼 있는 것을 확인할 수 있다.

```jsx
import React from "react";
import { render, screen } from "@testing-library/react";
import App from "./App";

test("render learn react link", () => {
  render(<App />);
  const linkElement = screen.getByTest(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
```

이 `App.test.tsx`가 테스트하는 App 컴포넌트는 다음과 같이 구성되어 있다.

```jsx
import React from "react";
import logo from "./logo.svg";
import "./App.css";

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alit="logo" />
        <p>
          Edit <code> src/App.tsx</code> and savw to reload.
        </p>
        <a
          className="App-link"
          href="https://reactks.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
```

코드 내용을 종합하면 `App.test.tsx`가 `App.tsx`에서 테스트하는 내용은 다음과 같이 요약할 수 있다.

1. <App />을 렌더링한다.
2. 렌더링하는 컴포넌트 내부에서 “learn react”라는 문자열을 가진 DOM 요소를 찾는다.
3. expect(linkElement).toBeInTheDocument()라는 어설션을 활용해 2번에서 찾은 요소가 document 내부에 있는지 확인한다.

위와 같이 리액트 컴포넌트에서 테스트하는 일반적인 시나리오는 특정한 무언가를 지닌 HTML 요소가 있는지 여부다. 이를 확인하는 방법은 크게 3가지가 있다.

- `getBy…` : 인수의 조건에 맞는 요소를 반환하며, 해당 요소가 없거나 두 개 이상이면 에러를 발생시킨다. 복수 개를 찾고 싶다면 getAllBy…를 사용하면 된다.
- `findBy…` : getBy…와 거의 유사하나 한 가지 큰 차이점은 Promise를 반환한다는 것이다. 즉, 비동기로 찾는가는 것을 의미하며, 기본값으로 1000ms의 타임아웃을 가지고 있다. 마찬가지로 두 개 이상이면 에러를 발생시키지만 복수 개를 찾고 싶다면 findAllBy…를 사용하면 된다. 이러한 특징 때문에 findBy는 비동기 액션 이후에 요소를 찾을 때 상요한다.
- `qeuryBy…` : 인수의 조건에 맞는 요소를 반환하는 대신, 찾지 못한다면 null을 반환한다. getBy…와 findBy…는 찾지 못하면 에러를 발생시키기 때문에 찾지 못해도 에러를 발생시키지 않고 싶다면 queryBy…를 사용하면 된다. 마찬가지로 복수 개를 찾았을 때는 에러를 발생시키며, 복수 개를 찾고 싶다면 queryAllBy…를 사용하면 된다.

그리고 컴포넌트를 테스트하는 파일은 App.tsx, App.test.tsx의 경우와 마찬가지로 같은 디렉터리상에 위치하는 것이 일반적이다.

이름 규칙인 \*.test.{t|s}jsx만 준수한다면 디렉터리 내부에서 명확하게 구별되고, 대부분의 프레임워크가 이러한 이름으로 된 파일은 번들링에서 제외하므로 유용하게 사용할 수 있다.

테스트를 위해 사용할 수 있는 기본적인 메서드에 대해 알아봤으니 이제 본격적으로 컴포넌트를 테스트하는 방법을 살펴보자.

### 정적 컴포넌트

정적 컴포넌트, 즉 별도의 상태가 존재하지 않아 항상 같은 결과를 반환하는 컴포넌트를 테스트하는 방법은 크게 어렵지 않다. 테스트를 원하는 컴포넌트를 렌더링한 다음, 테스트를 원하는 요소를 찾아 원하는 테스트를 수행하면 된다.

다음과 같은 컴포넌트가 있다고 해보자.

```jsx
import { memo } from 'react'

const AnchorTagComponent = memo(function AnchorTagComponent({
	name,
	href,
	targetBlank,
}: {
	name: string
	href: string
	targetBlank?: boolean
}) {
	return (
		<a
			href={href}
			target={targetBlank ? '_blank' : undefined}
			rel="nonpener noreferrer"
		>
			{name}
		</a>
	)
})

export default function StaticComponent() {
	return (
		<>
			<h1>Static Component</h1>
			<div>유용한 링크</div>

			<ul data-testid="ul" style={{ listStyleType: 'square' }}>
				<li>
					<AnchorTagComponent
						targetBlank
						name="리액트"
						href="https://reactks.org"
					/>
				</li>
				<li>
					<AnchorTagComponent
						targetBlank
						name="네이버"
						href="https://www.naver.com"
					/>
				</li>
				<li>
					<AnchorTagComponent
						name="블로그"
						href="https://www.haneul.kr"
					/>
				</li>
			</ul>
		</>
	)
}
```

이 컴포넌트에 링크가 제대로 있는지 확인한다면 다음과 같이 테스트 코드를 작성해 볼 수 있다.

```jsx
import { render, screen } from "@testing-library/react";

import StaticComponent from "./index";

beforeEach(() => {
  render(<StaticComponent />);
});

describe("링크 확인", () => {
  it("링크가 3개 존재한다.", () => {
    const ul = screen.getByTestId("ul");
    expect(ul.children.length).toBe(3);
  });

  it("링크 목록의 스타일이 square다.", () => {
    const ul = screen.getByTestId("ul");
    expect(ul).toHabeStyle("list-style=type: square;");
  });
});

describe("리액트 링크 테스트", () => {
  it("리액트 링크가 존재한다.", () => {
    const reactLink = screen.getByText("리액트");
    expect(reactLink).toBeVisible();
  });

  it("리액트 링크가 올바른 주소로 존재한다.", () => {
    const reactLink = screen.getByText("리액트");

    expect(reactLink.tagName).toEqual("A");
    expect(reactLink).toHaveAttribute("href", "https://reactjs.org");
  });
});

describe("네이버 링크 테스트", () => {
  it("네이버 링크가 존재한다.", () => {
    const naverLink = screen.getByText("네이버");
    expect(naverLink).toBeVisible();
  });

  it("네이버 링크가 올바른 주소로 존재한다.", () => {
    const naverLink = screen.getByText("네이버");

    expect(naverLink.tagName).toEqual("A");
    expect(naverLink).toHaveAttribute("href", "https://naver.com");
  });
});

describe("블로그 링크 테스트", () => {
  it("블로그 링크가 존재한다.", () => {
    const blogLink = screen.getByText("블로그");
    expect(blogLink).toBeVisible();
  });

  it("블로그 링크가 올바른 주소로 존재한다.", () => {
    const blogLink = screen.getByText("블로그");

    expect(blogLink.tagName).toEqual("A");
    expect(blogLink).toHaveAttribute("href", "https://haneul.kr");
  });

  it("블로그는 같은 창에서 열려야 한다.", () => {
    const blogLink = screen.getByText("블로그");
    expect(blogLink).not.toHaveAttribute("target");
  });
});
```

- `beforeEach` : 각 테스트(it)를 수행하기 전에 실행하는 함수다. 여기서는 각 테스트를 실행하기에 앞서 StaticComponent를 렌더링한다.
- `describe` : 비슷한 속성을 가진 테스트를 하나의 룹으로 묶는 역할을 한다. 정의에서도 알 수 있듯, 이 describe는 꼭 필요한 메서드가 아니다. 그러나 테스트 코드가 많아지고 관리가 어려워진다면 describe로 묵어서 관리하는 것이 편리하다. describe 내부에 describe를 또 사용할 수 있다.
- `it` : test와 완전히 동일하며, test의 축약어(alias)다. it이라는 축약어를 제공하는 이유는 테스트 코드를 좀 더 사람이 읽기 쉽게 하기 위해서다. describe … it (something)과 같은 형태로 작성해 두면 테스트 코드가 한결 더 문어체 같이 표현되어 읽기 쉬워진다.
- `testId` : testId는 리액트 테스팅 라이브러리의 예약어로, get 등의 선택자로 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용할 수 있다. HTML의 DOM 요소에 testId 데이터셋을 선언해 두면 이후 테스트 시에 getByTestId, findByTestId 등으로 선택할 수 있다. 웹에서 사용하느 querySelector([data-testid=”${yourId}”])와 동일한 역할을 한다.

📍 데이터셋이 무엇인가요?

데이터셋이란 HTML의 특정 요소와 관련된 임의 정보를 추가할 수 있는 HTML 속성이다. HTML의 특정 요소에 data-로 시작하는 속성은 무엇이든 사용할 수 있다. 앞의 예제에서는 HTML에 data-testid를 추가해 getByTestId를 사용했다. 이는 특정 시나리오에서 매우 유용하게 사용할 수 있다.

다음 리액트 코드를 살펴보자.

```jsx
export default function App() {
  return (
    <ul>
      {Array.from({ length: 10 }).map((_, index) => (
        <li>
          <button>{index + 1}</button>
        </li>
      ))}
    </ul>
  );
}
```

이 코드에서 만약 버튼을 눌렀을 때 해당 index를 확인할 수 있는 코드를 작성한다고 가정해 보자. 가장 먼저 떠오르는 방법은 button의 onClick에 이벤트를 추가하되, 해당 index를 함께 넘기는 것이다.

```jsx
export default function App() {
  function handleClickButton(index: number) {
    return function (_: MouseEvent<HTMLButtonElement>) {
      console.log(index);
    };
  }

  return (
    <ul>
      {Array.from({ length: 10 }).map((_, index) => (
        <li>
          <button onClick={handleClickButton(index)}>{index + 1}</button>
        </li>
      ))}
    </ul>
  );
}
```

그러나 이 방법에는 button의 개수만큼 새로운 함수를 계속해서 생성한다는 것이다. 이는 버튼이 많아질수록 비효율적으로 작동한다. 물론 이벤트 버블링 원리를 활용해 ul에 이벤트를 추가하는 방법도 있겠지만 이 경우 해당 이벤트가 어떤 버튼의 어떤 index를 타고 가져오는지 확인하기 어렵다.

이때 활용할 수 있는 방법이 바로 데이터셋이다. HTML에 필요한 정보를 담아두면 ul에서도 우리가 원하는 정보를 가져올 수 있다.

```jsx
export default function App() {
  function handleButtonClick(e: MouseEvent<HTMLUlistElement>) {
    if (e.target instanceof HTMLButtonElement) {
      // dataset.id는 해당 요소의 data-id 값이다.
      console.log(e.target.dataset.id);
    }
  }

  return (
    <ul onClick={handleButtonClick}>
      {Array.from({ length: 10 }).map((_, index) => (
        <li>
          <button data-id={index + 1}>{index + 1}</button>
        </li>
      ))}
    </ul>
  );
}
```

→ 이렇게 하면 버튼마다 onClick 함수를 생성할 필요도 없고, 이벤트 버블링을 활용해 ul에서도 원하는 정보를 가져올 수 있다.

요약하자면 각 테스트를 수행하기 전에 StaticComponent를 렌더링하고, describe로 연관된 테스트를 묶어서 it으로 it 함수 내부에 정의된 테스트를 수행하는 테스트 파일이라고 정의할 수 있다.

여기서는 toHaveAttribute, toBeVisible 등 다양한 메서드를 사용해 테스트를 수행했다. 메서드 이름만 봐도 한눈에 무슨 역할을 하는지 확인할 수 있는 것이 Jest를 비롯한 테스팅 프레임워크의 특징이다.

Jest에서 사용 가능한 각종 어설션 메서드는 문서에서 확인할 수 있다.

### 동적 컴포넌트

**사용자가 useState를 통해 입력을 변경하는 컴포넌트**

리액트로 작성하는 컴포넌트 중 가장 흔히 볼 수 있는 것은 사용자의 입력을 useState로 받아서 처리하는 컴포넌트일 것이다. 리액트 테스팅 라이브러리에서 사용자의 입력을 흉내 내고, 또 state의 변화에 따른 컴포넌트의 변화를 테스트하는 방법을 알아보자.

아래의 예제 코드로 테스트를 해보자.

```jsx
export function InputComponent() {
  const [text, setText] = useState("");

  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {
    const rawValue = event.target.value;
    const value = rawValue.replace(/[^A-Za-z0-9]/gi, "");
    setText(value);
  }

  function handleButtonClick() {
    alert(text);
  }

  return (
    <>
      <label htmlFor="input">아이디를 입력하세요.</label>
      <input
        aria-label="input"
        id="input"
        value={text}
        onChange={handleInputChange}
        maxLength={20}
      />
      <button onClick={handleButtonClick} disabled={text.length === 0}>
        제출하기
      </button>
    </>
  );
}
```

InputComponent는 사용자의 키보드 타이핑 입력을 받는 input과 이름 alert로 띄우는 button으로 구성된 간단한 컴포넌트다. input은 최대 20자까지, 한글 입력만 가능하도록 제한되어 있다.

한글 입력을 막는 기능은 onChange에서 정규식을 활용해 강제로 value를 replace하는 방식으로 작성되어 있다.

그리고 버튼은 글자가 없으면 disabled되도록 처리돼 있고, 클릭 시 alert 창을 띄운다.

이 컴포넌트를 테스트하기 위해 다음과 같이 태스트 코드를 작성했다.

```jsx
import { fireEvent, render } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

import { InputComponent } form '.'

describe('InputComponent 테스트', () => {
	const screen = render(<InputComponent />)
	const input = screen.getByLabelText('input') as HTMLInputElement
	const button = screen.getByText(/제출하기/i) as HTMLButtonElement
	return {
		input,
		button,
		...screen,
	}

	it('input의 초깃값은 빈 문자열이다,', () => {
		const { input } =setup()
		expect(input.value).toEqual('')
	})

	it('input의 최대 길이가 20자로 설정돼 있다.', () => {
		const { input } =setup()
		expect(input).toHaveAttribute('maxlength' '20')
	})

	it('영문과 숫자만 입력된다.', () => {
		const { input } =setup()
		const inputValue = '안녕하세요123'
		userEvent.type(input, inpueValue)
		expect(input.value).toEqual('123')
	})

	if('아이디를 입력하지 않으면 버튼이 활성화되지 않는다.', () => {
		const { button } = setup()
		expect(button).toBeDisabled()
	})

	if('아이디를 입력하면 버튼이 활성화된다.', () => {
		const { button, input } = setup()

		const inputValue = 'helloworld'
		userEvent.type(input, inputValue)

		expect(input.value).toEqual(inputValue)
		expect(button).toBeEnabled()
	})

	it('버튼을 클릭하면 alert가 해당 아이디로 표시된다.', () = {
		const alertMock = jest
			.spyOn(window,'alert')
			.mockImplementation((_: string)> undefined)

		const { button, input } = setup()
		const inputValue = 'helloworld'
		userEvent.type(input, inputValue)
		fireEvent.click(button)

		expect(alertMock).toHaveBeenCalledTimes(1)
		expect(alertMock).toHaveBeenCallWith(inputValue)
	})
})
```

이 테스트 코드는 위에서 작성한 코드와 다른 점이 몇 가지 있다.

- setup 함수 : setup 함수는 내부에서 컴포넌트를 렌더링하고, 또 테스트에 필요하 button과 input을 반환한다. 이 파일에서 수행하는 모든 테스트는 렌더링과 button, input을 필요로 하므로 이를 하나의 함수로 묶어 두었다.
- useEvent.type : userEvent.type은 사용자가 타이핑하는 것을 흉내 내는 메서드다. userEvent.type을 사용하면 사용자가 키보드로 타이핑하는 것과 동일한 작동을 만들 수 있다. userEvent는 @testing-library/react에서 제공하는 fireEvent와 차이가 있다. 기본적으로 userEvent는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내 낸다. 예를 들어, userEvent.click을 수행하면 내부적으로 다음과 같으 fireEvent가 실행된다.
  - fireEvent.mouseOver
  - fireEvent.mouseMove
  - fireEvent.mouseDown
  - fireEvent.mouseUp
  - fireEvent.click
    useEvent.click은 사용자가 마우스를 움직이고, 요소에 올리고, 마우스를 클릭하는 등의 모든 작동을 수행한다. 따라서 userEvent는 사용자의 작동을 여러 fireEvent를 통해 좀 더 자세하게 흉내 내는 모듈이라고 볼 수 있다. 이러한 작동 관련 내용은 코드에서 확인할 수 있다.
    maxLength는 사용자가 하나씩 입력하는 경우에만 막히고, 코드로 한 번에 입력하는 경우에는 작동하지 않는다. fireEvent.type으로는 이 maxLength 작동을 확인할 수 없으므로 userEvent.type을 사용해야 한다.
    요약하자면, 대부분의 이벤트를 테스트할 때는 fireEvent로 충분하고 훨씬 더 빠르다. 단, 특별히 사용자의 이벤트를 흉내 내야 할 때만 userEvent를 사용하면 된다.
- jest.spyOn(window, ‘alert’).mockImplementation() : 이 구문을 이해하려면 jest.spyOn과 mockImplementation에 대해 알아야 한다.
- jest.spyOn : Jest가 제공하는 spyOn은 어떠한 특정 메서드를 오염시키지 않고 실행이 됐는지, 또 어떤 인수로 실행됐는지 등 실행과 관련된 정보만 얻고 싶을 때 사용한다. 여기서는 (window, ‘alert’)라는 인수와 함께 사용됐는데, 이는 window 객체의 메서드 alert를 구현하지 않고 해당 메서드가 실행됐는지만 관찰하겠다는 뜻이다.
  다음 예제로 확인해보자.

  ```jsx
  const calc = {
    add: (a, b) => a + b,
  };

  const spyFn = jest.spyOn(calc, "add");

  const result = calc.add(1, 2);

  expect(spyFn).toBeCalledTimes(1);
  expect(spyFn).toBeCallWith(1, 2);
  expect(result).toBe(3);
  ```

  → 이 코드에서는 `jest.spyOn`으로 calc 객체의 add 메서드를 관찰하는 것을 볼 수 있다. spyOn으로 관찰한 덕분에 한번 호출됐는지`(toBeCalledTimes(1))`, 원하는 인수와 함께 호출됐는지`(toBeCalledWith(1, 2))`를 확인할 수 있다.
  → 그리고 spyOn으로 관찰은 했지만 calc.add의 작동 자체에는 영향을 미치지 않은 것을 확인할 수 있다.
  → 이처럼 `jest.spyOn`은 특정 객체의 메서드를 오염시키지 않고 단순히 관찰하는 용도로 사용할 수 있다.

- mockImplementation : 해당 메서드에 대한 모킹(mocking) 구현을 도와준다. 현재 Jest를 실행하는 Node.js 환경에서는 window.alert가 존재하지 않으므로 해당 메서드를 모의 함수(mock)로 구현해야 하는데, 이것이 바로 mockImplementation의 역할이다. 비록 모의 함수로 구현된 함수이지만 함수가 실행됐는지 등의 정보를 확인할 수 있도록 도와준다.
  → 즉, 여기서는 Node.js가 존재하지 않는 window.alert를 테스트하기 위해 jest.spyOn을 사용해 window.alert를 관찰하게끔 하고, mockImplementation을 통해 window.alert가 실행됐는지 등의 정보를 확인할 수 있도록 처리한 것이다.
  → 이렇게 먼저 Node.js 환경에서 실행될 수 없는 window.alert를 처리해 주면 실제 alert가 발생할 때 해당 모의 함수가 실행되어 함수가 몇 번 실행됐는지, 어떤 인수와 함께 실행됐는지 관찰할 수 있다.

Jest에서 사용자 작동을 흉내내는 메서드는 type 외에도 클릭(click), 더블클릭(dbclick), 클리어(clear) 등 다양하며, 이러한 메서드를 활용하면 웬만한 사용자 작동을 재현할 수 있다.

정적인 컴포넌트에 비해 테스트 코드가 복잡하지만 액션이 수행된 이후에 DOM에 기댓값이 반영됐는지 확인하는 방법은 동일하다.

### 비동기 이벤트가 발생하는 컴포넌트

이번에는 비동기 이벤트에서 자주 사용되는 fetch가 실행되는 컴포넌트로 에를 들어보자.

```jsx
import { MouseEvent, useState } from 'react'

interface TodoResponse {
	userId: number
	id: number
	title: string
	completed: false
}

export function FetchComponent() {
	const [data, setData] = useState<TodoResponse | null>(null)
	const [error, setError] = useState<number | null>(null)

	async function handleButtonClick(e: MouseEvent<HTMLButtonElement>) {
		const id = e.currentTarget.dataset.id

		const response = await fetch(`/todos/${id}`)

		if (response.of) {
			const reult: TodoResponse = await response.json()
			setData(result)
		} else {
			setError(response.status)
		}

		return (
			<div>
				<p>{data === null ? '불러온 데이터가 없습니다,' : data.title}</p>
				{error && <p style={{ backgroundColor: 'red' }}>에러가 발생했습니다</p>}

				<ul>
					{Array.from({ length: 10 }).map((_, index) => {
						const id = index + 1
						return (
							<button key={id} data-id={id} onClick={handleButtonClick}>
							{`${id}번`}
							</button>
						)
					}))
				</ul>
			</div>
		)
	}

```

→ 이 코드는 버튼을 클릭하면 /todos/:id로 fetch 요청을 보내 데이터를 불러오는 컴포넌트이다. 데이터를 불러오는 데 성공하면 응답값 중 하나를 노출하지만, 실패하면 에러 문구를 노출하는 컴포넌트로, 일반적인 애플리케이션에서 자주 볼 수 있는 패턴 중 하나다.

여기서는 jest.spyOn 등을 활용해서 fetch를 모킹하는 하여 테스트할 수 있다.

아래 코드로 확인해보자. fetch를 모킹한 코드이다.

```jsx
jest.spyOn(window, 'fetch').mockImplementation(
	jest.fn(() =>
		ok: true,
		statue: 200,
		json: () => Promise.resolve(MOCK_TODO_RESPONSE),
	) as jest.Mock,  // 실제로 정확하게 fetch를 모팅하려면 많은 메서드를 구현해야 하지만 여기서는 간단하게 json만 구현하고 어설션으로 간단하게 처리했다.
)
```

→ 이 방법으로 테스트는 가능하지만 모든 시나리오를 해결할 수 없다.

서버 응답에서 오류가 발생한 경우는 ok, status, json의 모든 값을 바꿔서 다시 모킹해야 한다. 이 방법은 테스트를 수행할 때마다 모든 경우를 새롭게 모킹해야 하므로 테스트 코드가 길고 복잡해진다.

또한 fetch가 할 수 있는 다양한 일(headers를 설정하거나, text()로 파싱하거나, status의 값을 다르게 보는 등)을 일일이 모킹해야 하므로 테스트 코드가 길어지고 유지보수도 어렵다.

👉 이러한 문제를 해결하기 위해 `MSW(Mock Service Worker)`가 등장했다.

`MSW`는 Node.js나 브라우저에서 모두 사용할 수 있는 모킹 라이브러리로, 브라우저에서는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현한다. 그리고 Node.js 환경에서는 https나 XMLHttpRequest의 요청을 가로채는 방식으로 작동한다. 즉, Node.js나 브라우저에서는 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행하고, 이 요청을 중간에 MSW가 감지하고 미리 준비한 모킹 데이터를 제공하는 방식이다.

이러한 방식은 fetch의 모든 기능을 그대로 사용하면서도 응답에 대해서만 모킹할 수 있으므로 fetch를 모킹하는 것이 훨씬 수월해진다.

비단 테스트 코드뿐만 아니라 create-react-app, Next.js 등 다양한 환경에서도 사용 가능하므로 모킹에 대해 고민하고 있다면 사용해 보는 것을 추천한다.

`MSW`를 활용해 fetch 응답을 모킹한 테스트 코드를 다음과 같이 작성했다.

```jsx
import { fireEvent, render, screen } from '@testing-library/react'
import { rest } from 'msw'
import { setupServer } from 'msw/node'

import { FetchComponent } from '.'

const MOCK_TODO_RESPONSE = {
	userId: 1,
	id: 1,
	title: 'delectus aut autem',
	completed: false,
}

const server = setupServer(
	rest.get('/todos/:id', (req, res, ctx) => {

		if (Nunber(todoId) {
			return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))
		} else {
			return res(ctx.status(404))
		}
	}),
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

beforeEach(() => {
	render(<FetchComponent />)
})

describe('FetchComponent 테스트', () => {
	it('데이터를 불러오기 전에는 기본 문구가 뜬다.', async () => {
		const nowLoading = screen.getByText(/불러온 데이터가 없습니다./)
		expect(nowLoading).toBeInTheDocument()
	})

	it('버튼을 클릭하면 데이터를 불러온다.' , async() => {
		const button = screen.getByRole('button', { name: /1번/ })
		fireEvent.click(button)

		const data = await screen.findByText(MOCK_TODO_RESPONSE.title)
		expect(data).toBeInTheDocument()
	})

	it('버튼을 클릭하고 서버 요청에서 에러가 발생하면 에러 문구를 노출한다.' async () => {
		server.use(
			rest.get('/todos/:id', (req, res, ctx) => {
				retirn res(ctx.status(503))
			}),
		)

		const button = screen.getByRole('button', { name: /1번/ })
		fireEvent.click(button)

		const error = await screen.findByText(/에러가 발생했습니다 /)
		expect(error).toBeInTheDocument()
	})
})
```

위 코드를 나워서 살펴보자.

```jsx
const server = setupServer(
	rest.get('/todos/:id', (req, res, ctx) => {

		if (Nunber(todoId) {
			return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))
		} else {
			return res(ctx.status(404))
		}
	}),
)
```

→ MSW를 활용해 fetch 응답을 모킹했다. setupServer는 MSW에서 제공하는 메서드로, 이름 그대로 서버를 만드는 역할을 한다. 그리고 이 함수 내부에서 Express나 Koa와 비슷하게 라우트를 선언할 수 있다.

→ 그리고 이 라우트 내부에서 서버 코드를 작성하는 것과 동일하게 코드를 작성하고, 대신 응답하는 데이터만 미리 준비해 둔 모킹 데이터를 반환하면 된다.

→ 테스트 코드에서는 라우트 /todos/:id의 요청만 가로채서 todoId가 숫자인지 확인한 다음, 숫자일 때만 MOCK_TODO_RESPONSE와 id를 반환하고, 숫자가 아니라면 404를 반환하도록 코드를 구성했다.

```jsx
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

→ 테스트 코드를 시작하기 전에는 서버를 가동하고, 테스트 코드 실행이 종료되면 서버를 종료시킨다. 한 가지 눈에 띄는 것은 afterEach에 있는 server.resetHandlers()다. 이 코드는 앞에서 선언한 setupServer의 기본 설정으로 되돌리는 역할을 한다.

→ 일반적인 경우라면 필요 없지만, 뒤이어서 작성할 ‘서버에서 실패가 발생하는 경우’를 테스트할 때는 res를 임의로 ctx.status(503)과 같은 형태로 변경할 것이다.

→ 그러나 이를 리셋하지 않으면 계속해서 실패하는 코드로 남아있을 것이므로 테스트 실행마다 resetHandlers를 통해 setupServer로 초기화했던 초깃값을 유지하는 것이다.

그 다음 아래 코드는 describe를 시작으로 테스트하고 싶은 내용을 테스트 코드로 작성했다.

```jsx
it("버튼을 클릭하면 데이터를 불러온다.", async () => {
  const button = screen.getByRole("button", { name: /1번/ });
  fireEvent.click(button);

  const data = await screen.findByText(MOCK_TODO_RESPONSE.title);
  expect(data).toBeInTheDocument();
});
```

→ 여기서부터는 본격적으로 비동기 이벤트, 버튼을 클릭해 fetch가 발생하는 시나리오를 테스트한다. 버튼을 클릭하는 것까지는 동일하지만 fetch 응답이 온 뒤에서야 비로소 찾고자 하는 값을 렌더링할 것이다.

→ 원하는 값을 동기 방식으로 즉시 찾는 get 메서드 대신, 요소가 렌더링될 때까지 일정 시간 동안 기다리는 find 메서드를 사용해 요소를 검색한다.

```jsx
it('버튼을 클릭하고 서버 요청에서 에러가 발생하면 에러 문구를 노출한다.' async () => {
		server.use(
			rest.get('/todos/:id', (req, res, ctx) => {
				retirn res(ctx.status(503))
			}),
		)

		const button = screen.getByRole('button', { name: /1번/ })
		fireEvent.click(button)

		const error = await screen.findByText(/에러가 발생했습니다 /)
		expect(error).toBeInTheDocument()
})
```

→ 앞에서 작성하 setupServer에서는 정상적인 응답만 모킹했기 때문에 에러가 발생하는 경우를 테스트하기 어렵다.

→ 서버 응답이 실패하는 경우를 테스트하기 위해 server.use를 사용해 기존 setupServer의 내용을 새롭게 덮어 쓴다.

→ 여기서는 /todos/:id 라우팅을 모든 경우에 503이 오도록 작성했다. 서버 설정이 끝난 이후에는 앞선 테스트와 동일하게 findBy를 활용해 에러 문구가 정상적으로 노출됐는지 확인한다.

→ server.use를 활용한 서버 기본 작동을 덮어쓰는 작업은 ‘it(’버튼을 클릭하고 서버 요청에서 에러가 발생하면 에러 문구를 노출한다.’, async () ⇒ {…에서만 유효해야 한다. 다른 테스트 시에는 원래대로 서버 작동이 다시 변경되어야 하므로 afterEach에서 resetHandlers를 실행한다. 이렇게 하면 it 내부의 server.use 구문이 종료된 이후에는 503 에러 라우팅은 사라지고 다시 정상적인 응답만 받을 수 있게 된다.

❣️앞에서 다룬 테스트가 가장 마지막에 수행하는 테스트이므로 resetHandlers를 제거해도 테스트 결과가 달라지지 않을 것이다. 그러나 테스트 케이스가 가장 마지막에 수행되지 않고, resetHandlers를 수행하지 않는다면 다른 테스트 케이스에서도 503 에러를 받게 되므로 주의해야 한다.

**📍 중요한 것**

- MSW를 사용한 fetch 응답 모킹
- findBy를 활용해 비동기 요청이 끝난 뒤에 제대로 된 렌더링이 일어났는지 기다린 후에 확인

## 🖌️ 사용자 정의 훅 테스트하기

`react-hooks-testing-library`를 활용하면 훅을 테스트 할 수 있다.

우선 `useEffectDebugger`라는 훅을 테스트해보자. 이 훅은 컴포넌트명과 props를 인수로 받아 해당 컴포넌트가 어떤 props의 변경으로 인해 리렌더링됐는지 확인해 주는 일종의 디버거 역할을 한다.

이 훅이 구현할 기능은 다음과 같다.

- 최초 컴포넌트 렌더링 시에는 호출하지 않는다.
- 이전 props를 useRef에 저장해 두고, 새로운 props를 넘겨받을 때마다 이전 props와 비교해 무엇이 렌더링을 발생시켰는지 확인한다.
- 이전 props와 신규 props의 비교는 리액트의 원리와 동일하게 Object.is를 활용해 얕은 비교를 수행한다.
- process.env.NODE_ENV === ‘production’인 경우에는 로깅을 하지 않는다. 이는 웹팩을 빌드 도구로 사용할 경우 일반적으로 트리쉐이킹이 이뤄지는 일종의 최적화 기법이다. 웹팩을 비롯한 많은 번들러에서는 process.env.NODE_ENV === ‘production’인 경우에는 해당 코드가 빌드 결과물에 포함되지 않는다. 이는 운영 환경에서는 해당 코드가 실행되지 않는다는 의미다.

아래 코드에서 `useEffectDebugger` 훅을 확인해보자.

```jsx
import { useEffect, useRef, DependencyList } from 'react'

export type Props = Record<string, unknown>

export const CONSOLE_PREFIX = '[useEffectDebugger]'

export default function useEffectDebugger(
	compenentName: string,
	props?: Props,
) {
	const prevProps = useRef<Props | undefined>()

	useEffect(() => {
		if (process.env.NODE_ENV === 'production') {
			return
		}

		const prevPropsCurrent = prevProps.current

		if (prePropsCurrent !== undefined) {
			const allKeys = Object.keys({ ...prevProps.current, ...props })

			const changedProps: Props = allKeys.reduce<Props>((result, key) => {
				const prevValue = prevPropsCurrent[key]
				const currentValue = props ? props[key] : undefined

				if (!Object.is(prevValue, currentValue)) {
					result[key] = {
						before: prevValue,
						after: currentValue,
					}
				}

				return result
			}, {})

			if (Object.keys(changedProps).length) {
				// eslint-disable-next-line no-console
				console.log(CONSOLE_PREFIX, componentName, changedProps)
			}
		}

		prevProps.current = props
	})
}
```

이 훅은 다음과 같이 사용할 수 있다.

```jsx
import { useState } from "react";

import useEffectDebugger from "./useEffectDebugger";

function Test(props: { a: string, b: number }) {
  const { a, b } = props;
  useEffectDebugger("TestComponent", props);

  return (
    <>
      <div>{a}</div>
      <div>{b}</div>
    </>
  );
}

function App() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount((count) => count + 1)}>up</button>
      <Test a={count % 2 === 0 ? "짝수" : "홀수"} b={count} />
    </>
  );
}

export default App;
```

👇 출력 결과는 다음과 같다.

![Untitled 12](https://github.com/user-attachments/assets/04ec9fd4-d205-4602-b7be-a6b99860cb73)

→ useEffectDebugger는 어디까지나 props가 변경되는 것만 확인할 수 있다는 것을 염두에 둬야 한다. 다은 렌더링 시나리오, 예를 들어 props가 변경되지 않았지만 부모 컴포넌트가 리렌더링되는 경우에는 useEffectDebugger로 확인할 수 없다.

props를 useRef에 저장해 두고, 이후에 새롭게 들어오는 props를 비교해 변경된 값만 console.log로 로깅을 남기고 있다. 여러 가지 컴포넌트에 적용해 보면서 얼추 의도한 대로 작동한다는 것을 확인할 수 있다.

하지만 테스트 코드를 통해 확인해보는 것이 확실하니 useEffectDebugger를 테스트하는 코드를 작성해보자.

```jsx
import { renderHook } from "@testing-library/react";

import useEffectDebugger, { CONSOLE_PREFIX } from "./useEffectDebugger";

const consoleSpy = jest.spyOn(console, "log");
const componentName = "TestComponent";
```

→ 해당 훅은 console.log를 사용하므로 jest.spyOn을 사용해 console.log 호출 여부를 확인한다. 그리고 테스트 대상 컴포넌트의 이름을 componentName에 저장한다.

```jsx
describe("useEffectDebugger", () => {
  afterAll(() => {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    process.env.NODE_ENV = "development";
  });
  // ...
});
```

→ 만약 프로젝트가 리액트 18 버전 미만을 사용한다면 @testing-library/react 대신 `@testing-library/react-hooks`를 사용해야 한다. 리액트 18부터는 `@testing-library/react`에 통합됐다.

→ 매번 테스트가 끝난 후에는 `process.env.NODE_ENV`를 다시 development로 변경한다.

`process.env.NODE_ENV` 할당문을 강제로 작성한 이유는 타입스크립트에서는 NODE_ENV를 읽기 전용 속성으로 간주하기 때문이다.

```jsx
it("props가 없으면 호출되지 않는다.", () => {
  renderHook(() => useEffectDebugger(componentName));

  expect(consoleSpy).not.toHaveBeenCalled();
});

it("최초에는 호출되지 않는다.", () => {
  const props = { hello: "wrold" };

  renderHook(() => useEffectDebugger(componentName, props));

  expect(consoleSpy).not.toHaveBeenCalled();
});
```

→ 훅을 렌더링하기 위해서는 renderHook을 래핑해서 사용해야 한다.

→ 이때 use로 시작하는 사용자 정의 훅임에도 불구하고 훅의 규칙을 위반한다고 경고 메시지를 출력하지 않는다.

→ 이 코드가 실행될 수 있는 비결은 renderHook 내부에 있다. renderHook 함수를 살펴보면 내부에서 TestComponent라고 하는 컴포넌트를 생성하고, 이 컴포넌트 내부에서 전달받은 훅을 실행하는 것을 알 수 있다.

→ 훅의 규칙을 위반하지 않기 위해 renderHook 내부에서 컴포넌트를 만들어 훅의 규칙을 위반하지 않는 것을 확인할 수 있다.

또 다른 테스트 코드를 작성해 보자.

```jsx
it("props가 변경되지 않으면 호출되지 않는다.", () => {
  const props = { hello: "world" };

  const { rerender } = renderHook(() =>
    useEffectDebugger(componentName, props)
  );

  expect(consoleSpy).not.toHaveBeenCalled();

  rerender();

  expect(consoleSpy).not.toHaveBeenCalled();
});
```

→ 이번 테스트에서는 컴포넌트를 다시 렌더링해 훅 내부의 console.log가 실행되지 않는지를 확인한다.

→ renderHook 내부에서는 컴포넌트를 하나 새로 만들어서 훅을 사용하는데, 만약 renderHook을 한번 더 실행하면 훅을 두 번 실행하는 것을 테스트할 수 없다.

- 그 이유는 앞에서 이야기 했듯이 훅의 규칙을 우회하기 위한 트릭, 즉 TestComponent의 생성 작업을 두 번 하게 되기 때문이다.
- 즉, renderHook 하나당 하나의 독립된 컴포넌트가 생성되므로 같은 컴포넌트에서 훅을 두 번 호출하려면 renderHook이 반환하는 객체의 값 중 하나인 rerender 함수를 사용해야 한다.

→ rerender 외에도 unmount라는 함수를 반환하는데, 이름 그대로 이 함수를 실행하면 컴포넌트를 언마운트한다.

```jsx
it("props가 변경되면 다시 호출한다.", () => {
  const props = { hello: "world" };

  const { rerender } = renderHook(
    ({ componentName, props }) => useEffectDebugger(componentName, props),
    {
      initialProps: {
        componentName,
        props,
      },
    }
  );

  const newProps = { hello: "world2" };

  rerender({ componentName, props: newProps });

  expect(consoleSpy).toHaveBeenCalled();
});
```

→ 테스트 코드에서는 props 비교를 정확히 하고 있는지 확인하기 위해 훅에 서로 다른 props를 인수로 넘겨야 한다.

→ 이를 위해 renderHook에서는 함수의 초깃값인 InitialProps를 지정할 수 있는데, 이를 사용하면 훅의 초기값을 지정할 수 있다.

→ 그리고 이후에 rerender 함수를 호출할 때, 여기서 지정한 초깃값을 변경해 다시 렌더링할 수 있다.

```jsx
it("process.env.NODE_ENV가 production이면 호출되지 않는다", () => {
  // eslint-diaslbe-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  process.env.NODE_ENV = "production";

  const props = { hello: "world" };

  const { rerender } = renderHook(
    ({ componentName, props }) => useEffectDebugger(componentName, props),
    {
      initialProps: {
        componentName,
        props,
      },
    }
  );

  const newProps = { hello: "world2" };

  rerender({ componentName, props: newProps });

  expect(consoleSpy).toHaveBeenCalled();
});
```

→ process.env.NODE_ENV = ‘production’을 설정하면 어떠한 경우에도 consoleSpy가 호출되지 않는지 확인한다.

→ process.env.NODE_ENV에 production 값을 강제로 주입했고, 그 결과 훅 내부에서 props가 변경되더라도 아무런 작동도 하지 않는 것을 확인할 수 있었다.

📍 react-hooks-testing-library를 사용하면 굳이 테스트를 위한 컴포넌트를 만들지 않아도 훅을 간편하게 테스트할 수 있다. 또한 renderHook 함수에서 훅을 편리하게 테스트하기 위한 rerender, unmount 등의 함수도 제공하고 있으므로 사용자 정의 훅을 테스트하고 싶으면 사용하는 것을 추천한다.

## 🖌️ 테스트를 작성하기에 앞서 고려해야 할 점

- 흔히 알고 있는 사실중에 테스트 커버리지가 높을수록 좋고 꾸준히 테스트 코드를 작성하나는 이야기가 있다.

  → 그러나 테스트 커버리지는 만능이 아니다. 먼저 테스트 커버리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘 되고 있는지를 나타내는 것은 아니다. 그래서 절대 테스트 커버리지를 맹신하면 안된다.

- 테스트 커버리지를 100%까지 끌어올릴 수 있는 상황은 생각보다 드물다.
  - TDD(Test Driven Development; 테스트 주도 개발)라고 하는 개발 방법론을 차용해서 테스트를 우선시하더라도 서버 코드와는 다르게 프론트엔드 코드는 사용자의 입력이 매우 자유롭기 때문에 이러한 모든 상황을 커버해 테스트를 작성하기란 불가능하다.
  - 또한 실무에서는 테스트 코드를 작성하고 운영할만큼 여유로운 상황이 별로 없어 때로는 테스트를 QA에 의존해 개발을 빠르게 진행해야 할 수도 있고, 이후에 또 개발해야 할 기능이 산적해 있을 수도 있다.

❣️ 따라서 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 **애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것**이다.

예를 들어,

전자상거래 애플리케이션을 만든다고 가정해보자.

애플리케이션의 모든 부분이 우선순위를 가릴 수 없이 중요하겠지만 가장 신경 써야 할 것은 바로 결제일 것이다.

결제에 대해 테스트하기로 마음먹었다면 해당 결제와 연관되어 테스트가 필요한 코드를 파악해야 할 것이다. 그리고 해당 코드들이 어떻게 순차적으로 실행되는지 확인한 다음, 그 순차적인 프로세스에 맞춰 테스트 코드를 작성하면 된다. 이 테스트가 통과해야 할 테스트 코드는 반드시 사용자의 작업과 최대한 유사하게 작성돼야 한다.

예를 들어, 결제일 위해 사용자가 입력하는 절차, 장바구니, 주소 입력, 결제까지의 과정을 모두 사용자와 최대한 비슷한 입장에서 테스트를 작성하는 것이 필요하다.

❣️이처럼 애플리케이션에서 가장 핵심이 되는 부분부터 먼저 테스트 코드를 하나씩 작성해 나가는 것이 중요하다

## 🖌️ 그 밖에 해볼 만한 여러 가지 테스트

- `유닛 테스트(Unit Test)` : 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증하는 테스트
- `통합 테스트(Integration Test)` : 유닛 테스트를 통과한 여러 컴포넌트가 묶어서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- `엔드 투 엔드(End to End Test)` : 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트

→ 리액트 테스팅 라이브러리 유닛 테스트 내지는 통합 테스트를 도와주는 도구이며, E2E 테스트를 수행하려면 Cypress 같은 다른 라이브러리의 힘을 빌려야 한다.
