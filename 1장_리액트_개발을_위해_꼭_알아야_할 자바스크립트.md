# 리액트 개발을 위해 꼭 알아야 할 자바스크립트

# 📑 자바스크립트의 동등 비교

리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

## 🖌️ 자바스크립트의 데이터 타입

### 원시타입

객체가 아닌 모든 타입을 의미 → 객체가 아니므로 이러한 타입들은 메서드를 갖지 않는다.

- boolean : 참(true)와 거짓(false)만을 가질 수 있는 데이터 타입. 주로 조건문에서 많이 쓰이는 데이터 타입
  - falsy : 조건문 내부에서 false로 취급되는 값
    | 값              | 타입           | 설명                                                                 |
    | --------------- | -------------- | -------------------------------------------------------------------- |
    | false           | Boolean        | false는 대표적인 falsy한 값이다.                                     |
    | 0, -0, 0n, 0x0n | Number, BigInt | 0은 부호나 소수점 유무에 상관없이 falsy한 값이다.                    |
    | NaN             | Number         | Number가 아니라는 것을 뜻하는 NaN(Not a Number)은 falsy한 값이다.    |
    | ‘’, “”, ``      | String         | 문자열이 falsy하기 위해서는 반드시 공백이 없는 빈 문자열이어야 한다. |
    | null            | null           | null은 falsy한 값이다.                                               |
    | undefined       | undefined      | undefined는 falsy한 값이다.                                          |
  - truthy : 조건문 내부에서 true로 취급되는 값. falsy로 취급되는 값 이외에는 모두 true로 취급.
    ❣️객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다. 즉 {}, [] 모두 truthy한 값이다.
- null : 아직 값이 없거나 비어 있는 값을 표현할 때 사용
- undefined : 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
- Number : 자바스크립트는 정수 실수 구분없이 모든 숫자를 하나의 타입에 저장
  - 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않아 모두 10진수로 해석되어 동일한 값으로 표시된다.
- String : 텍스트 타입의 데이터를 저장하기 위해 사용
  - 한 쌍의 작은따옴표(’)나 큰따옴표(”), 또는 내장 표현식을 허용하는 문자열 리터럴 표현 방식인 백틱(`)으로도 표현할 수 있다.
  - 백틱(`)을 사용해서 표현한 문자열은 템플릿 리터럴(template literal)이라고 하는데, 같은 문자열을 반환하지만 줄바꿈이 가능하고, 문자열 내부에 표현식을 쓸 수 있다는 차이가 있다.
  - 자바스크립트 문자열의 특징 중 하나는 문자열이 원시 타입이며 변경 불가능하다는 것이다. → 한번 문자열이 생성되면 그 문자열을 변경할 수 없음을 의미한다.
- Symbol : ES6에서 새롭게 추가된 7번째 타입, 중복되지 않은 어떠한 고유한 값을 나타내기 위해 만들어졌다.
  - 심벌은 심벌 함수를 이용해서만 만들 수 있다. 즉, 심벌을 생성하려면 반드시 Symbol()을 사용해야만 한다.
  ```jsx
  // Symbol 함수에 같은 인수를 넘겨주더라도 이는 동일한 값으로 인정되지 않는다.
  // 심벌 함수 내부에 넘겨주는 값은 Symbol 생성에 영향을 미치지 않는다(Symbol.for 제외).
  const key = Symbol("key");
  const key2 = Symbol("key");

  key === key2; // false

  // 동일한 값을 사용하기 위해서는 Symbol.for을 활용한다.
  Symbol.for("hello") === Symbol.for("hello"); //true
  ```
- BigInt : Number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 나온 타입 (number의 한계를 넘어서 더 큰 숫자를 저장할 수 있게 해준다)

### 객체타입(object/reference type)

7가지 원시 타입 이외의 모든 것, 즉 자바스크립트를 이루고 있는 대부분의 타입이다. → `배열, 함수, 정규식, 클래스` 등 포함

❣️객체 타입(object type)은 참조를 전달한다고 해서 참조 타입(reference type)으로도 불린다.

- object

```jsx
typeof [] === "object"; // true
typeof [] === "object"; // true

function hello() {}
typeof hello === "function"; // true

const hello1 = function () {};

const hello2 = function () {};

// 객체인 함수의 내용이 육안으로는 같아 보여도 참조가 다르기 때문에 false가 반환된다.
hello1 === hello2; // false
```

## 🖌️ 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식의 차이이다. → 이 차이가 동등 비교를 할 때 차이를 만든다.

- 원시타입은 불변 형태의 값으로 저장된다. 그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.
  → 값을 비교하기 때문에, 값을 전달하는 방식이 아닌 각각 선언하는 방식으로도 두 값을 비교해도 동일한 결과가 나온다.
- 반면, 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.
  ```jsx
  var hello = {
    greet: "hello, world",
  };

  var hi = {
    greet: "hello, world",
  };

  // 동등 비교를 하면 false가 나오고
  console.log(hello === hi); // false

  // 원시값인 내부 속성값을 비교하면 동일하다.
  console.loog(hello.greet === hi.greet); // true
  ```

## 🖌️ 자바스크립트의 또 다른 비교 공식, Object.is

Object.is는 두 개의 인수를 받으며, 이 인수 두개가 동일한지 확인하고 반환하는 메서드이다.

- `==` vs `Object.is` : == 비교는 같음을 비교하기 전에 양쪽에 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환(type casting)을 한 후에 비교한다. 따라서 5 == ‘5’와 같이 형변환 후에 값이 동일하다면 ==는 true를 반환한다.
  하지만 Object.is는 이러한 작업을 하지 않는다. 즉, ===와 동일하게 타입이 다르면 그냥 false이다.
- `===` vs `Object.is` : Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다.

  ```jsx
  -0 === +0; // true
  Object.is(-0, +0); // false

  Number.NaN === NaN; // false
  Object.is(Number.NaN, NaN); // true

  NaN === 0 / 0; // false
  Object.is(NaN, 0 / 0); // true
  ```

- ❣️Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다.
  ```jsx
  Object.is({}. {})  // false

  const a = {
  	hello: 'hi',
  }

  const b = a

  Object.is(a, b)  // true
  a === b
  ```

👉 Object.is는 ES6(ECMAScript 2015)에서 새롭게 도입된 비교 문법으로, 위와 같이 몇 가지 특별한 사항에서 동등 비교 ===가 가지는 한계를 극복하기 위해 만들어졌다. 하지만 여전히 객체 간 비교에 있어서는 자바스크립트의 특징으로 인해 ===와 동일하게 동작하는 것을 알 수 있다.

## 🖌️ 리액트에서의 동등 비교

- 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 이 Object.is다. Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(Polyfill)을 함께 사용한다.

```jsx
// flow로 구현돼 있어 any가 추가돼 있다. flow에서 any는 타입스크립트와 동일하게 어떠한 값도 받을 수 있는 타입을 의미한다.
function is(x: any, y: any) {
	return (
		(x === y (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) //eslint-disable-line no-self-compare
	)
)

//런타임에 Object.is가 있다면 그것을 사용하고, 아니면 위 함수를 사용한다.
//Object.is는 인터넷 인스플로러 등에 존재하지 않기 때문에 플리필을 넣어준 것으로 보인다.
const objectIs: (x: any, y: any) => boolean =
	typeof Object.is === 'function' ? Object.is : is

export default objectIs
```

👇 리액트에서는 이 `ObjectIs`를 기반으로 동등 비교를 하는 `shallowEqual`이라는 함수를 만들어 사용한다. `shallowEqual`은 의존성 비교 등 리액트의 동등 비교가 필요한 다양한 곳에서 사용된다.

```jsx
import is from "./objectIs";
// 다음 코드는 Object.prototype.hasOwnProperty다.
// 이는 객체에 특정 프로퍼티가 있는지 확인하는 메서드다.
import hasOwnProperty from "./hasOwnProperty";

/**
 * 주어진 객체의 키를 순회하면서 두 값이 엄격한 동등성을 가지는지를 확인하고,
 * 다른 값이 있다면 false를 반환한다. 만약 두 객체 간에 모든 키의 값이 동일하다면 true를 반환한다.
 */
// 단순히 Object.is를 수행하는 것뿐만 아니라 객체 간의 비교도 추가돼 있다.
function shallowEqual(objA: mixed, objB: mixed): boolean {
  if (is(objA, objB)) {
    return true;
  }

  if (
    typeof objA !== "object" ||
    objA === null ||
    typeof objB !== "object" ||
    objB === null
  ) {
    return false;
  }

  // 각 키 배열을 꺼낸다.
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  // 배열의 길이가 다르다면 false
  if (keysA.length !== keysB.length) {
    return false;
  }

  // A의 키를 기준으로, B에 같은 키가 있는지, 그리고 그 값이 같은지 확인한다.
  for (let i = 0; i < keysA.length; i++) {
    const currentKey = keysA[i];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !is(objA[currentKey], objB[currentKey])
    ) {
      return false;
    }
  }

  return true;
}

export default shallowEqual;
```

- 요약하자면 Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행하는 것을 알 수 있다. 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

  ```jsx
  // Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
  Object.is({ hello: "world" }, { hello: "world" }); // false

  // 반면 리액트 팀에서 구현한 shallowEqual은 객체의 1 depth까지는 비교가 가능하다.
  shallowEqual({ hello: "world" }, { hello: "world" }); // true

  // 그러나 2 depth까지 가면 이를 비교할 방법이 없으므로 false를 반환한다.
  shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
  ```

- 이와같이 객체의 얕은 비교까지만 구현한 이유는 리액트에서 사용하는 JSX props는 객체이고, 여기에 있는 props만 일차적으로 비교하면 되기 때문이다.

  ```jsx
  type Props = {
    hello: string,
  };

  function HelloComponent(props: Props) {
    return <h1>{props.hello}</h1>;
  }

  //...

  function App() {
    return <HelloComponent hello="hi!" />;
  }
  ```

  → props는 객체로, 기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분하다. 이러한 특성을 알고 있다면 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

- `React.memo`의 깊은 비교를 했을 때 문제
  ```jsx
  import { memo, useEffect, useState } from "react";

  type Props = {
    counter: number,
  };

  const Component = memo((props: Props) => {
    useEffect(() => {
      console.log("Component has been rendered!");
    });

    return <h1>{props.counter}</h1>;
  });

  type DeeperProps = {
    counter: {
      counter: number,
    },
  };

  const DeeperComponent = memo((props: DeeperProps) => {
    useEffect(() => {
      console.log("DeeperComponent has been rendered!");
    });

    return <h1>{props.counter.counter}</h1>;
  });

  export default function App() {
    const [, setCounter] = useState(0);

    function handleClick() {
      setCounter((prev) => prev + 1);
    }
    return (
      <div className="App">
        <Component counter={100} />
        <DeeperComponent counter={{ counter: 100 }} />
        <button onClick={handleClick}>+</button>
      </div>
    );
  }
  ```
  props가 깊어지는 경우, 즉 한 객체 안에 또다른 객체가 있을 경우 React.memo는 컴포넌트에 실제로 변경된 값이 없음에도 불구하고 메모이제이션된 컴포넌트를 반환하지 못한다. 즉, Component는 props.counter가 존재하지만, DeeperComponent는 props.counter.counter에 props가 존재한다.
  상위 컴포넌트인 App에서 버튼을 클릭해서 강제로 렌더링을 일으킬 경우, shallowEqual을 사용하는 Component 함수는 위 로직에 따라 정확히 객체 간 비교를 수행해서 렌더링을 방지해 주었지만 DeeperComponent 함수는 제대로 비교하지 못해 memo가 작동하지 않는 결과를 볼 수 있다.
  만약 내부에 있는 객체까지 완벽하기 비교하기 위한 재귀문을 넣었다면 객체 안에 객체가 몇 개까지 있을지 알 수 없으므로 성능에 악영향을 미쳤을 것이다.

# 📑 함수

## 🖌️ 함수란 무엇인가?

- 자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.
- 리액트에서 컴포넌트를 만드는 함수도 함수의 기초적인 형태를 따르면서 생성된다.
  ```jsx
  function Component(props) {
    return <div>{props.hello}</div>;
  }
  ```
  → Component라고 하는 함수를 선언하고 매개변수로는 일반적으로 props라고 부르는 단일 객체를 받으며 return 문으로 JSX를 반환한다.
  → 일반적인 함수와의 차이점은, 자바스크립트에서는 Component(props) 형태로 호출하지만, 리액트에서의 함수 컴포넌트는 <Component hello={props.hello}… />와 같이 JSX 문법으로 단일 props별로 받거나, <Component {…props} /> 같은 형태로 모든 props를 전개 연산자로 받는다는 차이가 있다.
  → 그리고 JSX 형태 외에도 일반적인 자바스크립트 문법으로 함수 컴포넌트를 호출하는 것도 가능하다.

## 🖌️ 함수를 정의하는 4가지 방법

### 함수 선언문

자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식이다.

```jsx
function add(a, b) {
  return a + b;
}
```

- 함수 선언문은 표현식이 아닌 일반 문(statement)으로 분류된다. 표현식이란 무언가 값을 산출하는 구문을 의미한다.

### 함수 표현식

- 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
- 자바스크립트에서 함수는 일급 객체이다. 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.
- 일급 객체는 함수를 변수에 할당하는 것이 가능하다.

  ```jsx
  const sum = function (a, b) {
    return a + b;
  };

  sum(10, 24); //34
  ```

- 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다. → 코드를 봤을 때 혼란을 방지하기 위함
  → add 명칭 생략

✅ 함수 표현식과 선언 식의 차이점

- 이 두가지 방식의 가장 큰 차이는 호이스팅(hoising) 여부이다.
- 함수의 호이스팅이란?

  > 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징을 의미한다.

  ```jsx
  hello(); // hello

  function hello() {
    consoole.log("hello");
  }

  hello(); // hello
  ```

  → 함수 선언 전에 hello를 호출해도 에러가 나지 않는 이유는 호이스팅때문이다.

  → 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다. (`호이스팅 덕분에 함수 선언문이 미리 메모리에 등록됐고, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 된다`)

- 반면 함수의 표현식은 함수를 변수에 할당하고 변수도 마찬가지로 호이스팅이 발생한다. 그러나 함수의 호이스팅과는 다르게, 호이스팅되는 시점에서 var의 경우에는 undefined로 초기화한다는 차이가 있다.
  ```jsx
  console.log(typeof hello === "undefined"); // true

  hello(); // Uncaught TypeError: hello is not a function

  var hello = function () {
    console.log("hello");
  };

  hello();
  ```
  → 이 예제는 정상적으로 호출되지 않고, undefined로 남아있는 것을 알 수 있다.
  → 함수와 다르게 변수는, 런타임 이전에 undefined로 초기화되고, 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다는 것을 알 수 있다.

❓ 그렇다면 둘 중 어떤 것이 좋을까?

함수를 자유롭게 선언하고 어디서든 자유롭게 호출하고 싶거나, 변수 선언과 다르게 명시적으로 함수를 구별하고 싶을 때는 함수 선언문이 더 좋을 수 있다.

함수 선언문은 함수가 선언된 위치에 상관없이 함수 호이스팅의 특징을 살리면 어디서든 호출할 수 있고, 또 변수 선언과 뚜렷하게 구별되는 차이점이 있다.

둘 중 어느것이 더 낫다는 없으니 상황에 맞게 적절하게 사용하면 된다.

### Function 생성자

Function 생성자 함수를 사용해서 함수를 생성하는 방식이다. → 좋지 않은 방법 ❌

```jsx
const add = new Function("a", "b", "return a+b");

add(10, 24); // 34
```

### 화살표 함수

ES6에서 새롭게 추가된 함수 생성 방식이다.

`function` 이라는 키워드 대신 ⇒ 라는 화살표를 활용해서 함수를 생성한다.

```jsx
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

그러나 화살표 함수는 겉보기와 다르게 앞에 언급한 함수 생성 방식과 몇 가지 큰 차이점이 있다.

1. 화살표 함수에는 `constructor`를 사용할 수 없다. 즉, 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

   ```jsx
   const Car = (name) => {
     this.name = name;
   };

   // Uncaught TypeError: Car is not a constructor
   const myCar = new Car("하이");
   ```

2. 화살표 함수에서는 arguments가 존재하지 않는다.

   ```jsx
   function hello() {
     console.log(arguments);
   }

   // Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
   hello(1, 2, 3);

   const hi = () => {
     console.log(arguments);
   };

   // Uncaught ReferenceError: arguments is not defined
   hi(1, 2, 3);
   ```

3. this 바인딩

   - 클래스 컴포넌트에서 이벤트에 바인딩할 메서드 선언 시 화살표 함수로 했을 때와 일반 함수로 했을 때 서로 다르게 작동한다.
   - this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다. this는 화살표 함수 이전까지는 함수를 정의할 때 결정되는 것이 아니라, 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다. 만약 함수가 일반 함수로서 호출된다면, 그 내부의 this는 전역 객체를 가리키게 된다.
   - 그러나 이와 달리 화살표 함수는 함수 자체의 바인딩을 갖지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.

   ✅ 클래스 컴포넌트에서 일반 함수와 화살표 함수로 state를 갱신하는 예제

   ```jsx
   class Component extends React.Component {
   	contructor(props) {
   		super(props)
   		this.state = {
   			counter: 1,
   		}
   	}

   	functionCountUp() {
   		console.log(thie) // undefined
   		this.setState((prev) => ){ counter: prev.counter + 1 }))
   	}

   	ArrowFunctionCountUp = () => {
   		console.log(this)  // class Component
   		this.setState((prev) => ({ counter: prev.counter + 1 }))
   	}

   	render() {
   		return (
   			<div>
   				{/* Cannot read properties of undefined (reading 'setState') */}
   				<button onClick={this.functionCountUp}>일반 함수</button>
   				{/* 정상적으로 작동한다. */}
   				<button onClick={this.ArrowFunctionCountUp}>화살표 함수</button>
   			</div>
   		)
   	}
   }
   ```

   → 화살표 함수에서는 별도의 작업을 추가로 하지 않고 this에 접근할 수 있다. 이러한 차이점은 바벨에서도 확인할 수 있다.

   ✅ 바벨 트랜스파일링으로 확인해 볼 수 있는 화살표 함수와 일반 함수의 차이

   ```jsx
   // 트랜스파일하기 전
   const hello = () => {
     console.log(this);
   };

   function hi() {
     console.log(this);
   }

   // 트랜스파일된 결과: 바벨에서는 이렇게 변환한다.
   var _this = void 0;

   var hello = function hello() {
     // 바벨에서 화살표 함수 내우븨 _this 자체를 undefined로 바꿔버린다.
     console.log(_this);
   };

   function hi() {
     console.log(this);
   }
   ```

   → 화살표 함수는 this가 선언되는 시점에 이미 상위 스코프로 결정돼 있어 미리 \_this를 받아서 사용하는 모습과 다르게, 일반 함수는 호출하는 런타임 시점에 결정되는 this를 그대로 따르는 모습이다.

## 🖌️ 즉시 실행 함수 & 고차함수

### 즉시 실행 함수

즉시 실행 함수(Immediately Invoked Function Expression, 일반적으로 IIFE라고 부른다)는 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다. 단 한 번만 호출되고, 다시 호출할 수 없는 함수다(그래서 즉시 실행 함수에 이름을 붙이지 않는다).

```jsx
(function (a, b) {
	return a + b
})(10, 24);  // 34

((a, b) => {
	return a + b
	},
)(10, 24) // 34
```

- 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점을 얻을 수 있다. → 함수의 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부에 있는 값은 그 함수 내부가 아니고서는 접근이 불가능하기 때문!
- 코드를 읽고 다시 호출되지 않기 때문에 리팩터링에도 매우 도움이 된다.

### 고차 함수

고차 함수(Higher Order Function)은 함수를 인수로 받거나 결과를 새로운 함수로 반환시키는 함수이다.

```jsx
// 함수를 매개변수로 받는 대표적인 고차 함수, Array.prototype.map
const doubleArray = [1, 2, 3].map((item) => item * 2);

doubleArray; // [2, 4, 6]

// 함수를 반환하는 고차 함수의 예
const add = function (a) {
  // a가 존재하는 클로저를 생성
  return function (b) {
    // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성
    return a + b;
  };
};

add(1)(3); // 4
```

## 🖌️ 함수를 만들 때 주의사항

### 함수의 부수 효과를 최대한 억제하라

함수의 부수 효과(side-effect)란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다. → 부수 효과가 없는 함수를 순수 함수라 하고, 부수 효과가 존재하는 함수를 비순수 함수라고 한다.

즉, 순수 함수는 부수 효과가 없고, 언제 어디서나 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환해야 한다. 그리고 동작 중 외부에 어떠한 영향도 미쳐서는 안된다.

```jsx
function PureComponent(props) {
  const { a, b } = props;
  return <div>{a + b}</div>;
}
```

불가피하게 웹 애플리케이션을 개발하면서 피할 수 없는 부수효과는

- 컴포넌트 내부에서 API를 호출할 경우 (외부에 어떠한 영향(HTTP request)을 끼침)
- console.log 사용 (브라우저의 콘솔 창이라는 외부에 영향을 끼침)
- HTML 문서의 title을 바꿈

→ 리액트 관점에서는 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 부수 효과를 최대한 억제할 수 있는 방향이다.

useEffect의 사용은 피할 수 없지만 최소한으로 줄임으로써 함수의 역할을 좁히고, 버그를 줄이며, 컴포넌트의 안정성을 높일 수 있다.

❣️자바스크립트 함수에서는 가능한 한 부수 효과를 최소화하고, 한수의 실행과 결과를 최대한 예측 가능하도록 설계해야한다.

### 가능한 한 함수를 작게 만들어라

함수의 길이읭 최적의 길이로 하도록 최대한 함수의 크기를 작게 하라

### 누구나 이해할 수 있는 이름을 붙여라

- 이름은 간결하고 이해하기 쉽게 붙이는 것이 좋다.
- 프로젝트의 프레임워크에 Tester가 설치돼 있다면 한글로 네이밍하는 것도 좋은 방법이다.
- 리액트에서 사용하는 useEffect나 useCallback 등의 훅에 넘겨주는 콜백 함수에 네이밍을 붙여주면 가독성에 도움이 된다.
  ```jsx
  uesEffect(function apiRequest() {
    // ...
  }, []);
  ```
  → 주의할 점은 uesEffect의 콜백 함수에 이름을 붙여줘도 apiReauest()와 같은 형태로 호출하거나 접근할 수 있는 것은 아니다!

# 📑 클래스

클래스에 대해 이해한다면, 왜 리액트가 패러다임을 바꾼지고 알 수 있고 오래된 리액트 코드를 리팩터링하는 데도 도움이 될 것이다.

또한 자바스크립트의 프로토타입 기반으로 작동하는 클래스의 원리를 이해한다면 프로토타입에 대해서도 알 수 있게 된다.

## 🖌️ 클래스란 무엇인가?

자바스크립트의 클래스란 특정한 객체를 만들기 위한 일종의 템플릿 같은 개념으로 볼 수 있다.

즉, 특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것이 클래스이다.

자바스크립트에서 클래스를 활용하면 객체를 만드는 데 필요한 데이터나 이를 조작하는 코드를 추상화해 객체 생성을 더욱 편리하게 할 수 있다.

클래스가 나오기 이전(ES6)에는 클래스라는 개념이 없어 객체를 만드는 템플릿 같은 역할을 함수가 도맡아 했다. → 자바스크립트에서 클래스로 하는 모든 것들을 함수로도 동일하게 표현할 수 있다는 의미이다.

```jsx
// Car 클래스 선언
class Car {
	// contructor는 생성자다. 최초에 생성할 때 어떤 인수를 받을지 결정할 수 있으며,
	// 객체를 초기화하는 용도로도 사용된다.
	constructor(name) {
		this.name = name
	}

	// 메서드
	honk() {
		console.log(`${this.name}이 경적을 울립니다!`)
	}

	// 정적 메서드
	static hello() {
		console.log('저는 자동차입니다')
	}

	// setter
	set age(value) {
		this.carAge = value
	}

	// getter
	set age() {
		return this.carAge
	}
}

	// Car 클래스를 활용해 car 객체를 만들었다.
	const myCar = new Car('자동차')

	//메서드 호출
	myCar.honk()

	// 정적 메서드는 클래스에서 직접 호출한다.
	Car.hello()

	// 정적 메서드는 클래스로 만든 객체에서는 호출할 수 없다.
	// Uncaught TypeError: myCar.hello is not a function
	myCar.hello()

	// setter를 만들면 값을 할당할 수 있다.
	myCar.age = 32

	// getter로 값을 가져올 수 있다.
	console.log(myCar.age, myCar.name) // 32 자동차
```

### constructor

- constructor는 생성자로, 객체를 생성하는 데 사용하는 특수한 메서드다.
- 하나만 존재할 수 있으며, 여러 개를 사용하면 에러가 발생한다.
- 생략 가능

### 프로퍼티

- 프로퍼티란 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값을 의미한다.

```jsx
class Car {
  constructor(name) {
    // 값을 받으면 내부에 프로퍼티로 할당된다.
    this.name = name;
  }
}

const myCar = new Car("자동차"); // 프로퍼티 값을 넘겨준다.
```

### getter와 setter

- getter란 클래스에서 무언가 값을 가져올 때 사용한다. → `get [getter이름]`
  ```jsx
  get firstChracter() {
  	return this.name[0];
  }
  ```
- setter란 클래스 필드에 값을 할당할 때 사용한다. → `set [setter이름]`
  ```jsx
  set firstCharacter(char) {
  	this.name = [char, ...this.name.slice(1)].join('')
  }
  ```

### 인스턴스 메서드

- 클래스 내부에서 선언한 메서드를 인스턴스 메서드라고 한다.
- 이 인스턴스 메서드는 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 한다.

그렇다면 prototype에 선언된다는 의미가 무엇일까??

```jsx
class Car {
  constructor(name) {
    this.name = name;
  }

  // 인스턴스 메서드 정의
  hello() {
    console.log(`안녕하세요, ${this.name}입니다.`);
  }
}
```

hello라는 인스턴스 메서드는 다음과 같이 선언할 수 있다.

```jsx
const myCar = new Car("자동차");
myCar.hello(); // 안녕하세요, 자동차입니다.
```

→ 이렇게 접근할 수 있는 이유는 앞서 프로토타입 메서드라고도 불리는 이유, 즉 메서드가 prototype에 선언됐기 때문이다.

```jsx
const myCar = new Car("자동차");

Object.getPrototypeOf(myCar); // {constructor: f, hello: f}
```

→ Object.getPrototypeOf를 사용하면, 인수로 넘겨준 변수의 prototype을 확인할 수 있다.

```jsx
Object.getPrototypeOf(myCar) === Car.prototype; // true

myCar.__proto__ === Car.prototype; // true
```

→ `__proto__` 도 `Object.getPrototypeOf`와 동일하게 작동한다.

❣️하지만 **proto**는 가급적 사용하면 ❌

→ `__proto__`는 typeof null === ‘object’와 유사하게 원래 의도한 표준은 아니지만 과거 브라우저가 이를 사용했기 때문에 유지되는, 호환성을 지키기 위해서만 존재하는 기능이기 때문이다.

- 직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것을 바로 프로토타입 체이닝이라고 한다.
- 모든 객체는 프로토타입을 가지고 있는데, 특정 속성을 찾을 때 자기 자신부터 시작해서 이 프로토타입을 타고 최상위 객체인 Object까지 훑는다. 이 경우 myCar에서 시작해서 부모인 Car에서 hello를 찾는 프로토타입 체이닝을 거쳐서 비로소 hello를 호출할 수 있게 됐다.
- 이와 비슷한 원리로 `toString`을 예로 들 수 있다.
  - toString은 객체 어디에서도 선언하는 경우가 없지만 대부분의 객체에서 모두 사용할 수 있다. 이는 toString도 마찬가지로 프로토타입 체이닝을 거쳐 Object에 있는 toString을 만나기 때문이다.

즉, 결론적으로 프로토타입과 프로토타입 체이닝이라는 특성 덕분에 생성한 객체에서도 직접 선언하지 않은, 클래스에 선언한 hello() 메서드를 호출할 수 있고, 이 메서드 내부에서 this도 접근해 사용할 수 있게 된다.

### 정적 메서드

- 정적 메서드는 특이하게 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드다.

```jsx
class Car {
  static hello() {
    console.log(`안녕하세요!`);
  }
}

const myCar = new Car();

myCar.hello(); // Uncaught TypeError: myCar.hello is not a function
Car.hello(); // 안녕하세요!
```

- 정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌, 클래스 자신을 가리키기 때문에 다른 메서드에서 일반적으로 사용하는 this를 사용할 수 없다.
  → 이러한 이유로 리액트 클래스 컴포넌트 생명주기 메서드인 `static getDerivedStateFromProps(props, state)`에서는 `this.state`에 접근할 수 없다.
- 정적 메서드는 this에 접근할 수 없지만 인스턴스를 생성하지 않아도 사용할 수 있다는 점, 그리고 생성하지 않아도 접근할 수 있기 때문에 객체를 생성하지 않더라도 여러 곳에서 재사용이 가능하다는 장점이 있다. 그래서 애플리케이션 전역에서 사용하는 유틸 함수를 정적 메서드로 많이 활용하는 편이다.

### 상속

- extends 라는 키워드를 사용하는데 이는 기존 클래스를 상속받아서 자식 클래스에서 이 상속받은 클래스를 기반으로 확장하는 개념이라고 볼 수 있다.
  - ex) `extends React.Component` 또는 `extends React.PureComponent`

```jsx
class Car {
  constructor(name) {
    this.name = name;
  }

  honk() {
    console.log(`${this.name} 경적을 울립니다!`);
  }
}

class Truck extends Car {
  constructor(name) {
    // 부모 클래스의 constructor, 즉 Car의 constructor를 호출한다.
    super(name);
  }

  load() {
    console.log("짐을 싣습니다.");
  }
}

const myCar = new Car("자동차");
myCar.honk(); // 자동차 경적을 울립니다!

const truck = new Truck("트럭");
truck.honk(); // 트럭 경적을 울립니다!
truck.load(); // 짐을 싣습니다!
```

## 🖌️ 클래스와 함수의 관계

- 클래스는 ES6에서 나온 개념으로, ES6 이전에는 프로토타입을 활용해 클래스의 작동 방식을 동일하게 구현할 수 있다. 즉, 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것이라고 볼 수 있다.

✅ 클래스 코드를 바벨로 변환한 결과

```jsx
//클래스 코드
class Car {
  constructor(name) {
    this.name = name;
  }

  honk() {
    console.log(`${this.name}이 경적을 울립니다!`);
  }

  static hello() {
    console.log("저는 자동차입니다");
  }

  set age(value) {
    this.carAge = value;
  }

  get age() {
    return this.carAge;
  }
}

// 바벨로 변환한 결과
("use strict");

// 클래스가 함수처럼 호출되는 것을 방지
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// 프로퍼티를 할당하는 코드
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

// 프로토타입 메서드와 정적 메서드를 선언하는 코드
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}

var Car = /*#__PURE__*/ (function () {
  function Car(name) {
    _classCallCheck(this, Car);

    this.name = name;
  }

  _createClass(
    Car,
    [
      {
        key: "honk",
        value: function honk() {
          console.log(
            "".concat(
              this.name,
              "\uC774 \uACBD\uC801\uC744 \uC6B8\uB9BD\uB2C8\uB2E4!"
            )
          );
        },
      },
      {
        key: "age",
        get: function get() {
          return this.carAge;
        },
        set: function set(value) {
          this.carAge = value;
        },
      },
    ],
    [
      {
        key: "hello",
        value: function hello() {
          console.log("저는 자동차입니다");
        },
      },
    ]
  );

  return Car;
})();
```

→ ES6 미만 환경에서는 동작하지 않는 클래스를 구현하기 위해 \_createClass라는 헬퍼 함수를 만들어 클래스와 동일한 방식으로 동작할 수 있도록 변경한 것을 확인할 수 있다.

위 코드를 좀 더 보기 쉽게 변경한 코드는 다음과 같다.

```jsx
var Car = (function () {
	function Car(name) {
		this.name = name
	}

	// 프로토타입 메서드. 실제로 프로토타입에 할당해야 프로토타입 메서드로 작동한다.
	Car.prototype.honk = function () {
		console.log(`${this.name}이 경적을 울립니다!`);
	}

	//정적 메서드. 인스턴스 생성 없이 바로 호출 가능하므로 직접 할당했다.
	Car.hello = function() {
		console.log('저는 자동차입니다')
	}

	// Car 객체에 속성을 직접 정의했다.
	Object.defineProperty(Car, 'age' {
		// get과 set은 각각 접근자, 설정자로 사용할 수 있는 예약어다.
		// getter
		get: function () {
			return this.carAge
		},
		// setter
		set: function (value) {
			this.carAge = value
		},
	})

	return Cat
})()
```

→ 클래스는 객체지향 언어를 사용하던 다른 프로그래머가 좀 더 자바스크립트에 접근하기 쉽게 만들어주는, 일종의 문법적 설탕(systactic sugar)의 역할을 한다고 볼 수 있다.

또한 자바스크립트 클래스가 프로토타입을 기반으로 작동한다는 사실도 확인할 수 있다.

# 📑 클로저

## 🖌️ 클로저의 정의

- `클로저(Closure)`는 자바스크립트 고유의 개념이 아니라 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
- 클로저란 함수와 함수가 선언된 어휘적 환경의 조합이다.

MDN에 나온 정의로는 이해가 안되는게 쉽게 말하자면 다음과 같다.

- 자신이 선언된 당시의 환경을 기억하는 함수
- 생명 주기가 끝난 외부 함수의 변수에 접근할 수 있는 내부 함수

✅ 어휘적 환경이 무엇일까?

```jsx
function add() {
  const a = 10;
  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }

  innerAdd(); // 30
}

add();
```

→ add 함수 내부에 innerAdd가 있다.

→ innerAdd 함수는 내부에서 b 변수를 선언한 뒤, 자신의 함수 외부에 있는 a와 b를 더해서 정상적으로 30을 출력한다.

→ 이는 함수가 중첩되어있다.

→ a 변수의 유효 범위는 add 전체이고, b의 유효 범위는 innerAdd의 전체이다. innerAdd는 add 내부에서 선언돼 있어 a를 사용할 수 있게 된다.

즉! `“선언된 어휘적 환경”` 의 의미는 변수가 코드 내부에서 어디서 선언됐는지를 의미한다.

## 🖌️ 변수의 유효 범위, 스코프

### 전역 스코프

- 전역 레벨에 선언하는 것을 전역 스코프(global scope)라고 한다. 이 스코프에서 변수를 선언하면 어디서든 호출할 수 있게 된다.
- 브라우저 환경에서 전역 객체는 window, Node.js 환경에서는 global이 있는데, 바로 이 객체에 전역 레벨에서 선언한 스코프가 바인딩된다.

### 함수 스코프

- 자바스크립트는 { } 블록이 스코프 범위를 결정하지 않고 기본적으로 함수 레벨 스코프를 따른다.

```jsx
if (true) {
  var global = "global scope";
}

console.log(global); // 'global scope'
console.log(global === window.global); // true
```

→ var global은 { } 내부에서 선언돼 있는데, { } 밖에서도 접근이 가능하다. 그 이유는 기본적으로 자바스크립트는 함수 레벨 스코프를 가지고 있기 때문이다.

→ 하지만 if 블록이 아닌 함수 블록 내부에서는 일반적으로 예측하는 것과 같이 스코프가 결정된다.

```jsx
function hello() {
  var local = "local variable";
  console.log(local); // local variable
}

hello();
console.log(local); // Uncaught ReferenceError: local is not defined
```

→ 만약 스코프가 중첩되어 있다면 일단 가장 가까운 스코프에서 변수가 존재하는지 먼저 확인해본다.

## 🖌️ 클로저의 활용

```jsx
function outerFunction() {
  var x = "hello";
  function innerFunction() {
    console.log(x);
  }

  return innerFunction;
}

const innerFunction = outerFunction();
innerFunction(); // 'hello'
```

- outerFunction은 innerFunction을 반환하며 실행이 종료됐다.
- 반환한 함수에는 x라는 변수가 존재하지 않지만, 해당 함수가 선언된 어휘적 환경, 즉 outerFunction에는 x라는 변수가 존재하며 접근할 수도 있다.
- 따라서 같은 환경에서 선언되고 반환된 innerFunction에서는 x라는 변수가 존재하던 환경을 기억하기 때문에 정상적으로 ‘hello’를 출력할 수 있다.

- 전역 스코프는 어디서든 원하는 값을 꺼내올 수 있다는 장점이 있지만, 반대로 이야기하면 누구든 접근할 수 있고 수정할 수 있다는 뜻이다.
  → 이를 클로저를 활용한 코드로 작성하면 다음과 같다.
  ```jsx
  function Counter() {
    var counter = 0;

    return {
      increase: function () {
        return ++counter;
      },
      decrease: function () {
        return --counter;
      },
      counter: function () {
        console.log("counter에 접근!");
        return counter;
      },
    };
  }

  var c = Counter();

  console.log(c.increase()); // 1
  console.log(c.increase()); // 2
  console.log(c.increase()); // 3
  console.log(c.decrease()); // 2
  console.log(c.counter()); // 2
  ```
  ✅ https://ui.dev/javascript-visualizer 에서 ES5 자바스크립트 코드를 입력해 실행하면 자바스크립트 코드가 어떤 식으로 실행되고 있는지, 어떤 클로저가 현재 존재하는지 등도 확인할 수 있다.
  ✅ 이와 같이 코드를 변경했을 때 얻을 수 있는 이점
  1. counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막는다. + 접근하는 경우를 제한해 로그를 남기는 등의 부차적인 작업도 수행가능.
  2. counter 변수의 업데이트를 increase와 decrease로 제한해 무분별하게 변경되는 것을 막는다.

     ⇒ 이처럼 클로저를 활용하면 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다.
  👉🏻 리액트에서는 클로저를 useState의 변수를 저장해두고, useState의 변수 접근 및 수정 또한 클로저 내부에서 확인이 가능해 값이 변하면 렌더링 함수를 호출하는 등의 작업이 이루어진다.

### 리액트에서의 클로저

- 리액트 함수 컴포넌트의 훅에서 클로저의 원리로 사용하고 있는 것이 대표적으로 `useState`이다.

```jsx
function Component() {
  const [state, setState] = useState();

  function handleClick() {
    // useState 호출은 위에서 끝났지만, setState는 계속 내부의 최신값(prev)을 알고 있다.
    // 이는 클로저를 활용했기 때문에 가능하다.
    setState((prev) => prev + 1);
  }

  // ...
}
```

- 클로저가 useState 내부에서 활용됐기 때문에 외부 함수(useState)가 반환한 내부 함수(setState)는 외부 함수(useState)의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경(state가 저장돼 있는 어딘가)을 기억하기 때문에 계속해서 state 값을 사용할 수 있는 것이다.

## 🖌️ 주의할 점

```jsx
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```

- 0부터 시작해 1초 간격으로 console.log로 0,1,2,3,4를 차례로 출력하는걸 의도했지만 실제로는 0,1,2,3,4초 뒤에 5만 출력된다.
- 그 이유는 i가 전역 변수로 작동하기 때문이다.
  - 자바스크립트는 기본적으로 함수 레벨 스코프를 따르고 있기 때문에 var는 for 문의 존재와 상관없이 해당 구문이 선언된 함수 레벨 스코프를 바라보고 있으므로 함수 내부 실행이 아니라면 전역 스코프에 var i가 등록돼 있을 것이다.
  - for 문을 다 순회한 이후, 태스크 큐에 있는 setTimeout을 실행하려고 했을 때, 이미 전역 레벨에 있는 i는 5로 업데이트가 완료돼 있다.

👇🏻 올바르게 수정하는 방법

1. 함수 레벨 스코프가 아닌 블록 레벨 스코프를 갖는 let으로 수정한다.
   - let은 기본적으로 블록 레벨 스코프를 가지게 되므로 let i가 for 문을 순회하면서 각각의 스코프를 갖게 된다. 이는 setTimeout이 실행되는 시점에도 유효해서 각 콜백이 의도한 i 값을 바라보게 할 수 있다.
2. 클로저를 제대로 활용한다.

   ```jsx
   for (var i = 0; i < 5; i++) {
     setTimeout(
       function (sec) {
         return function () {
           console.log(sec);
         };
       },
       i,
       i * 1000
     );
   }
   ```

   - for 문 내부에 즉시 실행 익명 함수를 선언했다.
   - 이 즉시 실행 함수는 i를 인수로 받는데, 이 함수 내부에서는 이를 sec이라고 하는 인수에 저장해 두었다가 setTimeout의 콜백 함수에 넘기게 된다. 이렇게 되면 setTimeout의 콜백 함수가 바라보는 클로저는 즉시 실행 익명 함수가 되는데, 이 즉시 실행 익명 함수는 각 for 문마다 생성되고 실행되기를 반복한다. 그리고 각각의 함수는 고유한 스코프, 즉 고유한 sec을 가지게 되므로 올바르게 실행할 수 있게 된다.

❣️클로저의 기본 개념, ‘함수와 함수가 선언된 어휘적 환경의 조합’을 주의 깊게 살펴봐야 클로저를 제대로 활용할 수 있다.

❣️클로저를 사용할 때 한 가지 주의할 점은, 클로저를 사용하는 데는 비용이 든다. → 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생한다.

✅ 클로저 유무의 차이 비교

1. 일반적인 함수로 처리

```jsx
const aButton = document.getElementById("a");

function heavyJob() {
  const longArr = Array.from({ length: 10000000 }, (_, i) => i + 1);
  console.log(longArr.length);
}

aButton.addEventListener("click", heavyJob);
```

1. 클로저로 처리

```jsx
function heavyJobWithClosure() {
  const longArr = Array.from({ length: 1000000 }, (_, i) => i + 1);
  return function () {
    console.log(longArr.length);
  };
}

const innerFunc = heavyJobWithClosure();
bButton.addEventListener("click", function () {
  innerFunc();
});
```

- 일반적인 함수와 클로저를 사용한 함수가 실제로 어떤 차이가 있는지 크롬 개발자 도구에서 직접 확인해 볼 수 있다.
  - 클로저를 활용하는 함수는 클로저 heavyJobWithClosure()로 분리해 실행하고, 이를 onClick에서 실행하는 방식인데 이미 스크립트를 실행하는 시점부터 아주 큰 배열을 메모리에 올려두고 시작한다.
  - 클로저의 기본 원리에 따라, 클로저가 선언된 순간 내부 함수는 외부 함수의 선언적인 환경을 기억하고 있어야 하므로 이를 어디에서 사용하는지 여부에 관계없이 저장해 둔다.
  - 실제로는 onClick 내부에서만 사용하고 있지만 이를 알 수 있는 방법이 없기 때문에 긴 배열을 저장해 두고 있다.
  - 반면 일반 함수의 경우에는 클릭 시 스크립트 실행히 조금 길지만 클릭과 동시에 선언, 그리고 길이를 구하는 작업이 모두 스코프 내부에서 끝났기 때문에 메모리 용량에 영향을 미치지 않는다.

따라서 클로저의 개념, 즉 외부 함수를 기억하고 이를 내부 함수에서 가져다 쓰는 메커니즘은 성능에 영향을 미친다. 클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리를 불필요하게 잡아먹고 클로저 사용을 적절한 스코프로 가둬두지 않으면 성능에 악영향을 미친다.

# 📑 이벤트 루프와 비동기 통신의 이해

자바스크립트는 싱글 스레드이다. 즉, 기본적으로 자바스크립트는 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다. 동기(synchronous)에 대해 간단하게 설명하자면 직렬 방식으로 작업을 처리하는 것을 의미하며, 이 요청이 시작된 이후에는 무조건 응답을 받은 이후에야 비로소 다른 작업을 처리할 수 있다. 그 동안 다른 모든 작업은 대기한다.

반대로 비동기(asynchronous)란 직렬 방식이 아니라 병렬 방식으로 작업을 처리하는 것을 의미한다. 요청을 시작한 후 이 응답이 오건 말건 상관없이 다음 작업이 이루어지기 때문에 한번에 여러 작업이 실행될 수 있다.

자바스크립트는 분명히 싱글 스레드에서 동기 방식으로 작동하는데 이러한 싱글 스레드 기반의 자바스크립트에서도 많은 양의 비동기 작업이 이루어지고 있다.

따라서 자바스크립트 환경에서 이러한 것이 어떻게 가능한지 알기 위해서는 비동기 작업이 어떻게 처리되는지 이해하고 비동기 처리를 도와주는 이벤트 루프를 비롯한 다양한 개념에 대해 알고 있어야 한다.

❣️비동기 코드의 작동 방식에 대해 이해한다면 자바스크립트에서 어떻게 여러 가지 요청을 동시에 처리하고 있는지, 이러한 요청받은 태스크에 대한 우선순위는 무엇인지, 또 주의할 점은 무엇인지 파악하면 사용자에게 더욱 매끄러운 웹 애플리케이션 서비스를 제공할 수 있다.

## 🖌️ 싱글 스레드 자바스크립트

자바스크립트는 싱글 스레드 언어인데 싱글 스레드에 대해 알아보기 전에 프로그램을 실행하는 단위인 프로세스에 대해 알아보자.

`프로세스(process)`란 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위를 의미한다. 즉, 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것을 의미한다.

그러나 소프트웨어가 복잡해지면서 하나의 프로그램에서 동시에 여러 개의 작업을 수행하게 되면서 하나의 프로세스만으로는 이러한 작업이 수행하기 어려워 더 작은 실행 단위인 `스레드(thread)`가 탄생했다.

하나의 프로세스에는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다. 이에 따라 프로세스 내부에서 여러 개의 스레드를 활용하면서 동시 다발적인 작업을 처리할 수 있게 된다.

⁉️그럼 자바스크립트는 왜 싱글 스레드로 설계된걸까?

우선 멀티 스레드는 처리가 복잡한 단점이 있다. 스레드는 하나의 프로세스에서 동시에 서로 같은 자원에 접근할 수 있는데, 동시에 여러 작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등 동시성 문제가 발생할 수 있어 이에 대한 처리가 필요하다.

또한 각각 격리돼 있는 프로세스와는 다르게, 하나의 스레드가 문제가 생기면 같은 자원을 공유하는 다른 스레드에도 동시에 문제가 일어날 수 있다.

⁉️자바스크립트가 싱글 스레드라는 것은 무엇을 의미할까?

하나의 스레드에서 순차적으로 이루어진다는 것은 코드를 한 줄 한 줄 실행한다는 것을 의미하며 궁극적으로 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다는 것을 의미한다. C언어나 다른 메이저 프로그래밍 언어에서는 스레드에서 실행 중인 함수를 시스템이 임의로 멈추고 다른 스레드의 코드를 먼저 실행할 수 있지만 자바스크립트에는 그런 기능이 없다.

- `Run-to-completion` : 자바스크립트의 모든 코드는 ‘동기식’으로 한 번에 하나씩 순차적으로 처리된다(자바스크립트에서 하나의 코드가 실행하는 데 오래 걸리면 뒤이은 코드가 실행되지 않는다는 것).

반대로 비동기는 동시에 일어나지 않는다는 것을 의미한다. 동기식과 다르게 요청한 즉시 결과가 주어지지 않을 수도 있고, 응답이 언제 올지도 알 수 없다. 하지만 동기식과 다르게 여러 작업을 동시에 수행할 수 있다는 장점이 있다.

자바스크립트 특징상 싱글 스레드로 작동하기 때문에 모든 코드는 “Run-to-completion”으로 작동해야 하는데 그렇지 않다. 그 이유는 `이벤트 루프`에 있으니 아래에서 이벤트 루프에 대해 알아보자.

## 🖌️ 이벤트 루프란?

이벤트 루프는 ECMAScript, 즉 자바스크립트 표준에 나와 있는 내용은 아니다.

이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라 볼 수 있다.

### 호출 스택과 이벤트 루프

- `호출 스택(call stack)`은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.

```jsx
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo();
```

이 코드는 foo를 호출하고, 내부에서 bar, baz를 순차적으로 호출하는 구조로 되어 있다. 아래와 같은 순서로 호출 스택에 쌓이고 비워지게 된다.

1. foo()가 호출 스택에 먼저 들어간다.
2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo()는 존재)
4. bar()가 호출 스택에 들어간다.
5. bar() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
6. 5의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo(), bar()는 존재)
7. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
8. baz()가 호출 스택에 들어간다.
9. baz() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
10. 9의 실행이 완료된 이후에 다음 코드로 넘어간다 (아직 foo(), baz()는 존재)
11. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
12. 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거된다.
13. 이제 호출 스택이 완전히 비워졌다.

→ 여기서 호출 스택이 비어 있느지 여부를 확인하는 것이 바로 이벤트 루프이다.

→ 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.

❣️`’코드를 실행하는 것’`과 `‘호출 스택이 비어 있는지 확인하는 것’` 모두 단일 스레드에서 일어난다. 이 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어난다.

✅ 비동기 작업은 다음과 같이 실행된다.

```jsx
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar(), 0); // setTimeout만 추가했다.
  baz();
}

foo();
```

1. foo()가 호출 스택에 먼저 들어간다.
2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo()는 존재)
4. setTimeout(bar(), 0)이 호출 스택에 들어간다.
5. 4번에 대해 타이머 이벤트가 실행되며 태스크 큐로 들어가고, 그 대신 바로 스택에서 제거된다.
6. baz()가 호출 스택에 들어간다.
7. baz() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
8. 7의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo(), baz()는 존재)
9. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
10. 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거된다.
11. 이제 호출 스택이 완전히 비워졌다.
12. 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인했다. 그러다 태스크 큐를 확인하니 4번에 들어갔던 내용이 있어 bar()를 호출 스택에 들여보낸다.
13. bar() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
14. 13의 실행이 끝나고, 다음 코드로 넘어간다. (아직 bar() 존재)
15. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다.

→ 이 코드를 보면 , `setTimeout(() ⇒ {}), 0)`이 정확하게 0초 뒤에 실행된다는 것을 보장하지 못한다.

이벤트 루프는 **태스크 큐**를 한 개 이상 가지고 있다.

태스크 큐란 실행해야 할 태스크의 집합을 의미한다. 또한 태스크 큐는 자료 구조의 큐(queue)가 아니고 set 형태를 띠고 있다. 그 이유는 실행 가능한 가장 오래된 태스크를 가져와야하기 때문에 FIFO형식이 아닌 방식으로 동작한다.

태스크 큐에서 의미하는 **‘실행해야 할 태스크’**라는 것은 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.

즉, 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다.

호출 스택이 비었다면 태스크 큐에 대기 중인 작업이 있는지 확인하고, 이 작업을 실행 가능한 오래된 것부터 순차적으로 꺼내와서 실행하게 된다. → 태스크 큐가 비어있을 때까지 반복하게된다.

⁉️ 그렇다면 비동기 함수는 누가 수행할까?

⁉️ n초 뒤에 setTimeout을 요청하는 작업은 누가 처리할까?

⁉️ fetch를 기반으로 실행되는 네트워크 요청은 누가 보내고 응답을 받을 것인가?

👉🏻 모두 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드인 태스크 큐에 작업을 할당해 처리하는 브라우저나 Node.js에 의해 수행된다.

즉, 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web API등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다.

그래서 이벤트 루프는 호출 스택이 비고, 콜백이 실행 가능한 때가 오면 이것을 거내서 수행하는 역할을 한다.

만약 이 작업들이 모두 자바스크립트 코드가 실행되는 메인 스레드에서만 이루어진다면 절대로 비동기 작업을 수행할 수 없을 것이다.

## 🖌️ 태스크 큐와 마이크로 태스크 큐

이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다.

- 마이크로 태스크가 처리하는 것들 중 대표적으로 Promise가 있다.
- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다. 즉, setTimeout과 setInterval은 Promise보다 늦게 실행된다. → 마이크로 태스크 큐가 빌 때까지 기존 태스크 큐의 실행은 뒤로 미뤄진다.

```jsx
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

setTimeout(foo, 0);

Promise.reslove().then(bar).then(baz);
```

이 코드에서 각 태스크에 들어가는 대표적인 작업은 다음과 같다.

- 태스크 큐 : setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐 : process.nextTick, Promises, queueMicroTask, MutationObserver

→ 태스크 큐를 실행하기 전에 마이크로 태스크 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.

✅ 동기 코드, 태스크 큐, 마이크로 태스크 큐와 렌더링과의 관계를 확인할 수 있는 코드

```jsx
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      <li>동기 코드: <button id="sync">0</button></li>
      <li>태스크: <button id="macrotask">0</button></li>
      <li>마이크로 태스크: <button id="microtask">0</button></li>
    </ul>

    <button id="macro_micro">모두 도시 실행</button>
  </body>
  <script>
    const button = document.getElementById("run");
    const sync = document.getElementById("sync");
    const macrotask = document.getElementById("macrotask");
    const microtask = document.getElementById("microtask");

    const macro_micro = document.getElementById("macro_micro");

    // 동기 코드로 버튼에 1부터 렌더링
    sync.addEventListener("click", function () {
      for (let i = 0; i < 100000; i++) {
        sync.innerHTML = i;
      }
    });

    // setTimeout으로 태스크 큐에 작업을 넣어서 1부터 렌더링
    macrotask.addEventListener("click", function () {
      for (let i = 0; i < 100000; i++) {
        setTimeout(() => {
          macrotask.innerHTML = i;
        }, 0);
      }
    });

    // queueMicrotask으로 마이크로 태스크 큐에 작업을 넣어서 1부터 렌더링
    microtask.addEventListener("click", function () {
      for (let i = 0; i < 100000; i++) {
        queueMicrotask(() => {
          microtask.innerHTML = i;
        });
      }
    });

    macro_micro.addEventListener("click", function () {
      for (let i = 0; i < 100000; i++) {
        sync.innerHTML = i;

        setTimeout(() => {
          macrotask.innerHTML = i;
        }, 0);

        queueMicrotask(() => {
          microtask.innerHTML = i;
        });
      }
    });
  </script>
</html>

```

- 동기 코드는 우리가 예상했던 것처럼 해당 연산, 즉 100,000까지 숫자가 올라가기 전까지는 렌더링이 일어나지 않다가 for 문이 끝나야 비로소 렌더링 기회를 얻으며 100,000이라는 숫자가 한 번에 나타난다.
- 태스크 큐(setTimeout)는 모든 setTimeout 콜백이 큐에 들어가기 전까지 잠깐의 대기 시간을 갖다가 1부터 100,000까지 순차적으로 렌더링되는 것을 볼 수 있다.
- 마이크로 태스크 큐(queueMicrotask)는 동기 코드와 마찬가지로 렌더링이 전혀 일어나지 않다가 100,000까지 다 끝난 이후에야 한 번에 렌더링이 일어난다.
- 모든 것을 동시에 실행했을 경우 동기 코드와 마이크로 태스크 큐만 한 번에 100,000까지 올라가고, 태스크 큐만 앞선 예제처럼 순차적으로 렌더링되는 것을 볼 수 있다.

이 작업 순서는 requestAnimationFrame(브라우저에 다음 리페인트 전에 콜백 함수 호출을 가능하게 하는 메서드)으로도 확인할 수 있다.

```jsx
console.log("a");

setTimeout(() => {
  console.log("b");
}, 0);

Promise.resolve().then(() => {
  console.log("c");
});

window,
  requestAnimationFrame(() => {
    console.log("d");
  });
```

- a, b, c, d 순서로 출력된다. 즉, 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어난다.

❣️결론적으로 동기 코드는 물론 마이크로 태스크 또한 렌더링에 영향을 미친다. 따라서 특정 렌더링이 자바스크립트 내 무거운 작업과 연관이 있다면 이를 어떤 식으로 분리해서 사용자에게 좋은 애플리케이션 경험을 제공해 줄지 고민해 보아야 한다.

# 📑 리액트에서 자주 사용하는 자바스크립트 문법

자바스크립트 표준을 ECMAScript라고 하는데, 작성하고자 하는 자바스크립트 문법이 어느 ECMAScript 버전에서 만들어졌는지도 파악해야 한다. 그 이유는 모든 브라우저와 자바스크립트 런타임이 항상 새로운 자바스크립트 문법을 지원하는 것이 아니기 때문이다.

그리고 웹페이지에 접근하는 사용자의 브라우저와 버전은 개발자와 다르게 항상 최신 버전이 아니고, 크롬, 사파리, 파이어폭스 등 다양하기 때문에 이러한 다양한 브라우저에서의 문법 지원을 염두에 두어야 한다.

하지만 아예 해결 방법이 없는건 아니다. 사용자의 다양한 브라우저 환경, 그리고 최신 문법을 작성하고 싶은 개발자의 요구를 해결하기 위해 탄생한 것이 바로 바벨이다. 바벨은 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일한다. 바벨이 어떻게 최신 코드를 트랜스파일하는지, 그리고 그 결과 어떤 코드가 생성되는지 이해하면 향후 애플리케이션을 디버깅하는 데 도움이 된다.

인터넷 익스프롤러 1의 지원은 종료되었지만 여전히 어느 정도 사용중이기도 하고, 호환모드를 활성화하면 엣지 환경에서도 인터넷 익스프롤러 환경으로 페이지에 접근할 수 있기 때문에 위의 바벨 코드는 ES5를 기준으로 작성되었다.

또한 셋톱박스와 같이 업데이트를 쉽게 할 수 없는 구형 기기에서도 ES5만 작동하는 경우가 있으므로 ES5 기준으로 트랜스파일된 코드를 파악하는 것이 중요하다.

[바벨이란??](https://www.notion.so/368ae2abae1a43e1b4ee32672ebec436?pvs=21)

## 🖌️ 구조 분해 할당

구조 분해 할당(Destructuring assignment)이란 배열 또는 객체의 값을 말 그대로 분해해 개별 변수에 즉시 할당하는 것을 의미한다.

배열과 객체에 주로 사용되며, 어떠한 객체나 배열에서 선언문 없이 즉시 분해해 변수를 선언하고 할당하고 싶을 때 사용한다.

### 배열 구조 분해 할당

리액트에서 많이 사용되는 useState 함수는 첫 번째 값을 value로, 두 번째 값을 setter로 사용 가능하다.

객체 구조 분해 할당은 사용하는 쪽에서 원하는 이름으로 변경하는 것이 번거롭지만 배열 구조 분해 할당은 자유롭게 일므을 선언할 수 있기 때문에 useState는 배열을 반환하는 것으로 추측할 수 있다.

- 중간 인덱스에 대한 할당을 생략

```jsx
const array = [1, 2, 3, 4, 5];
const [first, , , , fifth] = array; // 2, 3, 4는 아무런 표현식이 없으므로 변수 할당이 생략돼 있다.

first; // 1
fifth; // 5
```

- 기본값을 선언

```jsx
const array = [1, 2];
const [a = 10, b = 10, c = 10] = array;
// a 1
// b 2
// c 10
```

→ 만약 사용하고자 하는 배열의 길이가 짧거나 값이 없을 경우에 (undefined) 기본값을 사용할 것이다.

❣️한 가지 주의할 것은 반드시 undefined일 때만 기본값을 사용한다

```jsx
const [a = 1, b = 1, c = 1, d = 1, e = 1] = [undefined, null, 0, ""];
a; // 1
b; // null
c; // 0
d; // ''
e; // 1
```

→ 여기서 구조 분해 할당에서 기본값을 사용하는 것은, a와 e뿐이다. 자바스크립트에서 기본값을 사용할 수 있는 경우는 undefined일 때뿐이다.

따라서 a는 명시적으로 undefined가 지정돼 있고, e의 경우에는 배열의 길이를 넘어서서 구조 분해 할당됐으므로 undefined로 평가되어 기본값이 할당된다.

- 특정값 이후의 값을 다시금 배열로 선언하고 싶다면 뒤이어 소개할 전개 연산자(spread operator)인 …을 사용할 수도 있다.

```jsx
const array = [1, 2, 3, 4, 5];
const [first, ...rest] = array;

// first 1
// rest [2, 3, 4, 5]
```

→ 뒤에 …을 사용하면 나머지 모든 값을 해당 변수에 배열로 넣게 된다. 이는 어디서부터 어디까지 할당한지 예측할 수 있는 뒤쪽에서만 가능하다.

✅ 배열 구조 분해 할당 예제

```jsx
// 트랜스파일하기 전
const array = [1, 2, 3, 4, 5];
const [first, second, third, ...arrayRest] = array;

// 트랜스파일된 결과
var array = [1, 2, 3, 4, 5];
var first = array[0],
  second = array[1],
  third = array[2],
  arrayRest = array.slice(3);
```

### 객체 구조 분해 할당

```jsx
const object = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
  e: 5,
};

const { a, b, c, ...objectRest } = object;
// a 1
// b 2
//c 3
// objectRest = {d: 4, e: 5}
```

- 새로운 이름으로 다시 할당 가능

```jsx
const object = {
  a: 1,
  b: 2,
};

const { a: first, b: secode } = object;
// first 1
// second 2
```

- 기본값으로 주는 것도 가능

```jsx
const object = {
  a: 1,
  b: 2,
};

const { a = 10, b = 10, c = 10 } = object;

// a 1
// b 1
// c 10
```

👇🏻 이러한 방식은 리액트 컴포넌트인 props에서 값을 바로 꺼내올 때 자주 쓰이는 방식이다.

```jsx
function SampleComponent({ a, b }) {
  return a + b;
}

SampleComponent({ a: 3, b: 5 }); // 8
```

- 단순히 값으로 꺼내오는 것뿐만 아니라 변수에 있는 값으로 꺼내오는 계산된 속성 이름 방식도 가능하다.

  ```jsx
  const key = "a";
  const object = {
    a: 1,
    b: 1,
  };

  const { [key]: a } = object;

  // a = 1
  ```

  → key는 a라는 값을 가지고 있는데, object에서 이 a라는 값을 꺼내오기 위해 [key] 문법을 사용했다.

  → 이러한 계산된 속성 이름을 사용하려면 반드시 이름을 선언하는 :a와 같은 변수 네이밍이 필요하다. 그렇지 않으면 에러가 발생한다.

  > const {[key]} = object // Uncaught SystaxError: Unexpected token ‘[’

- 전개 연산자 …를 사용하면 나머지 값을 모두 가져올 수 있다.

```jsx
const object = {
  a: 1,
  b: 1,
  c: 1,
  d: 1,
  e: 1,
};

const { a, b, ...rest } = object;

// rest { c: 1, d: 1, e: 1 }
```

→ 배열과 마찬가지로 전개 연산자는 앞이 아닌 뒤에만 와야한다. 그렇지 않으면 오류가 발생한다.

✅ 객체 구조 분해 할당 예제

```jsx
// 트랜스파일하기 전
const object = {
  a: 1,
  b: 1,
  c: 1,
  d: 1,
  e: 1,
};

const { a, b, ...rest } = object;

// 트랜스파일된 결과
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutProperties(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

function _objectwithourPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKey.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var object = {
  a: 1,
  b: 1,
  c: 1,
  d: 1,
  e: 1,
};

var a = object.a,
  b = object.b;
rest = _objectWithoutProperties(objet, ["a", "b"]);
```

- \_objectWithoutPropertiesLoose는 객체와 해당 객체에서 제외할 키가 포함된 배열 두 가지를 인수로 받는데, 이 두가지 값을 활용해서 해당 객체에서 특정 키를 제외하는 것을 확인할 수 있다.
- \_objectWithoutProperties 함수는 Object.getOwnPropertySymbols가 존재하는 환경인 경우(즉 객체 내부에서 심벌의 존재를 확인할 수 있는 경우)를 대비해 이에 대한 예외 처리 또한 추가로 더해주고 있다.

→ 이처럼 객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때문에 만약 자신의 웹 애플리케이션 개발 환경이 ES5를 고려해야 하고, 또 객체 구조 분해 할당을 자주 쓰지 않는다면 꼭 써야 하는지 검토할 필요가 있다.

만약 객체 구조 분해 할당을 통한 …rest와 같은 함수가 필요하다면 외부 라이브러리를 사용해 보는 것도 고려해 보면 좋다. ex) `lodash.omit, rambda.omit`

## 🖌️ 전개 구문

전개 구문(Spread Syntax)은 앞서 소개한 구조 분해 할당과는 다르게 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 말 그대로 전개해 간결하게 사용할 수 있는 구문이다.

### 배열의 전개 구문

```jsx
const arr1 = ["a", "b"];
const arr2 = [...arr1, "c", "d", "e"]; // ['a', 'b', 'c', 'd', 'e']
```

- 배열 내부에서 `…배열`을 사용하면 해당 배열을 마치 전개하는 것처럼 선언하고, 이를 내부 배열에서 활용할 수 있다.
- 이러한 특징을 활용하면 기존 배열에 영향을 미치지 않고 배열을 복사하는 것도 가능하다.

```jsx
const arr1 = ["a", "b"];
const arr2 = arr1;

arr1 === arr2; // true  내용이 아닌 참조를 복사하기 때문에 true가 반환된다.

const arr1 = ["a", "b"];
const arr2 = [...arr1];

arr1 === arr2; // false 실제로 값만 복사됐을 뿐, 참조는 다르므로 false가 반환된다.
```

### 객체의 전개 구문

```jsx
const obj1 = {
  a: 1,
  b: 2,
};

const obj2 = {
  c: 3,
  d: 4,
};

const newObj = { ...obj1, ...obj2 };
// { "a" : 1, "b" : 2, "c" : 3, "d" : 4 }
```

❣️객체 전개 구문에서는 순서가 중요하다. 위에 있을 때와 아래에 있을 때의 작동의 순서 차이로 인해 전혀 다른 객체가 생성될 수 있다.

위의 코드들이 바벨에서 어떻게 변환되는지 아래 코드에서 확인해보자.

✅ 배열 구조 분해 할당 예제

```jsx
// 트랜스파일하기 전
const arr1 = ["a", "b"];
const arr2 = [...arr1, "c", "d", "e"];

// 트랜스파일된 결과
var arr1 = ["a", "b"];
var arr2 = [].concat(arr1, ["c", "d", "e"]);
```

✅ 객체 구조 분해 할당 예제

```jsx
// 트랜스파일하기 전
const obj1 = {
  a: 1,
  b: 2,
};

const obj2 = {
  c: 3,
  d: 4,
};

const newObj = { ...obj1, ...obj2 };

// 트랜스파일된 결과
function ownKey(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly &&
      (symbol = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })),
      keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2
      ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(
          target,
          Object.getOwnPropertyDescriptors(source)
        )
      : ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(
            target,
            key,
            Object.getOwnPropertyDescriptor(source, key)
          );
        });
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumeragle: true,
      configurable: true,
      writable: true,
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var obj1 = {
  a: 1,
  b: 2,
};
var obj2 = {
  c: 3,
  d: 4,
};

var newObj = _objectSpread(_objectSpread({}, obj1), obj2);
```

→ 단순히 값을 복사하는 배열과 다르게 객체의 경우 객체의 속성값 및 설명자 확인, 심벌 체크 등 때문에 트랜스파일된 코드가 커지는 것을 볼 수 있다.

→ 객체 구조 분해 할당과 마찬가지로, 객체 전개 연산자 또한 트랜스파일되면 상대벅으로 번들링이 커지기 때문에 사용할 때 주의할 필요가 있다.

## 🖌️ 객체 초기자

객체 초기자는 객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식이다.

```jsx
const a = 1
const b = 2

const obj - {
	a,
	b,
}

// {a: 1, b: 2}
```

- 원래대로라면 a: a와 같은 형식으로 작성해야 하는데, 넣어야 할 키와 값이 각각 a와 1이고, 이미 해당 내용으로 선언된 변수가 있다면 위와 같은 형식으로 축약해서 선언하는 것이 가능해진다.

바벨로 트랜스파일을 거쳤을 때도 간단하다.

✅ 객체 초기자 예제

```jsx
// 트랜스파일하기 전
const a = 1;
const b = 2;

const obj = {
  a,
  b,
};

// 트랜스파일된 결과
var a = 1;
var b = 2;
var obj = {
  a: a,
  b: b,
};
```

→ 별도의 작업을 거치지 않고, 단순히 키와 값 할당 형식으로 변경되었다.

## 🖌️ Array 프로토타입의 메서드: map, filter, reduce, forEach

`Array.prototype.map`, `Array.prototype.filter`, `Array.prototype.reduce`는 모두 배열과 관련된 메서드다.

JSX 내부에서 배열을 조작해 바로 원하는 JSX를 반환하는 특성상 이 3개의 메서드가 자주 쓰인다.

기존 배열의 값을 건드리지 않고 새로운 값을 만들어 내기 때문에 기존 값이 변경될 염려가 없다.

forEach까지 포함해서 ES5부터 사용한 문법이기 때문에 별도의 트랜스파일이나 폴리필이 없어도 부담 없이 사용할 수 있다.

### Array.prototype.map

`Array.prototype.map`은 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드다.

배열의 각 아이템을 순회하면서 각 아이템을 콜백으로 연산한 결과로 구성된 새로운 배열을 만들 수 있다.

```jsx
const arr = [1, 2, 3, 4, 5];
const doubleArr = arr.map((item) => item * 2);
// [2, 4, 6, 8, 10]
```

👇🏻 리액트에서는 주로 특정 배열을 기반으로 어떠한 리액트 요소를 반환하고자 할 때 주로 사용

```jsx
const arr = [1, 2, 3, 4, 5];
const Elements = arr.map((item) => {
  return <Fragment key={item}>{itme}</Fragment>;
});
```

### Array.prototype.filter

`Array.prototype.filter` 메서드는 콜백 함수를 인수로 받는데, 이 콜백 함수에서 truthy 조검을 만족하는 경우에만 해당 원소를 반환하는 메서드다.

말 그대로 필터링하는 역할의 메서드이며, filter의 결과에 따라 원본 배열의 길이 이하의 새로운 배열이 반환된다. → 즉 map과 다르게 같은 크기의 배열이 나오지 않을 수도 있다.

주로 어떠한 조건을 만족하는 새로운 배열을 반환할 때 쓰인다.

```jsx
const arr = [1, 2, 3, 4, 5];
const evenARr = arr.filter((item) => item % 2 === 0);
// [2, 4]
```

### Array.prototype.reduce

`Array.prototype.reduce`는 콜백 함수와 함께 초깂값을 추가로 인수를 받는데, 이 초기값에 따라 배열이나 객체, 또는 그 외의 다른 무언가를 반환할 수 있는 메서드다.

즉, reducer 콜백 함수를 실행하고, 이를 초깃값에 누적해 결과를 반환한다.

```jsx
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce((result, item) => {
  return result + item;
}, 0);
// 15
```

- 0은 reduce의 결과를 누적할 초깃값이다.
- reducer 콜백 함수의 첫 번째 인수는 선언한 초깃값의 현재값을 의미하고, 두 번째 인수는 현재 배열의 아이템을 의미한다.
- 즉, 콜백의 반환값을 계속해서 초깃값에 누적하면서 새로운 값을 만든다고 볼 수 있다.

- reduce는 단순히 합계를 구하는 것뿐만 아니라 배열을 원하는 하나의 객체로 변환하는 등 다양한 예제에서 사용된다.
- reduce는 filter와 map보다 복잡하여 짧은 코드라면 filter와 map을 각각 활용하는 것이 좋다.

✅ filter와 map의 조합과 reduce를 사용한 배열 처리 비교

```jsx
// 짝수만 100을 곱해 반환하는 함수의 예제
const arr = [1, 2, 3, 4, 5];

// [200, 400]
const result1 = arr.filter((item) => item % 2 === 0).map((item) => item * 100);

// [200, 400]
const result2 = arr.reduce((result, item) => {
  if (item % 2 === 0) {
    result.push(item * 100);
  }
  return result;
}, []);
```

### Array.prototype.forEach

`Array.prototype.forEach`는 콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백 함수를 실행하기만 하는 메서드다.

```jsx
const arr = [1, 2, 3];

arr.forEach((item) => console.log(item));
// 1, 2, 3
```

❣️주의사항

- forEach는 아무런 반환값이 없다. → 단순히 콜백 함수를 실행할 뿐, map과 같이 결과를 반환하는 작업은 수행하지 않는다.
- 즉, 콜백 함수 내부에서 아무리 반환해도 모두 의미 없는 값이 된다. forEach의 반환값은 undefined로 의미가 없다.
- forEach는 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 이를 멈출 수 없다. → break, return 등 무엇을 이용해도 배열 순회를 멈출 수 없다.

```jsx
function run() {
  const arr = [1, 2, 3];
  arr.forEach((item) => {
    console.log(item);
    if (item === 1) {
      console.log("finished!");
    }
  });
}

// 이 함수를 실행하면 다음과 같은 결과를 볼 수 있다.
run();

// 1
// finished!
// 2
// 3
```

- 중간에 return이 존재해 함수 실행이 끝났어도 forEach 콜백이 실행된다. 그 이유는 return이 함수의 return이 아닌 콜백 함수의 return으로 간주되기 때문이다.
  → 따라서 forEach를 사용할 때는 절대로 중간에 순회를 멈출 수 없다!
- forEach 내부의 콜백 함수는 무조건 0(n)만큼 실행되므로 코드 작성과 실행 시에 반드시 최적화할 가능성이 있는지 검토해보는 것이 필요하다.

## 🖌️ 삼항 조건 연산자

```jsx
조건문 ? 참일_때_값 : 거짓일_때_값;
```

- 맨 앞에 true/false를 판별할 수 있는 조건문이 들어가고 그 이후에 물음표가 들어간다. 물음표 뒤에는 참일 경우 반환할 값, : 뒤에는 거짓일 때 반환할 값을 지정한다.

리액트에서는 If 조건문을 간단하게 쓸 수 있다는 점에서 자주 사용되며, JSX 내부에서 조건부로 렌더링하기 위해서 가장 널리 쓰이는 방법이다.

```jsx
function Component({ condition }) {
  return <>{condition ? "참" : "거짓"}</>;
}
```

또한 삼항 연산자를 중첩해서 사용하는 경우도 종종 발생하는데 연산의 결과를 쉽게 예측하기 어려우므로 가급적이면 중첩해서 사용하지 않는것이 좋다.

# 📑 선택이 아닌 필수, 타입스크립트

## 🖌️ 타입스크립트란?

- 타입스크립트는 기존 자바스크립트 + 타입 이 합쳐진 개념이다.
- 자바스크립트는 기본적으로 동적 타입의 언어이기 때문에 대부분의 에러를 코드를 실행했을 때만 확인할 수 있는데 이는 개발자에게 자유를 주기도 하지만 코드의 규모가 커질수록 오히려 발목을 잡는 경우도 많다.
- 타입스크립트는 자바스크립트의 한계를 벗어나 타입 체크를 정적으로 런타임이 아닌 빌드(트랜스파일) 타임에 수행할 수 있게 해준다.

✅ 자바스크립트일 경우

```jsx
function test(a, b) {
	if (typeof a !== 'number' || typeof b !== 'number') {
		throw new Error('a와 b 모두 숫자여야 합니다.')
	}
	return a / b
)

test('안녕하세요', '하이') // Uncaught Error: a와 b 모두 숫자여야 합니다.
```

✅ 타입스크립트일 경우

```jsx
function test(a: number, b: number) {
  return a / b;
}

// tsc로 이 코드를 자바스크립트로 트랜스파일하면 다음과 같은 에러가 난다.
// Argument of type 'string' is not assignable to parameter of type 'number'
// 이 코드는 타입 문제가 해결되기 전까지 쓸 수 없다.
test("안녕하세요", "하이");
```

- 변수 a와 b에는 number 타입만 올 수 있다.
- 타입스크립트는 이러한 특징 덕분에 굳이 런타임까지 가지 않고 코드를 빌드하는 시점에 이미 에러가 발생할 가능성이 있는 코드를 확인할 수 있다.
- 즉, 타입스크립트는 자바스크립트의 슈퍼셋으로 함수의 변환 타입, 배열, enum 등 기존에는 사용하기 어려웠던 타입 관련 작업들을 손쉽게 처리할 수 있다.

## 🖌️ 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

### any 대신 unknown을 사용하자

any는 불가피할때만 사용해야 한다. 그 이유는 any를 사용한다는 것은 사실 타입스크립트가 제공하는 정적 타이핑의 이점을 모두 버리는 것이다.

any 대신 불가피하게 아직 타입을 단정할 수 없는 경우에는 `unknown`을 사용하는 것이 좋다.

`unknown`은 모든 값을 할당할 수 있는 top type으로, 어떠한 값도 할당할 수 있다.

```jsx
function doSomething(callback: unknown) {
  if (typeof callback === "function") {
    callback();
    return;
  }

  throw new Error("callback은 함수여야 합니다.");
}
```

- typeof를 사용해서 unknown에 직접 접근하는 대신, 해당 unknown 값이 우리가 원하는 타입일 때만 의도대로 작동하도록 수정했다.

  → unknown을 사용하는 것은 예상치 못한 타입을 받아들일 수 있고, 사용하는 쪽에서도 더욱 안전하게 쓸 수 있다.

- top type인 unknown과 반대되는 bottom type으로 `never`가 있다.
  ```jsx
  type what1 = string & number;
  type what2 = ("hello" | "hi") & "react";
  ```
  - `what1`은 string과 number를 교차하는 타입이다. string과 number 둘 다 만족시키지 못하는 타입은 존재하지 않기때문에 never이 선언된다.
  - `what2`도 양쪽 두 타입에는 교차점이 없기 때문에 never가 선언된다.

✅ 실제 사용 예

```jsx
// string이 키지만 값은 never다. 즉 어떠한 값도 올 수 없다.
type Props = Record<string, never>
tyep State = {
	counter: 0
}

class SampleComponent extends React.Component<Props, State> {
	constuctor(props: Props) {
		super(props)
		this.state = {
			counter: 0,
		}
	}

	render() {
		return <>...</>
	}
}

export default function App() {
	return (
		<>
			{/* OK */}
			<SampleComponent />
			{/* Type 'string' is not assignable to type 'never' */}
			<SampleComponent hello="world" />
		</>
	)
}
```

- SampleComponent는 어떠한 props도 받을 수 없는 대신, state가 존재한다. React.Component의 제네릭은 Props와 State를 순서대로 작성해야 하는데, Props의 경우 Record<string, never>로 작성해 어떠한 props도 받을 수 없도록 타입스크립트로 처리할 수 있다.

### 타입 가드를 적극 활용하자

- `instanceof`와 `typeof`
  - `instanceof`는 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자다.

✅ instanceof를 활용한 타입가드 예제

```jsx
class UnAuthorizedError extends Error {
  constructor() {
    super();
  }

  get message() {
    return "인증에 실패했습니다.";
  }
}

class UnExpectedError extends Error {
  constructor() {
    super();
  }

  get message() {
    return "예상치 못한 에러가 발생했습니다.";
  }
}

async function fetchSomething() {
  try {
    const response = await fetch("/api/something");
    return await response.json();
  } catch (e) {
    // e는 unknown이다.

    // UnAuthorizedError를 위한 타입 가드 조건문
    if (e instanceof UnAuthorizedError) {
      //...
    }

    // UnAuthorizedError를 위한 타입 가드 조건문
    if (e instanceof UnExpectedError) {
      // ...
    }

    throw e;
  }
}
```

- unknown으로 내려오는 에러에 대해 타입 가드를 통해 타입을 좁힘으로써 각 에러에 따라 원하는 처리 내용을 추가할 수 있다.

- `typeof`는 특정 요소에 대해 자료형을 확인하는 데 사용된다.

  ✅ `typeof`을 사용한 예제

  ```jsx
  function logging(value: string | undefined) {
    if (typeof value === "string") {
      console.log(value);
    }

    if (typeof value === "undefined") {
      return;
    }
  }
  ```

- `in`
  - `in`은 property in object로 사용되는데, 주로 어떤 객체에 키가 존재하는지 확인하는 용도로 사용된다.
  ```jsx
  interface Student {
  	age: number
  	score: number
  }

  interface Teacher {
  	name: string
  }

  function doSchool(person: Student | Teacher) {
  	if ('age' in person) {
  		person.age // person은 Student
  		person.score
  	}

  	if ('name' in person) {
  		person.name // person은 Teacher
  	}
  }
  ```

### 제네릭

- 제네릭(generic)은 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구다.
- 제네릭을 사용하면 타입만 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 간결하게 작성할 수 있다.

```jsx
function getFirstAndLas(list: unknown[]) {
  return [list[0], list[list.length - 1]];
}

const [first, last] = getFirstAndLast([1, 2, 3, 4, 5]);

first; // unknown
last; // unknown
```

→ 다양한 타입을 받아들이기 위해 top type인 unknown을 썼지만 정작 결과물도 unknown이 나와서 타입을 좁혀야만 했다. 이 문제를 제네릭으로 해결할 수 있다.

다음 예제는 위 코드를 T라는 제네릭을 선언해, 이를 각각 배열의 요소와 반환 값의 요소로 사용한 예제이다.

```jsx
function getFirstAndLas<T>(list: T[]): [T, T] {
  return [list[0], list[list.length - 1]];
}

const [first, last] = getFirstAndLast([1, 2, 3, 4, 5]);

first; // number
last; // number

const [first, last] = getFirstAndLast(["a", "b", "c", "d", "e"]);

first; // string
last; // string
```

- 제네릭 덕분에 getFirstAndLast 함수는 다양한 타입을 처리할 수 있는 함수로 변모했다.

리액트에서 제네릭을 사용할 수 있는 코드로는 대표적으로 useState를 떠올릴 수 있다.

```jsx
function Component() {
  // state: string
  const [state, setState] = useState < string > "";
}
```

- useState에 제네릭으로 타입을 선언한다면 state 사용과 기본값 선언을 좀 더 명확하게 할 수 있다.
- 흔히 useState()와 같은 형식으로 기본값을 넘기지 않고 사용하는 경우가 많은데, 이 경우 값을 undefined로 추론해 버리는 문제가 발생하다. 따라서 제네릭으로 기본값을 선언해 주면 이러한 문제를 타입스크립트가 방지해 줄 수 있다.

### 인텍스 시그니처

- 인덱스 시그니처란 객체의 키를 정의하는 방식을 의미한다.

```jsx
type Hello = {
  [key: string]: string,
};

const hello: Hello = {
  hello: "hello",
  hi: "hi",
};

hello["hi"]; // hi
hello["안녕"]; //undefined
```

- `[ key: string ]`을 사용한 부분이 인덱스 시그니처이다. 인덱스 시그니처를 사용하면 이처럼 키에 원하는 타입을 부여할 수 있다.

다음과 같이 Record를 사용하는 방법도 있다.

```jsx
// record를 사용
type Hello = Record<'hello' | 'hi', string>

const hello: Hello = {
	hello: 'hello',
	hi: 'hi',
}

// 타입을 사용한 인덱스 시그니처
type Hello = { [key in 'hello' | 'hi']: string }

const hello: Hello = {
	hello: 'hello',
	hi: 'hi',
}
```

- Record<key, value>를 사용하면 객체의 타입에 각각 원하는 키와 값을 넣을 수 있다. 그리고 인덱스 시그니처에 타입을 사용함으로써 객체를 원하는 형태로 최대한 좁힐 수 있다.

```jsx
Object.keys(hello).map((key) => {
  // Element implicitly has an 'any' type because expression of type 'string'
  // can't be used to index type 'Hello'
  // No index signature with a parameter of type 'string' aws found on type 'Hello'
  const value = hello[key];
  return value;
});
```

- Object.keys가 string[]을 반환하는데, 이 string은 hello의 인덱스 키로 접근할 수 없기 때문에 위와같은 에러가 발생한다.
- 해결 방법은 아래와 같이 코드를 수정하면 된다.
  ```jsx
  Object.keys(hello) as Array<keyof Hello>.map((key) => {
  	const value = hello[key]
  	return value
  })
  ```
  - 이와 같이 Object.keys(hello)를 as로 타입을 단언하는 방법이다.
  - 타입스크립트의 Object.keys에 대한 반환 타입을 string[] 대신 개발자가 단언한 타입으로 강제하는 방법이다.
  ```jsx
  // 타입 가드 함수를 만드는 방법
  function keysOf<T extends Object>(obj: T): Array<keyof T> {
  	return Array.from(Object.keys(obj)) as Array<keyof T>
  }

  keysOf(hello).map((key) => {
  	const value = hello[key]
  	return value
  })
  ```
  → keysOf라고 하는 Object.keys를 대신할 함수를 만드는 것이다. 이 함수는 객체의 키를 가지고 오면서 동시에 이 가져온 배열에 대해서도 마찬가지로 타입 단언으로 처리하는 과정을 거친다.
  - 그리고 마지막으로 가져온 키를 단언하는 방법이 있다. 원리는 동일하다.
  ```jsx
  // 가져온 key를 단언하는 방법
  Object.keys(hello).map((key) => {
  	const value = hello[key as keyof Hello]
  	return value
  }
  ```

⁉️ 왜 Object.keys는 string[]으로 강제돼 있을까? useState와 같이 제네릭을 사용하지 않고, 혹은 적절히 함수 내부에서 추론할 수 있음에도 왜 string[]을 강제해 두었을까?

→ 자바스크립트의 특징과 이를 구현하기 위한 타입스크립트의 구조적 타이핑의 특징 때문이다.

→ 자바스크립트는 다른 언어에 비해 객체가 열려 있는 구조로 만들어져 있으므로 덕 타이핑(duck typing)으로 객체를 비교해야 하는 특징이 있다.

`덕 타이핑이란? 객체의 타입이 클래스 상속, 인터페이스 구현 등으로 결정되는 것이 아니고 어떤 객체가 필요한 변수와 메서드만 지니고 있다면 그냥 해당 타입에 속하도록 인정해 주는 것을 의미`

→ 이러한 특징 때문에 타입스크립트 인터페이스 소개란에 다음과 같은 문장으로 설명되어있다.

```jsx
타입스크립트 핵심 원칙 중 하나는 타입 검사가 값의 형태에 초점을 맞추단는 것입니다. 이를 "덕 타이핑" 또는 "구조적 서브타이핑"이라고 부르기도 합니다.
```

- 타입스크립트의 핵심 원칙은 타입 체크를 할 때 그 값이 가진 형태에 집중한다는 것이다. 이러한 것을 덕타이핑 또는 구조적 타이핑이라고 한다.

👇🏻 아래의 코드를 통해 덕 타이핑이 Object.keys와 무슨 관계가 있는지 알아보자.

```jsx
type Car = { name: string };
type Truck = Car & { power: number };

function horn(car: Car) {
  console.log(`${car.name}이 경적을 울립니다! 빵빵`);
}

const truck: Truck = {
  name: "비싼차",
  power: 100,
};

// 정상적으로 작동한다.
// Car에 필요한 속성은  다 가지고 있기 때문에 Car처럼 name을 가지고 있으므로 유효하가
horn(truck);
```

→ 이와같이 자바스크립트는 객체의 타입에 구애받지 않고 객체의 타입에 열려 있으므로 타입스크립트도 이러한 자바스크립트의 특징을 맞춰줘야 한다.

→ 즉, 타입스크립트는 이렇게 모든 키가 들어올 수 있는 가능성이 열려 있는 객체의 키에 포괄적으로 대응하기 위해 string[]으로 타입을 제공하는 것이다.

## 🖌️ 타입스크립트 전환 가이드

### tsconfig.json 먼저 작성하기

최상위 디렉터리에 tsconfig.json 생성

```jsx
{
	"compilerOptions": {
		"outDir": "./dist",
		"alowJs": true,
		"target": "es5"
	},
	"include": ["./src/**/*"]
}
```

- outDir은 .ts나 .js가 만들어진 결과를 넣어두는 폴더다. tsc는 타입스크립트를 자바스크립트로 변환하는 명령어인데, 이 tsc를 사용하면 결과물이 outDir로 넘어간다.
- allowJs는 .js 파일을 허용할 것인지 여부다. 자바스크립트가 존재하는 과도기적인 프로젝트이므로 true로 설정해둔다.
- target에는 결과물이 될 자바스크립트 버전을 지정한다.
- include에는 트랜스파일할 자바스크립트와 타입스크립트 파일을 지정한다.

이 외에 tsconfig.json에서 사용할 수 있는 옵션에 대해서 알고 싶으면 공식 문서를 참고하자. → https://www.typescriptlang.org/ko/docs/handbook/tsconfig-json.html

### JSDoc과 @ts-check를 활용해 점진적으로 전환하기

자바스크립트 파일을 굳이 타입스크립트로 전환하지 않더라도 타입을 체크하는 방법이 있다.

1. 파일 최상단에 //@ts-check를 선언
2. JSDoc을 활용해 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인

```jsx
// @ts-check

/**
 * @type {string}
 */
const str = true;

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
function sum(a, b) {
  return a + b;
}

/**
 * Function lacks ending return statement and return type does not include 'undefined'
 * @return {JSX.Element}
 */
export function SampleComponent() {
  // Argument of type 'string' is not assignable to parameter of type 'number' .ts
  const result1 = sum("a", "b");
  // Argument of type 'string' is not assignable to parameter of type 'number' .ts
  const result2 = sum(10, str);

  if (result1 && result2) {
    return (
      <>
        {result1} {result2}
      </>
    );
  }
}
```

- 위 코드와 같이 JSDoc을 추가하는 것도 손이 많이 가는 작업이기 때문에 만야 기존 프로젝트에서 JSDoc을 이미 사용했거나, 혹은 타입스크립트로 전환하기 어려울 때만 사용하고, 그 외에는 바로 .ts로 파일 확장자를 변경하고 바로 작업하는 것을 추천한다.

### 타입 기반 라이브버리 사용을 위해 @types 모듈 설치하기

자바스크립트 기반으로 작성된 라이브러리를 설치해서 사용하고 있다면 타입스크립트에서 이러한 라이브러리를 정상적으로 사용하기 위해서는 @types라 불리는 DefinitelyTyped를 설치해야 한다. 이는 타입스크립트로 작성되지 않은 코드에 대한 타입을 제공하는 라이브러리다.

리액트를 타입스크립트에서 사용하기 위해서도 이 모듈을 설치해야 한다. 리액트에 대한 타입은 @types/react와 @types/react-dom 등에 정의돼 있다.

타입스크립트 기반 프로젝트로 코드를 작성하려면 필요에 따라 @types 라이브러리를 설치해야 하지만 모든 라이브러리가 @types를 필요로 하는 것은 아니다.

→ 만약 파일을 .ts로 전환했는데 import에 `“Cannot find module ‘lodash’ or its corresponding type declarations”`라는 오류 메시지가 출력된다면 @types 라이브러리를 설치해야 한다.

이 오류 메시지는 Lodash라는 라이브러리 내부에서 별도의 d.ts와 같은 타입 파일을 제공하지 않기 때문에 발생하는 에러이다.

### 파일 단위로 조금씩 전환하기

자바스크립트 파일을 타입스크립트로 전환하는 과정에서 예기치 못한 타입 이슈를 접할 수도 있고, 또 사용하고 있는 라이브러리에서 타입을 제공하지 않을 수도 있기 때문에 점진적으로 타입스크립트로 전환하는것이 안전하다.
